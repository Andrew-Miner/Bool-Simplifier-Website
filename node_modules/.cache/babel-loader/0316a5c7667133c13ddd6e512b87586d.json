{"ast":null,"code":"/**\n * @license BitSet.js v5.1.1 2/1/2020\n * http://www.xarg.org/2014/03/javascript-bit-array/\n *\n * Copyright (c) 2020, Robert Eisele (robert@xarg.org)\n * Dual licensed under the MIT or GPL Version 2 licenses.\n **/\n(function (root) {\n  'use strict';\n  /**\n   * The number of bits of a word\n   * @const\n   * @type number\n   */\n\n  var WORD_LENGTH = 32;\n  /**\n   * The log base 2 of WORD_LENGTH\n   * @const\n   * @type number\n   */\n\n  var WORD_LOG = 5;\n  /**\n   * Calculates the number of set bits\n   *\n   * @param {number} v\n   * @returns {number}\n   */\n\n  function popCount(v) {\n    // Warren, H. (2009). Hacker`s Delight. New York, NY: Addison-Wesley\n    v -= v >>> 1 & 0x55555555;\n    v = (v & 0x33333333) + (v >>> 2 & 0x33333333);\n    return (v + (v >>> 4) & 0xF0F0F0F) * 0x1010101 >>> 24;\n  }\n  /**\n   * Divide a number in base two by B\n   *\n   * @param {Array} arr\n   * @param {number} B\n   * @returns {number}\n   */\n\n\n  function divide(arr, B) {\n    var r = 0;\n\n    for (var i = 0; i < arr.length; i++) {\n      r *= 2;\n      var d = (arr[i] + r) / B | 0;\n      r = (arr[i] + r) % B;\n      arr[i] = d;\n    }\n\n    return r;\n  }\n  /**\n   * Parses the parameters and set variable P\n   *\n   * @param {Object} P\n   * @param {string|BitSet|Array|Uint8Array|number=} val\n   */\n\n\n  function parse(P, val) {\n    if (val == null) {\n      P['data'] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n      P['_'] = 0;\n      return;\n    }\n\n    if (val instanceof BitSet) {\n      P['data'] = val['data'];\n      P['_'] = val['_'];\n      return;\n    }\n\n    switch (typeof val) {\n      case 'number':\n        P['data'] = [val | 0];\n        P['_'] = 0;\n        break;\n\n      case 'string':\n        var base = 2;\n        var len = WORD_LENGTH;\n\n        if (val.indexOf('0b') === 0) {\n          val = val.substr(2);\n        } else if (val.indexOf('0x') === 0) {\n          val = val.substr(2);\n          base = 16;\n          len = 8;\n        }\n\n        P['data'] = [];\n        P['_'] = 0;\n        var a = val.length - len;\n        var b = val.length;\n\n        do {\n          var num = parseInt(val.slice(a > 0 ? a : 0, b), base);\n\n          if (isNaN(num)) {\n            throw SyntaxError('Invalid param');\n          }\n\n          P['data'].push(num | 0);\n          if (a <= 0) break;\n          a -= len;\n          b -= len;\n        } while (1);\n\n        break;\n\n      default:\n        P['data'] = [0];\n        var data = P['data'];\n\n        if (val instanceof Array) {\n          for (var i = val.length - 1; i >= 0; i--) {\n            var ndx = val[i];\n\n            if (ndx === Infinity) {\n              P['_'] = -1;\n            } else {\n              scale(P, ndx);\n              data[ndx >>> WORD_LOG] |= 1 << ndx;\n            }\n          }\n\n          break;\n        }\n\n        if (Uint8Array && val instanceof Uint8Array) {\n          var bits = 8;\n          scale(P, val.length * bits);\n\n          for (var i = 0; i < val.length; i++) {\n            var n = val[i];\n\n            for (var j = 0; j < bits; j++) {\n              var k = i * bits + j;\n              data[k >>> WORD_LOG] |= (n >> j & 1) << k;\n            }\n          }\n\n          break;\n        }\n\n        throw SyntaxError('Invalid param');\n    }\n  }\n  /**\n   * Module entry point\n   *\n   * @constructor\n   * @param {string|BitSet|number=} param\n   * @returns {BitSet}\n   */\n\n\n  function BitSet(param) {\n    if (!(this instanceof BitSet)) {\n      return new BitSet(param);\n    }\n\n    parse(this, param);\n    this['data'] = this['data'].slice();\n  }\n\n  function scale(dst, ndx) {\n    var l = ndx >>> WORD_LOG;\n    var d = dst['data'];\n    var v = dst['_'];\n\n    for (var i = d.length; l >= i; l--) {\n      d.push(v);\n    }\n  }\n\n  var P = {\n    'data': [],\n    // Holds the actual bits in form of a 32bit integer array.\n    '_': 0 // Holds the MSB flag information to make indefinitely large bitsets inversion-proof\n\n  };\n  BitSet.prototype = {\n    'data': [],\n    '_': 0,\n\n    /**\n     * Set a single bit flag\n     *\n     * Ex:\n     * bs1 = new BitSet(10);\n     *\n     * bs1.set(3, 1);\n     *\n     * @param {number} ndx The index of the bit to be set\n     * @param {number=} value Optional value that should be set on the index (0 or 1)\n     * @returns {BitSet} this\n     */\n    'set': function (ndx, value) {\n      ndx |= 0;\n      scale(this, ndx);\n\n      if (value === undefined || value) {\n        this['data'][ndx >>> WORD_LOG] |= 1 << ndx;\n      } else {\n        this['data'][ndx >>> WORD_LOG] &= ~(1 << ndx);\n      }\n\n      return this;\n    },\n\n    /**\n     * Get a single bit flag of a certain bit position\n     *\n     * Ex:\n     * bs1 = new BitSet();\n     * var isValid = bs1.get(12);\n     *\n     * @param {number} ndx the index to be fetched\n     * @returns {number} The binary flag\n     */\n    'get': function (ndx) {\n      ndx |= 0;\n      var d = this['data'];\n      var n = ndx >>> WORD_LOG;\n\n      if (n >= d.length) {\n        return this['_'] & 1;\n      }\n\n      return d[n] >>> ndx & 1;\n    },\n\n    /**\n     * Creates the bitwise NOT of a set.\n     *\n     * Ex:\n     * bs1 = new BitSet(10);\n     *\n     * res = bs1.not();\n     *\n     * @returns {BitSet} A new BitSet object, containing the bitwise NOT of this\n     */\n    'not': function () {\n      // invert()\n      var t = this['clone']();\n      var d = t['data'];\n\n      for (var i = 0; i < d.length; i++) {\n        d[i] = ~d[i];\n      }\n\n      t['_'] = ~t['_'];\n      return t;\n    },\n\n    /**\n     * Creates the bitwise AND of two sets.\n     *\n     * Ex:\n     * bs1 = new BitSet(10);\n     * bs2 = new BitSet(10);\n     *\n     * res = bs1.and(bs2);\n     *\n     * @param {BitSet} value A bitset object\n     * @returns {BitSet} A new BitSet object, containing the bitwise AND of this and value\n     */\n    'and': function (value) {\n      // intersection\n      parse(P, value);\n      var T = this['clone']();\n      var t = T['data'];\n      var p = P['data'];\n      var pl = p.length;\n      var p_ = P['_'];\n      var t_ = T['_']; // If this is infinite, we need all bits from P\n\n      if (t_ !== 0) {\n        scale(T, pl * WORD_LENGTH - 1);\n      }\n\n      var tl = t.length;\n      var l = Math.min(pl, tl);\n      var i = 0;\n\n      for (; i < l; i++) {\n        t[i] &= p[i];\n      }\n\n      for (; i < tl; i++) {\n        t[i] &= p_;\n      }\n\n      T['_'] &= p_;\n      return T;\n    },\n\n    /**\n     * Creates the bitwise OR of two sets.\n     *\n     * Ex:\n     * bs1 = new BitSet(10);\n     * bs2 = new BitSet(10);\n     *\n     * res = bs1.or(bs2);\n     *\n     * @param {BitSet} val A bitset object\n     * @returns {BitSet} A new BitSet object, containing the bitwise OR of this and val\n     */\n    'or': function (val) {\n      // union\n      parse(P, val);\n      var t = this['clone']();\n      var d = t['data'];\n      var p = P['data'];\n      var pl = p.length - 1;\n      var tl = d.length - 1;\n      var minLength = Math.min(tl, pl); // Append backwards, extend array only once\n\n      for (var i = pl; i > minLength; i--) {\n        d[i] = p[i];\n      }\n\n      for (; i >= 0; i--) {\n        d[i] |= p[i];\n      }\n\n      t['_'] |= P['_'];\n      return t;\n    },\n\n    /**\n     * Creates the bitwise XOR of two sets.\n     *\n     * Ex:\n     * bs1 = new BitSet(10);\n     * bs2 = new BitSet(10);\n     *\n     * res = bs1.xor(bs2);\n     *\n     * @param {BitSet} val A bitset object\n     * @returns {BitSet} A new BitSet object, containing the bitwise XOR of this and val\n     */\n    'xor': function (val) {\n      // symmetric difference\n      parse(P, val);\n      var t = this['clone']();\n      var d = t['data'];\n      var p = P['data'];\n      var t_ = t['_'];\n      var p_ = P['_'];\n      var i = 0;\n      var tl = d.length - 1;\n      var pl = p.length - 1; // Cut if tl > pl\n\n      for (i = tl; i > pl; i--) {\n        d[i] ^= p_;\n      } // Cut if pl > tl\n\n\n      for (i = pl; i > tl; i--) {\n        d[i] = t_ ^ p[i];\n      } // XOR the rest\n\n\n      for (; i >= 0; i--) {\n        d[i] ^= p[i];\n      } // XOR infinity\n\n\n      t['_'] ^= p_;\n      return t;\n    },\n\n    /**\n     * Creates the bitwise AND NOT (not confuse with NAND!) of two sets.\n     *\n     * Ex:\n     * bs1 = new BitSet(10);\n     * bs2 = new BitSet(10);\n     *\n     * res = bs1.notAnd(bs2);\n     *\n     * @param {BitSet} val A bitset object\n     * @returns {BitSet} A new BitSet object, containing the bitwise AND NOT of this and other\n     */\n    'andNot': function (val) {\n      // difference\n      return this['and'](new BitSet(val)['flip']());\n    },\n\n    /**\n     * Flip/Invert a range of bits by setting\n     *\n     * Ex:\n     * bs1 = new BitSet();\n     * bs1.flip(); // Flip entire set\n     * bs1.flip(5); // Flip single bit\n     * bs1.flip(3,10); // Flip a bit range\n     *\n     * @param {number=} from The start index of the range to be flipped\n     * @param {number=} to The end index of the range to be flipped\n     * @returns {BitSet} this\n     */\n    'flip': function (from, to) {\n      if (from === undefined) {\n        var d = this['data'];\n\n        for (var i = 0; i < d.length; i++) {\n          d[i] = ~d[i];\n        }\n\n        this['_'] = ~this['_'];\n      } else if (to === undefined) {\n        scale(this, from);\n        this['data'][from >>> WORD_LOG] ^= 1 << from;\n      } else if (0 <= from && from <= to) {\n        scale(this, to);\n\n        for (var i = from; i <= to; i++) {\n          this['data'][i >>> WORD_LOG] ^= 1 << i;\n        }\n      }\n\n      return this;\n    },\n\n    /**\n     * Clear a range of bits by setting it to 0\n     *\n     * Ex:\n     * bs1 = new BitSet();\n     * bs1.clear(); // Clear entire set\n     * bs1.clear(5); // Clear single bit\n     * bs1.clear(3,10); // Clear a bit range\n     *\n     * @param {number=} from The start index of the range to be cleared\n     * @param {number=} to The end index of the range to be cleared\n     * @returns {BitSet} this\n     */\n    'clear': function (from, to) {\n      var data = this['data'];\n\n      if (from === undefined) {\n        for (var i = data.length - 1; i >= 0; i--) {\n          data[i] = 0;\n        }\n\n        this['_'] = 0;\n      } else if (to === undefined) {\n        from |= 0;\n        scale(this, from);\n        data[from >>> WORD_LOG] &= ~(1 << from);\n      } else if (from <= to) {\n        scale(this, to);\n\n        for (var i = from; i <= to; i++) {\n          data[i >>> WORD_LOG] &= ~(1 << i);\n        }\n      }\n\n      return this;\n    },\n\n    /**\n     * Gets an entire range as a new bitset object\n     *\n     * Ex:\n     * bs1 = new BitSet();\n     * bs1.slice(4, 8);\n     *\n     * @param {number=} from The start index of the range to be get\n     * @param {number=} to The end index of the range to be get\n     * @returns {BitSet} A new smaller bitset object, containing the extracted range\n     */\n    'slice': function (from, to) {\n      if (from === undefined) {\n        return this['clone']();\n      } else if (to === undefined) {\n        to = this['data'].length * WORD_LENGTH;\n        var im = Object.create(BitSet.prototype);\n        im['_'] = this['_'];\n        im['data'] = [0];\n\n        for (var i = from; i <= to; i++) {\n          im['set'](i - from, this['get'](i));\n        }\n\n        return im;\n      } else if (from <= to && 0 <= from) {\n        var im = Object.create(BitSet.prototype);\n        im['data'] = [0];\n\n        for (var i = from; i <= to; i++) {\n          im['set'](i - from, this['get'](i));\n        }\n\n        return im;\n      }\n\n      return null;\n    },\n\n    /**\n     * Set a range of bits\n     *\n     * Ex:\n     * bs1 = new BitSet();\n     *\n     * bs1.setRange(10, 15, 1);\n     *\n     * @param {number} from The start index of the range to be set\n     * @param {number} to The end index of the range to be set\n     * @param {number} value Optional value that should be set on the index (0 or 1)\n     * @returns {BitSet} this\n     */\n    'setRange': function (from, to, value) {\n      for (var i = from; i <= to; i++) {\n        this['set'](i, value);\n      }\n\n      return this;\n    },\n\n    /**\n     * Clones the actual object\n     *\n     * Ex:\n     * bs1 = new BitSet(10);\n     * bs2 = bs1.clone();\n     *\n     * @returns {BitSet|Object} A new BitSet object, containing a copy of the actual object\n     */\n    'clone': function () {\n      var im = Object.create(BitSet.prototype);\n      im['data'] = this['data'].slice();\n      im['_'] = this['_'];\n      return im;\n    },\n\n    /**\n     * Gets a list of set bits\n     *\n     * @returns {Array}\n     */\n    'toArray': Math['clz32'] ? function () {\n      var ret = [];\n      var data = this['data'];\n\n      for (var i = data.length - 1; i >= 0; i--) {\n        var num = data[i];\n\n        while (num !== 0) {\n          var t = 31 - Math['clz32'](num);\n          num ^= 1 << t;\n          ret.unshift(i * WORD_LENGTH + t);\n        }\n      }\n\n      if (this['_'] !== 0) ret.push(Infinity);\n      return ret;\n    } : function () {\n      var ret = [];\n      var data = this['data'];\n\n      for (var i = 0; i < data.length; i++) {\n        var num = data[i];\n\n        while (num !== 0) {\n          var t = num & -num;\n          num ^= t;\n          ret.push(i * WORD_LENGTH + popCount(t - 1));\n        }\n      }\n\n      if (this['_'] !== 0) ret.push(Infinity);\n      return ret;\n    },\n\n    /**\n     * Overrides the toString method to get a binary representation of the BitSet\n     *\n     * @param {number=} base\n     * @returns string A binary string\n     */\n    'toString': function (base) {\n      var data = this['data'];\n      if (!base) base = 2; // If base is power of two\n\n      if ((base & base - 1) === 0 && base < 36) {\n        var ret = '';\n        var len = 2 + Math.log(4294967295\n        /*Math.pow(2, WORD_LENGTH)-1*/\n        ) / Math.log(base) | 0;\n\n        for (var i = data.length - 1; i >= 0; i--) {\n          var cur = data[i]; // Make the number unsigned\n\n          if (cur < 0) cur += 4294967296\n          /*Math.pow(2, WORD_LENGTH)*/\n          ;\n          var tmp = cur.toString(base);\n\n          if (ret !== '') {\n            // Fill small positive numbers with leading zeros. The +1 for array creation is added outside already\n            ret += '0'.repeat(len - tmp.length - 1);\n          }\n\n          ret += tmp;\n        }\n\n        if (this['_'] === 0) {\n          ret = ret.replace(/^0+/, '');\n          if (ret === '') ret = '0';\n          return ret;\n        } else {\n          // Pad the string with ones\n          ret = '1111' + ret;\n          return ret.replace(/^1+/, '...1111');\n        }\n      } else {\n        if (2 > base || base > 36) throw SyntaxError('Invalid base');\n        var ret = [];\n        var arr = []; // Copy every single bit to a new array\n\n        for (var i = data.length; i--;) {\n          for (var j = WORD_LENGTH; j--;) {\n            arr.push(data[i] >>> j & 1);\n          }\n        }\n\n        do {\n          ret.unshift(divide(arr, base).toString(base));\n        } while (!arr.every(function (x) {\n          return x === 0;\n        }));\n\n        return ret.join('');\n      }\n    },\n\n    /**\n     * Check if the BitSet is empty, means all bits are unset\n     *\n     * Ex:\n     * bs1 = new BitSet(10);\n     *\n     * bs1.isEmpty() ? 'yes' : 'no'\n     *\n     * @returns {boolean} Whether the bitset is empty\n     */\n    'isEmpty': function () {\n      if (this['_'] !== 0) return false;\n      var d = this['data'];\n\n      for (var i = d.length - 1; i >= 0; i--) {\n        if (d[i] !== 0) return false;\n      }\n\n      return true;\n    },\n\n    /**\n     * Calculates the number of bits set\n     *\n     * Ex:\n     * bs1 = new BitSet(10);\n     *\n     * var num = bs1.cardinality();\n     *\n     * @returns {number} The number of bits set\n     */\n    'cardinality': function () {\n      if (this['_'] !== 0) {\n        return Infinity;\n      }\n\n      var s = 0;\n      var d = this['data'];\n\n      for (var i = 0; i < d.length; i++) {\n        var n = d[i];\n        if (n !== 0) s += popCount(n);\n      }\n\n      return s;\n    },\n\n    /**\n     * Calculates the Most Significant Bit / log base two\n     *\n     * Ex:\n     * bs1 = new BitSet(10);\n     *\n     * var logbase2 = bs1.msb();\n     *\n     * var truncatedTwo = Math.pow(2, logbase2); // May overflow!\n     *\n     * @returns {number} The index of the highest bit set\n     */\n    'msb': Math['clz32'] ? function () {\n      if (this['_'] !== 0) {\n        return Infinity;\n      }\n\n      var data = this['data'];\n\n      for (var i = data.length; i-- > 0;) {\n        var c = Math['clz32'](data[i]);\n\n        if (c !== WORD_LENGTH) {\n          return i * WORD_LENGTH + WORD_LENGTH - 1 - c;\n        }\n      }\n\n      return Infinity;\n    } : function () {\n      if (this['_'] !== 0) {\n        return Infinity;\n      }\n\n      var data = this['data'];\n\n      for (var i = data.length; i-- > 0;) {\n        var v = data[i];\n        var c = 0;\n\n        if (v) {\n          for (; (v >>>= 1) > 0; c++) {}\n\n          return i * WORD_LENGTH + c;\n        }\n      }\n\n      return Infinity;\n    },\n\n    /**\n     * Calculates the number of trailing zeros\n     *\n     * Ex:\n     * bs1 = new BitSet(10);\n     *\n     * var ntz = bs1.ntz();\n     *\n     * @returns {number} The index of the lowest bit set\n     */\n    'ntz': function () {\n      var data = this['data'];\n\n      for (var j = 0; j < data.length; j++) {\n        var v = data[j];\n\n        if (v !== 0) {\n          v = (v ^ v - 1) >>> 1; // Set v's trailing 0s to 1s and zero rest\n\n          return j * WORD_LENGTH + popCount(v);\n        }\n      }\n\n      return Infinity;\n    },\n\n    /**\n     * Calculates the Least Significant Bit\n     *\n     * Ex:\n     * bs1 = new BitSet(10);\n     *\n     * var lsb = bs1.lsb();\n     *\n     * @returns {number} The index of the lowest bit set\n     */\n    'lsb': function () {\n      var data = this['data'];\n\n      for (var i = 0; i < data.length; i++) {\n        var v = data[i];\n        var c = 0;\n\n        if (v) {\n          var bit = v & -v;\n\n          for (; bit >>>= 1; c++) {}\n\n          return WORD_LENGTH * i + c;\n        }\n      }\n\n      return this['_'] & 1;\n    },\n\n    /**\n     * Compares two BitSet objects\n     *\n     * Ex:\n     * bs1 = new BitSet(10);\n     * bs2 = new BitSet(10);\n     *\n     * bs1.equals(bs2) ? 'yes' : 'no'\n     *\n     * @param {BitSet} val A bitset object\n     * @returns {boolean} Whether the two BitSets have the same bits set (valid for indefinite sets as well)\n     */\n    'equals': function (val) {\n      parse(P, val);\n      var t = this['data'];\n      var p = P['data'];\n      var t_ = this['_'];\n      var p_ = P['_'];\n      var tl = t.length - 1;\n      var pl = p.length - 1;\n\n      if (p_ !== t_) {\n        return false;\n      }\n\n      var minLength = tl < pl ? tl : pl;\n      var i = 0;\n\n      for (; i <= minLength; i++) {\n        if (t[i] !== p[i]) return false;\n      }\n\n      for (i = tl; i > pl; i--) {\n        if (t[i] !== p_) return false;\n      }\n\n      for (i = pl; i > tl; i--) {\n        if (p[i] !== t_) return false;\n      }\n\n      return true;\n    },\n    [Symbol.iterator]: function () {\n      var d = this['data'];\n      var ndx = 0;\n\n      if (this['_'] === 0) {\n        // Find highest index with something meaningful\n        var highest = 0;\n\n        for (var i = d.length - 1; i >= 0; i--) {\n          if (d[i] !== 0) {\n            highest = i;\n            break;\n          }\n        }\n\n        return {\n          'next': function () {\n            var n = ndx >>> WORD_LOG;\n            return {\n              'done': n > highest || n === highest && d[n] >>> ndx === 0,\n              'value': n > highest ? 0 : d[n] >>> ndx++ & 1\n            };\n          }\n        };\n      } else {\n        // Endless iterator!\n        return {\n          'next': function () {\n            var n = ndx >>> WORD_LOG;\n            return {\n              'done': false,\n              'value': n < d.length ? d[n] >>> ndx++ & 1 : 1\n            };\n          }\n        };\n      }\n    }\n  };\n\n  BitSet['fromBinaryString'] = function (str) {\n    return new BitSet('0b' + str);\n  };\n\n  BitSet['fromHexString'] = function (str) {\n    return new BitSet('0x' + str);\n  };\n\n  BitSet['Random'] = function (n) {\n    if (n === undefined || n < 0) {\n      n = WORD_LENGTH;\n    }\n\n    var m = n % WORD_LENGTH; // Create an array, large enough to hold the random bits\n\n    var t = [];\n    var len = Math.ceil(n / WORD_LENGTH); // Create an bitset instance\n\n    var s = Object.create(BitSet.prototype); // Fill the vector with random data, uniformally distributed\n\n    for (var i = 0; i < len; i++) {\n      t.push(Math.random() * 4294967296 | 0);\n    } // Mask out unwanted bits\n\n\n    if (m > 0) {\n      t[len - 1] &= (1 << m) - 1;\n    }\n\n    s['data'] = t;\n    s['_'] = 0;\n    return s;\n  };\n\n  if (typeof define === 'function' && define['amd']) {\n    define([], function () {\n      return BitSet;\n    });\n  } else if (typeof exports === 'object') {\n    Object.defineProperty(exports, \"__esModule\", {\n      'value': true\n    });\n    BitSet['default'] = BitSet;\n    BitSet['BitSet'] = BitSet;\n    module['exports'] = BitSet;\n  } else {\n    root['BitSet'] = BitSet;\n  }\n})(this);","map":{"version":3,"sources":["C:/Users/Andrew/Documents/JavaScript Projects/bool-simp/node_modules/bitset/bitset.js"],"names":["root","WORD_LENGTH","WORD_LOG","popCount","v","divide","arr","B","r","i","length","d","parse","P","val","BitSet","base","len","indexOf","substr","a","b","num","parseInt","slice","isNaN","SyntaxError","push","data","Array","ndx","Infinity","scale","Uint8Array","bits","n","j","k","param","dst","l","prototype","value","undefined","t","T","p","pl","p_","t_","tl","Math","min","minLength","from","to","im","Object","create","ret","unshift","log","cur","tmp","toString","repeat","replace","every","x","join","s","c","bit","Symbol","iterator","highest","str","m","ceil","random","define","exports","defineProperty","module"],"mappings":"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","sourcesContent":["/**\n * @license BitSet.js v5.1.1 2/1/2020\n * http://www.xarg.org/2014/03/javascript-bit-array/\n *\n * Copyright (c) 2020, Robert Eisele (robert@xarg.org)\n * Dual licensed under the MIT or GPL Version 2 licenses.\n **/\n(function(root) {\n\n  'use strict';\n\n  /**\n   * The number of bits of a word\n   * @const\n   * @type number\n   */\n  var WORD_LENGTH = 32;\n\n  /**\n   * The log base 2 of WORD_LENGTH\n   * @const\n   * @type number\n   */\n  var WORD_LOG = 5;\n\n  /**\n   * Calculates the number of set bits\n   *\n   * @param {number} v\n   * @returns {number}\n   */\n  function popCount(v) {\n\n    // Warren, H. (2009). Hacker`s Delight. New York, NY: Addison-Wesley\n\n    v -= ((v >>> 1) & 0x55555555);\n    v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);\n    return (((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24);\n  }\n\n  /**\n   * Divide a number in base two by B\n   *\n   * @param {Array} arr\n   * @param {number} B\n   * @returns {number}\n   */\n  function divide(arr, B) {\n\n    var r = 0;\n\n    for (var i = 0; i < arr.length; i++) {\n      r *= 2;\n      var d = (arr[i] + r) / B | 0;\n      r = (arr[i] + r) % B;\n      arr[i] = d;\n    }\n    return r;\n  }\n\n  /**\n   * Parses the parameters and set variable P\n   *\n   * @param {Object} P\n   * @param {string|BitSet|Array|Uint8Array|number=} val\n   */\n  function parse(P, val) {\n\n    if (val == null) {\n      P['data'] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n      P['_'] = 0;\n      return;\n    }\n\n    if (val instanceof BitSet) {\n      P['data'] = val['data'];\n      P['_'] = val['_'];\n      return;\n    }\n\n    switch (typeof val) {\n\n      case 'number':\n        P['data'] = [val | 0];\n        P['_'] = 0;\n        break;\n\n      case 'string':\n\n        var base = 2;\n        var len = WORD_LENGTH;\n\n        if (val.indexOf('0b') === 0) {\n          val = val.substr(2);\n        } else if (val.indexOf('0x') === 0) {\n          val = val.substr(2);\n          base = 16;\n          len = 8;\n        }\n\n        P['data'] = [];\n        P['_'] = 0;\n\n        var a = val.length - len;\n        var b = val.length;\n\n        do {\n\n          var num = parseInt(val.slice(a > 0 ? a : 0, b), base);\n\n          if (isNaN(num)) {\n            throw SyntaxError('Invalid param');\n          }\n\n          P['data'].push(num | 0);\n\n          if (a <= 0)\n            break;\n\n          a -= len;\n          b -= len;\n        } while (1);\n\n        break;\n\n      default:\n\n        P['data'] = [0];\n        var data = P['data'];\n\n        if (val instanceof Array) {\n\n          for (var i = val.length - 1; i >= 0; i--) {\n\n            var ndx = val[i];\n\n            if (ndx === Infinity) {\n              P['_'] = -1;\n            } else {\n              scale(P, ndx);\n              data[ndx >>> WORD_LOG] |= 1 << ndx;\n            }\n          }\n          break;\n        }\n\n        if (Uint8Array && val instanceof Uint8Array) {\n\n          var bits = 8;\n\n          scale(P, val.length * bits);\n\n          for (var i = 0; i < val.length; i++) {\n\n            var n = val[i];\n\n            for (var j = 0; j < bits; j++) {\n\n              var k = i * bits + j;\n\n              data[k >>> WORD_LOG] |= (n >> j & 1) << k;\n            }\n          }\n          break;\n        }\n        throw SyntaxError('Invalid param');\n    }\n  }\n\n  /**\n   * Module entry point\n   *\n   * @constructor\n   * @param {string|BitSet|number=} param\n   * @returns {BitSet}\n   */\n  function BitSet(param) {\n\n    if (!(this instanceof BitSet)) {\n      return new BitSet(param);\n    }\n    parse(this, param);\n    this['data'] = this['data'].slice();\n  }\n\n  function scale(dst, ndx) {\n\n    var l = ndx >>> WORD_LOG;\n    var d = dst['data'];\n    var v = dst['_'];\n\n    for (var i = d.length; l >= i; l--) {\n      d.push(v);\n    }\n  }\n\n  var P = {\n    'data': [], // Holds the actual bits in form of a 32bit integer array.\n    '_': 0 // Holds the MSB flag information to make indefinitely large bitsets inversion-proof\n  };\n\n  BitSet.prototype = {\n    'data': [],\n    '_': 0,\n    /**\n     * Set a single bit flag\n     *\n     * Ex:\n     * bs1 = new BitSet(10);\n     *\n     * bs1.set(3, 1);\n     *\n     * @param {number} ndx The index of the bit to be set\n     * @param {number=} value Optional value that should be set on the index (0 or 1)\n     * @returns {BitSet} this\n     */\n    'set': function(ndx, value) {\n\n      ndx |= 0;\n\n      scale(this, ndx);\n\n      if (value === undefined || value) {\n        this['data'][ndx >>> WORD_LOG] |= (1 << ndx);\n      } else {\n        this['data'][ndx >>> WORD_LOG] &= ~(1 << ndx);\n      }\n      return this;\n    },\n    /**\n     * Get a single bit flag of a certain bit position\n     *\n     * Ex:\n     * bs1 = new BitSet();\n     * var isValid = bs1.get(12);\n     *\n     * @param {number} ndx the index to be fetched\n     * @returns {number} The binary flag\n     */\n    'get': function(ndx) {\n\n      ndx |= 0;\n\n      var d = this['data'];\n      var n = ndx >>> WORD_LOG;\n\n      if (n >= d.length) {\n        return this['_'] & 1;\n      }\n      return (d[n] >>> ndx) & 1;\n    },\n    /**\n     * Creates the bitwise NOT of a set.\n     *\n     * Ex:\n     * bs1 = new BitSet(10);\n     *\n     * res = bs1.not();\n     *\n     * @returns {BitSet} A new BitSet object, containing the bitwise NOT of this\n     */\n    'not': function() { // invert()\n\n      var t = this['clone']();\n      var d = t['data'];\n      for (var i = 0; i < d.length; i++) {\n        d[i] = ~d[i];\n      }\n\n      t['_'] = ~t['_'];\n\n      return t;\n    },\n    /**\n     * Creates the bitwise AND of two sets.\n     *\n     * Ex:\n     * bs1 = new BitSet(10);\n     * bs2 = new BitSet(10);\n     *\n     * res = bs1.and(bs2);\n     *\n     * @param {BitSet} value A bitset object\n     * @returns {BitSet} A new BitSet object, containing the bitwise AND of this and value\n     */\n    'and': function(value) {// intersection\n\n      parse(P, value);\n\n      var T = this['clone']();\n      var t = T['data'];\n      var p = P['data'];\n\n      var pl = p.length;\n      var p_ = P['_'];\n      var t_ = T['_'];\n\n      // If this is infinite, we need all bits from P\n      if (t_ !== 0) {\n        scale(T, pl * WORD_LENGTH - 1);\n      }\n\n      var tl = t.length;\n      var l = Math.min(pl, tl);\n      var i = 0;\n\n      for (; i < l; i++) {\n        t[i] &= p[i];\n      }\n\n      for (; i < tl; i++) {\n        t[i] &= p_;\n      }\n\n      T['_'] &= p_;\n\n      return T;\n    },\n    /**\n     * Creates the bitwise OR of two sets.\n     *\n     * Ex:\n     * bs1 = new BitSet(10);\n     * bs2 = new BitSet(10);\n     *\n     * res = bs1.or(bs2);\n     *\n     * @param {BitSet} val A bitset object\n     * @returns {BitSet} A new BitSet object, containing the bitwise OR of this and val\n     */\n    'or': function(val) { // union\n\n      parse(P, val);\n\n      var t = this['clone']();\n      var d = t['data'];\n      var p = P['data'];\n\n      var pl = p.length - 1;\n      var tl = d.length - 1;\n\n      var minLength = Math.min(tl, pl);\n\n      // Append backwards, extend array only once\n      for (var i = pl; i > minLength; i--) {\n        d[i] = p[i];\n      }\n\n      for (; i >= 0; i--) {\n        d[i] |= p[i];\n      }\n\n      t['_'] |= P['_'];\n\n      return t;\n    },\n    /**\n     * Creates the bitwise XOR of two sets.\n     *\n     * Ex:\n     * bs1 = new BitSet(10);\n     * bs2 = new BitSet(10);\n     *\n     * res = bs1.xor(bs2);\n     *\n     * @param {BitSet} val A bitset object\n     * @returns {BitSet} A new BitSet object, containing the bitwise XOR of this and val\n     */\n    'xor': function(val) { // symmetric difference\n\n      parse(P, val);\n\n      var t = this['clone']();\n      var d = t['data'];\n      var p = P['data'];\n\n      var t_ = t['_'];\n      var p_ = P['_'];\n\n      var i = 0;\n\n      var tl = d.length - 1;\n      var pl = p.length - 1;\n\n      // Cut if tl > pl\n      for (i = tl; i > pl; i--) {\n        d[i] ^= p_;\n      }\n\n      // Cut if pl > tl\n      for (i = pl; i > tl; i--) {\n        d[i] = t_ ^ p[i];\n      }\n\n      // XOR the rest\n      for (; i >= 0; i--) {\n        d[i] ^= p[i];\n      }\n\n      // XOR infinity\n      t['_'] ^= p_;\n\n      return t;\n    },\n    /**\n     * Creates the bitwise AND NOT (not confuse with NAND!) of two sets.\n     *\n     * Ex:\n     * bs1 = new BitSet(10);\n     * bs2 = new BitSet(10);\n     *\n     * res = bs1.notAnd(bs2);\n     *\n     * @param {BitSet} val A bitset object\n     * @returns {BitSet} A new BitSet object, containing the bitwise AND NOT of this and other\n     */\n    'andNot': function(val) { // difference\n\n      return this['and'](new BitSet(val)['flip']());\n    },\n    /**\n     * Flip/Invert a range of bits by setting\n     *\n     * Ex:\n     * bs1 = new BitSet();\n     * bs1.flip(); // Flip entire set\n     * bs1.flip(5); // Flip single bit\n     * bs1.flip(3,10); // Flip a bit range\n     *\n     * @param {number=} from The start index of the range to be flipped\n     * @param {number=} to The end index of the range to be flipped\n     * @returns {BitSet} this\n     */\n    'flip': function(from, to) {\n\n      if (from === undefined) {\n\n        var d = this['data'];\n        for (var i = 0; i < d.length; i++) {\n          d[i] = ~d[i];\n        }\n\n        this['_'] = ~this['_'];\n\n      } else if (to === undefined) {\n\n        scale(this, from);\n\n        this['data'][from >>> WORD_LOG] ^= (1 << from);\n\n      } else if (0 <= from && from <= to) {\n\n        scale(this, to);\n\n        for (var i = from; i <= to; i++) {\n          this['data'][i >>> WORD_LOG] ^= (1 << i);\n        }\n      }\n      return this;\n    },\n    /**\n     * Clear a range of bits by setting it to 0\n     *\n     * Ex:\n     * bs1 = new BitSet();\n     * bs1.clear(); // Clear entire set\n     * bs1.clear(5); // Clear single bit\n     * bs1.clear(3,10); // Clear a bit range\n     *\n     * @param {number=} from The start index of the range to be cleared\n     * @param {number=} to The end index of the range to be cleared\n     * @returns {BitSet} this\n     */\n    'clear': function(from, to) {\n\n      var data = this['data'];\n\n      if (from === undefined) {\n\n        for (var i = data.length - 1; i >= 0; i--) {\n          data[i] = 0;\n        }\n        this['_'] = 0;\n\n      } else if (to === undefined) {\n\n        from |= 0;\n\n        scale(this, from);\n\n        data[from >>> WORD_LOG] &= ~(1 << from);\n\n      } else if (from <= to) {\n\n        scale(this, to);\n\n        for (var i = from; i <= to; i++) {\n          data[i >>> WORD_LOG] &= ~(1 << i);\n        }\n      }\n      return this;\n    },\n    /**\n     * Gets an entire range as a new bitset object\n     *\n     * Ex:\n     * bs1 = new BitSet();\n     * bs1.slice(4, 8);\n     *\n     * @param {number=} from The start index of the range to be get\n     * @param {number=} to The end index of the range to be get\n     * @returns {BitSet} A new smaller bitset object, containing the extracted range\n     */\n    'slice': function(from, to) {\n\n      if (from === undefined) {\n        return this['clone']();\n      } else if (to === undefined) {\n\n        to = this['data'].length * WORD_LENGTH;\n\n        var im = Object.create(BitSet.prototype);\n\n        im['_'] = this['_'];\n        im['data'] = [0];\n\n        for (var i = from; i <= to; i++) {\n          im['set'](i - from, this['get'](i));\n        }\n        return im;\n\n      } else if (from <= to && 0 <= from) {\n\n        var im = Object.create(BitSet.prototype);\n        im['data'] = [0];\n\n        for (var i = from; i <= to; i++) {\n          im['set'](i - from, this['get'](i));\n        }\n        return im;\n      }\n      return null;\n    },\n    /**\n     * Set a range of bits\n     *\n     * Ex:\n     * bs1 = new BitSet();\n     *\n     * bs1.setRange(10, 15, 1);\n     *\n     * @param {number} from The start index of the range to be set\n     * @param {number} to The end index of the range to be set\n     * @param {number} value Optional value that should be set on the index (0 or 1)\n     * @returns {BitSet} this\n     */\n    'setRange': function(from, to, value) {\n\n      for (var i = from; i <= to; i++) {\n        this['set'](i, value);\n      }\n      return this;\n    },\n    /**\n     * Clones the actual object\n     *\n     * Ex:\n     * bs1 = new BitSet(10);\n     * bs2 = bs1.clone();\n     *\n     * @returns {BitSet|Object} A new BitSet object, containing a copy of the actual object\n     */\n    'clone': function() {\n\n      var im = Object.create(BitSet.prototype);\n      im['data'] = this['data'].slice();\n      im['_'] = this['_'];\n\n      return im;\n    },\n    /**\n     * Gets a list of set bits\n     *\n     * @returns {Array}\n     */\n    'toArray': Math['clz32'] ?\n    function() {\n\n      var ret = [];\n      var data = this['data'];\n\n      for (var i = data.length - 1; i >= 0; i--) {\n\n        var num = data[i];\n\n        while (num !== 0) {\n          var t = 31 - Math['clz32'](num);\n          num ^= 1 << t;\n          ret.unshift((i * WORD_LENGTH) + t);\n        }\n      }\n\n      if (this['_'] !== 0)\n        ret.push(Infinity);\n\n      return ret;\n    } :\n    function() {\n\n      var ret = [];\n      var data = this['data'];\n\n      for (var i = 0; i < data.length; i++) {\n\n        var num = data[i];\n\n        while (num !== 0) {\n          var t = num & -num;\n          num ^= t;\n          ret.push((i * WORD_LENGTH) + popCount(t - 1));\n        }\n      }\n\n      if (this['_'] !== 0)\n        ret.push(Infinity);\n\n      return ret;\n    },\n    /**\n     * Overrides the toString method to get a binary representation of the BitSet\n     *\n     * @param {number=} base\n     * @returns string A binary string\n     */\n    'toString': function(base) {\n\n      var data = this['data'];\n\n      if (!base)\n        base = 2;\n\n      // If base is power of two\n      if ((base & (base - 1)) === 0 && base < 36) {\n\n        var ret = '';\n        var len = 2 + Math.log(4294967295/*Math.pow(2, WORD_LENGTH)-1*/) / Math.log(base) | 0;\n\n        for (var i = data.length - 1; i >= 0; i--) {\n\n          var cur = data[i];\n\n          // Make the number unsigned\n          if (cur < 0)\n            cur += 4294967296 /*Math.pow(2, WORD_LENGTH)*/;\n\n          var tmp = cur.toString(base);\n\n          if (ret !== '') {\n            // Fill small positive numbers with leading zeros. The +1 for array creation is added outside already\n            ret += '0'.repeat(len - tmp.length - 1);\n          }\n          ret += tmp;\n        }\n\n        if (this['_'] === 0) {\n\n          ret = ret.replace(/^0+/, '');\n\n          if (ret === '')\n            ret = '0';\n          return ret;\n\n        } else {\n          // Pad the string with ones\n          ret = '1111' + ret;\n          return ret.replace(/^1+/, '...1111');\n        }\n\n      } else {\n\n        if ((2 > base || base > 36))\n          throw SyntaxError('Invalid base');\n\n        var ret = [];\n        var arr = [];\n\n        // Copy every single bit to a new array\n        for (var i = data.length; i--; ) {\n\n          for (var j = WORD_LENGTH; j--; ) {\n\n            arr.push(data[i] >>> j & 1);\n          }\n        }\n\n        do {\n          ret.unshift(divide(arr, base).toString(base));\n        } while (!arr.every(function(x) {\n          return x === 0;\n        }));\n\n        return ret.join('');\n      }\n    },\n    /**\n     * Check if the BitSet is empty, means all bits are unset\n     *\n     * Ex:\n     * bs1 = new BitSet(10);\n     *\n     * bs1.isEmpty() ? 'yes' : 'no'\n     *\n     * @returns {boolean} Whether the bitset is empty\n     */\n    'isEmpty': function() {\n\n      if (this['_'] !== 0)\n        return false;\n\n      var d = this['data'];\n\n      for (var i = d.length - 1; i >= 0; i--) {\n        if (d[i] !== 0)\n          return false;\n      }\n      return true;\n    },\n    /**\n     * Calculates the number of bits set\n     *\n     * Ex:\n     * bs1 = new BitSet(10);\n     *\n     * var num = bs1.cardinality();\n     *\n     * @returns {number} The number of bits set\n     */\n    'cardinality': function() {\n\n      if (this['_'] !== 0) {\n        return Infinity;\n      }\n\n      var s = 0;\n      var d = this['data'];\n      for (var i = 0; i < d.length; i++) {\n        var n = d[i];\n        if (n !== 0)\n          s += popCount(n);\n      }\n      return s;\n    },\n    /**\n     * Calculates the Most Significant Bit / log base two\n     *\n     * Ex:\n     * bs1 = new BitSet(10);\n     *\n     * var logbase2 = bs1.msb();\n     *\n     * var truncatedTwo = Math.pow(2, logbase2); // May overflow!\n     *\n     * @returns {number} The index of the highest bit set\n     */\n    'msb': Math['clz32'] ?\n    function() {\n\n      if (this['_'] !== 0) {\n        return Infinity;\n      }\n\n      var data = this['data'];\n\n      for (var i = data.length; i-- > 0;) {\n\n        var c = Math['clz32'](data[i]);\n\n        if (c !== WORD_LENGTH) {\n          return (i * WORD_LENGTH) + WORD_LENGTH - 1 - c;\n        }\n      }\n      return Infinity;\n    } :\n    function() {\n\n      if (this['_'] !== 0) {\n        return Infinity;\n      }\n\n      var data = this['data'];\n\n      for (var i = data.length; i-- > 0;) {\n\n        var v = data[i];\n        var c = 0;\n\n        if (v) {\n\n          for (; (v >>>= 1) > 0; c++) {\n          }\n          return (i * WORD_LENGTH) + c;\n        }\n      }\n      return Infinity;\n    },\n    /**\n     * Calculates the number of trailing zeros\n     *\n     * Ex:\n     * bs1 = new BitSet(10);\n     *\n     * var ntz = bs1.ntz();\n     *\n     * @returns {number} The index of the lowest bit set\n     */\n    'ntz': function() {\n\n      var data = this['data'];\n\n      for (var j = 0; j < data.length; j++) {\n        var v = data[j];\n\n        if (v !== 0) {\n\n          v = (v ^ (v - 1)) >>> 1; // Set v's trailing 0s to 1s and zero rest\n\n          return (j * WORD_LENGTH) + popCount(v);\n        }\n      }\n      return Infinity;\n    },\n    /**\n     * Calculates the Least Significant Bit\n     *\n     * Ex:\n     * bs1 = new BitSet(10);\n     *\n     * var lsb = bs1.lsb();\n     *\n     * @returns {number} The index of the lowest bit set\n     */\n    'lsb': function() {\n\n      var data = this['data'];\n\n      for (var i = 0; i < data.length; i++) {\n\n        var v = data[i];\n        var c = 0;\n\n        if (v) {\n\n          var bit = (v & -v);\n\n          for (; (bit >>>= 1); c++) {\n\n          }\n          return WORD_LENGTH * i + c;\n        }\n      }\n      return this['_'] & 1;\n    },\n    /**\n     * Compares two BitSet objects\n     *\n     * Ex:\n     * bs1 = new BitSet(10);\n     * bs2 = new BitSet(10);\n     *\n     * bs1.equals(bs2) ? 'yes' : 'no'\n     *\n     * @param {BitSet} val A bitset object\n     * @returns {boolean} Whether the two BitSets have the same bits set (valid for indefinite sets as well)\n     */\n    'equals': function(val) {\n\n      parse(P, val);\n\n      var t = this['data'];\n      var p = P['data'];\n\n      var t_ = this['_'];\n      var p_ = P['_'];\n\n      var tl = t.length - 1;\n      var pl = p.length - 1;\n\n      if (p_ !== t_) {\n        return false;\n      }\n\n      var minLength = tl < pl ? tl : pl;\n      var i = 0;\n\n      for (; i <= minLength; i++) {\n        if (t[i] !== p[i])\n          return false;\n      }\n\n      for (i = tl; i > pl; i--) {\n        if (t[i] !== p_)\n          return false;\n      }\n\n      for (i = pl; i > tl; i--) {\n        if (p[i] !== t_)\n          return false;\n      }\n      return true;\n    },\n    [Symbol.iterator]: function () {\n\n      var d = this['data'];\n      var ndx = 0;\n\n      if (this['_'] === 0) {\n\n        // Find highest index with something meaningful\n        var highest = 0;\n        for (var i = d.length - 1; i >= 0; i--) {\n          if (d[i] !== 0) {\n            highest = i;\n            break;\n          }\n        }\n\n        return {\n          'next': function () {\n            var n = ndx >>> WORD_LOG;\n\n            return {\n              'done': n > highest || n === highest && (d[n] >>> ndx) === 0,\n              'value': n > highest ? 0 : (d[n] >>> ndx++) & 1\n            };\n          }\n        };\n\n      } else {\n        // Endless iterator!\n        return {\n          'next': function () {\n            var n = ndx >>> WORD_LOG;\n\n            return {\n              'done': false,\n              'value': n < d.length ? (d[n] >>> ndx++) & 1 : 1,\n            };\n          }\n        };\n      }\n    }\n  };\n\n  BitSet['fromBinaryString'] = function(str) {\n\n    return new BitSet('0b' + str);\n  };\n\n  BitSet['fromHexString'] = function(str) {\n\n    return new BitSet('0x' + str);\n  };\n\n  BitSet['Random'] = function(n) {\n\n    if (n === undefined || n < 0) {\n      n = WORD_LENGTH;\n    }\n\n    var m = n % WORD_LENGTH;\n\n    // Create an array, large enough to hold the random bits\n    var t = [];\n    var len = Math.ceil(n / WORD_LENGTH);\n\n    // Create an bitset instance\n    var s = Object.create(BitSet.prototype);\n\n    // Fill the vector with random data, uniformally distributed\n    for (var i = 0; i < len; i++) {\n      t.push(Math.random() * 4294967296 | 0);\n    }\n\n    // Mask out unwanted bits\n    if (m > 0) {\n      t[len - 1] &= (1 << m) - 1;\n    }\n\n    s['data'] = t;\n    s['_'] = 0;\n    return s;\n  };\n\n  if (typeof define === 'function' && define['amd']) {\n    define([], function() {\n      return BitSet;\n    });\n  } else if (typeof exports === 'object') {\n    Object.defineProperty(exports, \"__esModule\", { 'value': true });\n    BitSet['default'] = BitSet;\n    BitSet['BitSet'] = BitSet;\n    module['exports'] = BitSet;\n  } else {\n    root['BitSet'] = BitSet;\n  }\n\n})(this);\n"]},"metadata":{},"sourceType":"script"}