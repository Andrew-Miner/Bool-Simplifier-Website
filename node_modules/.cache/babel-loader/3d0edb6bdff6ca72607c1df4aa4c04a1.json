{"ast":null,"code":"import _classPrivateFieldLooseBase from \"C:/Users/Andrew/Documents/JavaScript Projects/bool-simp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"C:/Users/Andrew/Documents/JavaScript Projects/bool-simp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\nimport { buildBoolGrammar, deepCopy, validateTerms, getVarBitSet, calculateMinTerms } from \"./BoolExpressionUtils\";\nimport QMFuncs from \"./QMFunctions\";\nimport PMFuncs from \"./PMFunctions\";\nimport Recognizer from \"../Earley Parser/EarleyRecognizer\";\nimport Parser from \"../Earley Parser/EarleyParser\";\nimport BitSet from \"bitset\";\n\nvar _varCount = /*#__PURE__*/_classPrivateFieldLooseKey(\"varCount\");\n\nvar _minTerms = /*#__PURE__*/_classPrivateFieldLooseKey(\"minTerms\");\n\nvar _dontCares = /*#__PURE__*/_classPrivateFieldLooseKey(\"dontCares\");\n\nvar _primeImps = /*#__PURE__*/_classPrivateFieldLooseKey(\"primeImps\");\n\nvar _petrickSOP = /*#__PURE__*/_classPrivateFieldLooseKey(\"petrickSOP\");\n\nvar _sSet = /*#__PURE__*/_classPrivateFieldLooseKey(\"sSet\");\n\nvar _invertedS = /*#__PURE__*/_classPrivateFieldLooseKey(\"invertedS\");\n\nvar _parseTree = /*#__PURE__*/_classPrivateFieldLooseKey(\"parseTree\");\n\nvar _varBitSet = /*#__PURE__*/_classPrivateFieldLooseKey(\"varBitSet\");\n\nvar _expression = /*#__PURE__*/_classPrivateFieldLooseKey(\"expression\");\n\nvar _errorCode = /*#__PURE__*/_classPrivateFieldLooseKey(\"errorCode\");\n\nvar _isLogged = /*#__PURE__*/_classPrivateFieldLooseKey(\"isLogged\");\n\nvar _qmLog = /*#__PURE__*/_classPrivateFieldLooseKey(\"qmLog\");\n\nvar _pmLog = /*#__PURE__*/_classPrivateFieldLooseKey(\"pmLog\");\n\nvar _truthTable = /*#__PURE__*/_classPrivateFieldLooseKey(\"truthTable\");\n\nvar _BOOL_GRAMMAR = /*#__PURE__*/_classPrivateFieldLooseKey(\"BOOL_GRAMMAR\");\n\nvar _reduce = /*#__PURE__*/_classPrivateFieldLooseKey(\"reduce\");\n\nvar _buildTruthTable = /*#__PURE__*/_classPrivateFieldLooseKey(\"buildTruthTable\");\n\nexport default class BoolExpression {\n  constructor(_expression2, _minTerms2, _dontCares2, isLogged = false) {\n    Object.defineProperty(this, _varCount, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _minTerms, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _dontCares, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _primeImps, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _petrickSOP, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _sSet, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _invertedS, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _parseTree, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _varBitSet, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _expression, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _errorCode, {\n      writable: true,\n      value: -2\n    });\n    Object.defineProperty(this, _isLogged, {\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, _qmLog, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _pmLog, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _truthTable, {\n      writable: true,\n      value: void 0\n    });\n\n    this.getMinTerms = () => deepCopy(_classPrivateFieldLooseBase(this, _minTerms)[_minTerms]);\n\n    this.getDontCares = () => deepCopy(_classPrivateFieldLooseBase(this, _dontCares)[_dontCares]);\n\n    this.getPetrickSOP = () => deepCopy(_classPrivateFieldLooseBase(this, _petrickSOP)[_petrickSOP]);\n\n    this.getEssentialImplicants = () => deepCopy(_classPrivateFieldLooseBase(this, _primeImps)[_primeImps]);\n\n    this.getVarCount = () => _classPrivateFieldLooseBase(this, _varCount)[_varCount];\n\n    this.getQMLog = () => _classPrivateFieldLooseBase(this, _isLogged)[_isLogged] ? deepCopy(_classPrivateFieldLooseBase(this, _qmLog)[_qmLog]) : [];\n\n    this.getPMLog = () => _classPrivateFieldLooseBase(this, _isLogged)[_isLogged] ? deepCopy(_classPrivateFieldLooseBase(this, _pmLog)[_pmLog]) : [];\n\n    this.getTruthTable = () => deepCopy(_classPrivateFieldLooseBase(this, _truthTable)[_truthTable]);\n\n    this.getPrimeImpStrings = () => {\n      let piStrs = [];\n\n      for (const implicant of _classPrivateFieldLooseBase(this, _primeImps)[_primeImps]) {\n        let str = \"[\";\n        let minTerms = QMFuncs.extractMinTerms(implicant);\n\n        for (const term of minTerms) str += parseInt(term) + \"-\";\n\n        str = str.substring(0, str.length - 1) + \"] \";\n        str += QMFuncs.toString(implicant, _classPrivateFieldLooseBase(this, _varCount)[_varCount]);\n        piStrs.push(str);\n      }\n\n      return piStrs;\n    };\n\n    this.getSOPStrings = () => {\n      let sopStrs = [];\n      if (_classPrivateFieldLooseBase(this, _petrickSOP)[_petrickSOP].length === 0) sopStrs.push(PMFuncs.mapProductToString([], _classPrivateFieldLooseBase(this, _varBitSet)[_varBitSet]));else {\n        for (const product of _classPrivateFieldLooseBase(this, _petrickSOP)[_petrickSOP]) {\n          if (_classPrivateFieldLooseBase(this, _varBitSet)[_varBitSet]) sopStrs.push(PMFuncs.mapProductToString(product, _classPrivateFieldLooseBase(this, _varBitSet)[_varBitSet]));else sopStrs.push(PMFuncs.productToString(product, _classPrivateFieldLooseBase(this, _varCount)[_varCount]));\n        }\n      }\n      return sopStrs;\n    };\n\n    this.setExpression = expression => {\n      expression = expression.replace(/ /g, \"\");\n      let sSet = Recognizer.buildItems(expression, _classPrivateFieldLooseBase(BoolExpression, _BOOL_GRAMMAR)[_BOOL_GRAMMAR]);\n      let invertedS = Parser.invertEarleySets(sSet, _classPrivateFieldLooseBase(BoolExpression, _BOOL_GRAMMAR)[_BOOL_GRAMMAR]);\n      let parseTree = Parser.buildParseTree(expression, invertedS, _classPrivateFieldLooseBase(BoolExpression, _BOOL_GRAMMAR)[_BOOL_GRAMMAR]);\n\n      if (parseTree !== null) {\n        _classPrivateFieldLooseBase(this, _sSet)[_sSet] = sSet;\n        _classPrivateFieldLooseBase(this, _invertedS)[_invertedS] = invertedS;\n        _classPrivateFieldLooseBase(this, _parseTree)[_parseTree] = parseTree;\n        _classPrivateFieldLooseBase(this, _varBitSet)[_varBitSet] = getVarBitSet(expression);\n        _classPrivateFieldLooseBase(this, _varCount)[_varCount] = _classPrivateFieldLooseBase(this, _varBitSet)[_varBitSet].cardinality();\n        _classPrivateFieldLooseBase(this, _minTerms)[_minTerms] = calculateMinTerms(parseTree, _classPrivateFieldLooseBase(this, _varBitSet)[_varBitSet]);\n      } else {\n        let [parsed, minTerms, dontCares] = QMFuncs.parseString(expression);\n\n        if (!parsed) {\n          _classPrivateFieldLooseBase(this, _errorCode)[_errorCode] = -2;\n          return false;\n        }\n\n        let [validated, errorCode] = validateTerms(minTerms, dontCares);\n\n        if (!validated) {\n          _classPrivateFieldLooseBase(this, _errorCode)[_errorCode] = errorCode;\n          return false;\n        }\n\n        _classPrivateFieldLooseBase(this, _varCount)[_varCount] = QMFuncs.getVariableCount(minTerms, dontCares);\n        _classPrivateFieldLooseBase(this, _minTerms)[_minTerms] = minTerms;\n        _classPrivateFieldLooseBase(this, _dontCares)[_dontCares] = dontCares;\n      }\n\n      if (_classPrivateFieldLooseBase(this, _isLogged)[_isLogged]) {\n        _classPrivateFieldLooseBase(this, _qmLog)[_qmLog] = [];\n        _classPrivateFieldLooseBase(this, _pmLog)[_pmLog] = [];\n      }\n\n      _classPrivateFieldLooseBase(this, _reduce)[_reduce]();\n\n      _classPrivateFieldLooseBase(this, _buildTruthTable)[_buildTruthTable]();\n\n      return true;\n    };\n\n    this.setMinTerms = (minTerms, dontCares) => {\n      let [success, errorCode] = validateTerms(minTerms, dontCares);\n\n      if (!success) {\n        _classPrivateFieldLooseBase(this, _errorCode)[_errorCode] = errorCode;\n        return false;\n      }\n\n      _classPrivateFieldLooseBase(this, _minTerms)[_minTerms] = minTerms;\n      _classPrivateFieldLooseBase(this, _dontCares)[_dontCares] = dontCares;\n      _classPrivateFieldLooseBase(this, _varCount)[_varCount] = QMFuncs.getVariableCount(minTerms, dontCares);\n      _classPrivateFieldLooseBase(this, _sSet)[_sSet] = null;\n      this.expression = null;\n      _classPrivateFieldLooseBase(this, _invertedS)[_invertedS] = null;\n      _classPrivateFieldLooseBase(this, _parseTree)[_parseTree] = null;\n      _classPrivateFieldLooseBase(this, _varBitSet)[_varBitSet] = null;\n\n      if (_classPrivateFieldLooseBase(this, _isLogged)[_isLogged]) {\n        _classPrivateFieldLooseBase(this, _qmLog)[_qmLog] = [];\n        _classPrivateFieldLooseBase(this, _pmLog)[_pmLog] = [];\n      }\n\n      _classPrivateFieldLooseBase(this, _reduce)[_reduce]();\n\n      _classPrivateFieldLooseBase(this, _buildTruthTable)[_buildTruthTable]();\n\n      return true;\n    };\n\n    Object.defineProperty(this, _reduce, {\n      writable: true,\n      value: () => {\n        let nonEssentialPrimeImps = QMFuncs.getPrimeImplicants(_classPrivateFieldLooseBase(this, _minTerms)[_minTerms], _classPrivateFieldLooseBase(this, _dontCares)[_dontCares], _classPrivateFieldLooseBase(this, _qmLog)[_qmLog]);\n        _classPrivateFieldLooseBase(this, _petrickSOP)[_petrickSOP] = PMFuncs.getPetrickSOP(nonEssentialPrimeImps, _classPrivateFieldLooseBase(this, _minTerms)[_minTerms], _classPrivateFieldLooseBase(this, _pmLog)[_pmLog]);\n        _classPrivateFieldLooseBase(this, _primeImps)[_primeImps] = QMFuncs.getEssentialTerms(nonEssentialPrimeImps, _classPrivateFieldLooseBase(this, _minTerms)[_minTerms]);\n      }\n    });\n    Object.defineProperty(this, _buildTruthTable, {\n      writable: true,\n      value: () => {\n        _classPrivateFieldLooseBase(this, _truthTable)[_truthTable] = [];\n        let varRow = [\"#\"];\n        if (varBitSet()) for (let i = 0; i < 26; i++) {\n          if (_classPrivateFieldLooseBase(this, _varBitSet)[_varBitSet].get(i) === 0) continue;\n          varRow.push(String.fromCharCode(i + 65));\n        }\n        varRow.push(\"Output\");\n\n        _classPrivateFieldLooseBase(this, _truthTable)[_truthTable].push(varRow);\n\n        let rowCount = 2 ** _classPrivateFieldLooseBase(this, _varCount)[_varCount];\n\n        for (let i = 0; i < rowCount; i++) {\n          let row = [i];\n          let bits = new BitSet(i);\n\n          for (let j = 0; j < _classPrivateFieldLooseBase(this, _varCount)[_varCount]; j++) {\n            row.push(parseInt(bits.get(_classPrivateFieldLooseBase(this, _varCount)[_varCount] - 1 - j)));\n          }\n\n          row.push(this.isMinTerm(i) ? \"1\" : \"0\");\n\n          _classPrivateFieldLooseBase(this, _truthTable)[_truthTable].push(row);\n        }\n      }\n    });\n\n    this.toString = () => {\n      if (_classPrivateFieldLooseBase(this, _expression)[_expression]) return _classPrivateFieldLooseBase(this, _expression)[_expression];\n      let str = \"m(\";\n\n      for (const term of _classPrivateFieldLooseBase(this, _minTerms)[_minTerms]) str += parseInt(term) + \" \";\n\n      str = str.substr(0, str.length - 1) + \")\";\n\n      if (_classPrivateFieldLooseBase(this, _dontCares)[_dontCares].length) {\n        str += \"+d(\";\n\n        for (const term of _classPrivateFieldLooseBase(this, _dontCares)[_dontCares]) str += parseInt(term) + \" \";\n\n        str = str.substr(0, str.length - 1) + \")\";\n      }\n\n      return str;\n    };\n\n    if (!_expression2 && !_minTerms2 && !_dontCares2) {\n      throw \"null expression\";\n    }\n\n    _classPrivateFieldLooseBase(this, _minTerms)[_minTerms] = _minTerms2;\n    _classPrivateFieldLooseBase(this, _dontCares)[_dontCares] = _dontCares2;\n    _classPrivateFieldLooseBase(this, _expression)[_expression] = _expression2;\n    _classPrivateFieldLooseBase(this, _isLogged)[_isLogged] = true;\n\n    let _success;\n\n    if (_expression2) _success = this.setExpression(_expression2);else _success = this.setMinTerms(_minTerms2, _dontCares2);\n\n    if (!_success) {\n      if (_classPrivateFieldLooseBase(this, _errorCode)[_errorCode] == -1) throw \"cannot have 0 minimum terms\";else if (_classPrivateFieldLooseBase(this, _errorCode)[_errorCode] >= 0) throw parseInt(_classPrivateFieldLooseBase(this, _errorCode)[_errorCode]) + \" cannot be both a min term and a don't care\";else throw \"expression is not valid\";\n    }\n  }\n\n  static ExpressionInstance(expression, isLogged = false) {\n    return new BoolExpression(expression, null, null, isLogged);\n  }\n\n  static MinTermInstance(minTerms, dontCares, isLogged = false) {\n    return new BoolExpression(null, minTerms, dontCares, isLogged);\n  }\n\n  isEssentialImplicant(qmTerm) {\n    return _classPrivateFieldLooseBase(this, _primeImps)[_primeImps].some(e => QMFuncs.isQMTermEqual(qmTerm, e));\n  }\n\n  isMinTerm(intTerm) {\n    return _classPrivateFieldLooseBase(this, _minTerms)[_minTerms].includes(intTerm);\n  }\n\n  isDontCare(intTerm) {\n    return _classPrivateFieldLooseBase(this, _dontCares)[_dontCares].includes(intTerm);\n  }\n\n}\nObject.defineProperty(BoolExpression, _BOOL_GRAMMAR, {\n  writable: true,\n  value: buildBoolGrammar()\n});","map":{"version":3,"sources":["C:/Users/Andrew/Documents/JavaScript Projects/bool-simp/src/scripts/BooleanSimplifier/BoolExpression.js"],"names":["buildBoolGrammar","deepCopy","validateTerms","getVarBitSet","calculateMinTerms","QMFuncs","PMFuncs","Recognizer","Parser","BitSet","BoolExpression","constructor","expression","minTerms","dontCares","isLogged","getMinTerms","getDontCares","getPetrickSOP","getEssentialImplicants","getVarCount","getQMLog","getPMLog","getTruthTable","getPrimeImpStrings","piStrs","implicant","str","extractMinTerms","term","parseInt","substring","length","toString","push","getSOPStrings","sopStrs","mapProductToString","product","productToString","setExpression","replace","sSet","buildItems","invertedS","invertEarleySets","parseTree","buildParseTree","cardinality","parsed","parseString","validated","errorCode","getVariableCount","setMinTerms","success","nonEssentialPrimeImps","getPrimeImplicants","getEssentialTerms","varRow","varBitSet","i","get","String","fromCharCode","rowCount","row","bits","j","isMinTerm","substr","ExpressionInstance","MinTermInstance","isEssentialImplicant","qmTerm","some","e","isQMTermEqual","intTerm","includes","isDontCare"],"mappings":"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","sourcesContent":["import {\r\n    buildBoolGrammar,\r\n    deepCopy,\r\n    validateTerms,\r\n    getVarBitSet,\r\n    calculateMinTerms,\r\n} from \"./BoolExpressionUtils\";\r\nimport QMFuncs from \"./QMFunctions\";\r\nimport PMFuncs from \"./PMFunctions\";\r\nimport Recognizer from \"../Earley Parser/EarleyRecognizer\";\r\nimport Parser from \"../Earley Parser/EarleyParser\";\r\nimport BitSet from \"bitset\";\r\n\r\nexport default class BoolExpression {\r\n    #varCount;\r\n    #minTerms;\r\n    #dontCares;\r\n    #primeImps;\r\n    #petrickSOP;\r\n\r\n    #sSet;\r\n    #invertedS;\r\n    #parseTree;\r\n    #varBitSet;\r\n    #expression;\r\n\r\n    #errorCode = -2;\r\n    #isLogged = false;\r\n\r\n    #qmLog;\r\n    #pmLog;\r\n\r\n    #truthTable;\r\n\r\n    static #BOOL_GRAMMAR = buildBoolGrammar();\r\n\r\n    constructor(expression, minTerms, dontCares, isLogged = false) {\r\n        if (!expression && !minTerms && !dontCares) {\r\n            throw \"null expression\";\r\n        }\r\n\r\n        this.#minTerms = minTerms;\r\n        this.#dontCares = dontCares;\r\n        this.#expression = expression;\r\n        this.#isLogged = true;\r\n\r\n        let success;\r\n        if (expression) success = this.setExpression(expression);\r\n        else success = this.setMinTerms(minTerms, dontCares);\r\n\r\n        if (!success) {\r\n            if (this.#errorCode == -1) throw \"cannot have 0 minimum terms\";\r\n            else if (this.#errorCode >= 0)\r\n                throw (\r\n                    parseInt(this.#errorCode) +\r\n                    \" cannot be both a min term and a don't care\"\r\n                );\r\n            else throw \"expression is not valid\";\r\n        }\r\n    }\r\n\r\n    static ExpressionInstance(expression, isLogged = false) {\r\n        return new BoolExpression(expression, null, null, isLogged);\r\n    }\r\n\r\n    static MinTermInstance(minTerms, dontCares, isLogged = false) {\r\n        return new BoolExpression(null, minTerms, dontCares, isLogged);\r\n    }\r\n\r\n    getMinTerms = () => deepCopy(this.#minTerms);\r\n    getDontCares = () => deepCopy(this.#dontCares);\r\n    getPetrickSOP = () => deepCopy(this.#petrickSOP);\r\n    getEssentialImplicants = () => deepCopy(this.#primeImps);\r\n    getVarCount = () => this.#varCount;\r\n\r\n    getQMLog = () => (this.#isLogged ? deepCopy(this.#qmLog) : []);\r\n    getPMLog = () => (this.#isLogged ? deepCopy(this.#pmLog) : []);\r\n\r\n    getTruthTable = () => deepCopy(this.#truthTable);\r\n\r\n    getPrimeImpStrings = () => {\r\n        let piStrs = [];\r\n        for (const implicant of this.#primeImps) {\r\n            let str = \"[\";\r\n            let minTerms = QMFuncs.extractMinTerms(implicant);\r\n            for (const term of minTerms) str += parseInt(term) + \"-\";\r\n            str = str.substring(0, str.length - 1) + \"] \";\r\n            str += QMFuncs.toString(implicant, this.#varCount);\r\n            piStrs.push(str);\r\n        }\r\n        return piStrs;\r\n    };\r\n\r\n    getSOPStrings = () => {\r\n        let sopStrs = [];\r\n        if (this.#petrickSOP.length === 0)\r\n            sopStrs.push(PMFuncs.mapProductToString([], this.#varBitSet));\r\n        else {\r\n            for (const product of this.#petrickSOP) {\r\n                if (this.#varBitSet)\r\n                    sopStrs.push(PMFuncs.mapProductToString(product, this.#varBitSet));\r\n                else sopStrs.push(PMFuncs.productToString(product, this.#varCount));\r\n            }\r\n        }\r\n        return sopStrs;\r\n    };\r\n\r\n    setExpression = (expression) => {\r\n        expression = expression.replace(/ /g, \"\");\r\n        let sSet = Recognizer.buildItems(expression, BoolExpression.#BOOL_GRAMMAR);\r\n        let invertedS = Parser.invertEarleySets(sSet, BoolExpression.#BOOL_GRAMMAR);\r\n        let parseTree = Parser.buildParseTree(\r\n            expression,\r\n            invertedS,\r\n            BoolExpression.#BOOL_GRAMMAR\r\n        );\r\n\r\n        if (parseTree !== null) {\r\n            this.#sSet = sSet;\r\n            this.#invertedS = invertedS;\r\n            this.#parseTree = parseTree;\r\n\r\n            this.#varBitSet = getVarBitSet(expression);\r\n            this.#varCount = this.#varBitSet.cardinality();\r\n            this.#minTerms = calculateMinTerms(parseTree, this.#varBitSet);\r\n        } else {\r\n            let [parsed, minTerms, dontCares] = QMFuncs.parseString(expression);\r\n            if (!parsed) {\r\n                this.#errorCode = -2;\r\n                return false;\r\n            }\r\n\r\n            let [validated, errorCode] = validateTerms(minTerms, dontCares);\r\n            if (!validated) {\r\n                this.#errorCode = errorCode;\r\n                return false;\r\n            }\r\n\r\n            this.#varCount = QMFuncs.getVariableCount(minTerms, dontCares);\r\n            this.#minTerms = minTerms;\r\n            this.#dontCares = dontCares;\r\n        }\r\n\r\n        if (this.#isLogged) {\r\n            this.#qmLog = [];\r\n            this.#pmLog = [];\r\n        }\r\n\r\n        this.#reduce();\r\n        this.#buildTruthTable();\r\n\r\n        return true;\r\n    };\r\n\r\n    setMinTerms = (minTerms, dontCares) => {\r\n        let [success, errorCode] = validateTerms(minTerms, dontCares);\r\n        if (!success) {\r\n            this.#errorCode = errorCode;\r\n            return false;\r\n        }\r\n\r\n        this.#minTerms = minTerms;\r\n        this.#dontCares = dontCares;\r\n        this.#varCount = QMFuncs.getVariableCount(minTerms, dontCares);\r\n\r\n        this.#sSet = null;\r\n        this.expression = null;\r\n        this.#invertedS = null;\r\n        this.#parseTree = null;\r\n        this.#varBitSet = null;\r\n\r\n        if (this.#isLogged) {\r\n            this.#qmLog = [];\r\n            this.#pmLog = [];\r\n        }\r\n\r\n        this.#reduce();\r\n        this.#buildTruthTable();\r\n\r\n        return true;\r\n    };\r\n\r\n    #reduce = () => {\r\n        let nonEssentialPrimeImps = QMFuncs.getPrimeImplicants(\r\n            this.#minTerms,\r\n            this.#dontCares,\r\n            this.#qmLog\r\n        );\r\n\r\n        this.#petrickSOP = PMFuncs.getPetrickSOP(\r\n            nonEssentialPrimeImps,\r\n            this.#minTerms,\r\n            this.#pmLog\r\n        );\r\n\r\n        this.#primeImps = QMFuncs.getEssentialTerms(\r\n            nonEssentialPrimeImps,\r\n            this.#minTerms\r\n        );\r\n    };\r\n\r\n    #buildTruthTable = () => {\r\n        this.#truthTable = [];\r\n\r\n        let varRow = [\"#\"];\r\n        if(varBitSet())\r\n        for (let i = 0; i < 26; i++) {\r\n            if (this.#varBitSet.get(i) === 0) continue;\r\n            varRow.push(String.fromCharCode(i + 65));\r\n        }\r\n        varRow.push(\"Output\");\r\n        this.#truthTable.push(varRow);\r\n\r\n        let rowCount = 2 ** this.#varCount;\r\n        for (let i = 0; i < rowCount; i++) {\r\n            let row = [i];\r\n            let bits = new BitSet(i);\r\n            for (let j = 0; j < this.#varCount; j++) {\r\n                row.push(parseInt(bits.get(this.#varCount - 1 - j)));\r\n            }\r\n            row.push(this.isMinTerm(i) ? \"1\" : \"0\");\r\n            this.#truthTable.push(row);\r\n        }\r\n    };\r\n\r\n    toString = () => {\r\n        if (this.#expression) return this.#expression;\r\n\r\n        let str = \"m(\";\r\n        for (const term of this.#minTerms) str += parseInt(term) + \" \";\r\n        str = str.substr(0, str.length - 1) + \")\";\r\n\r\n        if (this.#dontCares.length) {\r\n            str += \"+d(\";\r\n            for (const term of this.#dontCares) str += parseInt(term) + \" \";\r\n            str = str.substr(0, str.length - 1) + \")\";\r\n        }\r\n\r\n        return str;\r\n    };\r\n\r\n    isEssentialImplicant(qmTerm) {\r\n        return this.#primeImps.some((e) => QMFuncs.isQMTermEqual(qmTerm, e));\r\n    }\r\n\r\n    isMinTerm(intTerm) {\r\n        return this.#minTerms.includes(intTerm);\r\n    }\r\n\r\n    isDontCare(intTerm) {\r\n        return this.#dontCares.includes(intTerm);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}