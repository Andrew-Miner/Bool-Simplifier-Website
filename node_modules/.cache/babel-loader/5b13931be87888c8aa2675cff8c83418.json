{"ast":null,"code":"import StructFactory from \"../StructFactory\";\nimport BitSet from \"bitset\";\nconst QMTerm = StructFactory(\"term dashMask used\");\nconst REG_TERMS = \"/ *m *\\\\( *(\\\\d+)(?:, *\\\\d+)* *\\\\)/\";\nconst REG_DONTS = \"/ *\\\\+ *d *\\\\( *(\\\\d+)(?:, *\\\\d+)* *\\\\)\";\nconst QM = {\n  getPrimeImplicants(minTerms, dontCares, log) {\n    let allTerms = dontCares ? minTerms.concat(dontCares) : minTerms;\n    let qmTerms = this.getQMArray(allTerms);\n    qmTerms = this.fromatQMArray(qmTerms);\n    let reducedTerms = [];\n    this.reduceQMTerms(qmTerms, reducedTerms, log);\n    this.removeDuplicateTerms(reducedTerms);\n    return reducedTerms;\n  },\n\n  toString(qmTerm, variableCount) {\n    let varLimit = variableCount === 0 ? 25 : variableCount - 1;\n    let str = \"\";\n\n    for (let i = varLimit; i >= 0; i--) {\n      if ((i + 1) % 4 === 0) str += \" \";\n      if (qmTerm.dashMask.get(i) === 1) str += \"-\";else str += qmTerm.term.get(i);\n    }\n\n    return str;\n  },\n\n  getQMArray(intTerms) {\n    let terms = [];\n    intTerms.forEach(term => {\n      terms.push(new QMTerm(new BitSet(term), new BitSet(0), false));\n    });\n    return terms;\n  },\n\n  fromatQMArray(qmTerms) {\n    // compareQMTerms works like a standard comparison function\n    // and must be multiplied by -1 to sort in decending order\n    return qmTerms.sort((term1, term2) => {\n      return QM.compareQMTerms(term1, term2) * -1;\n    });\n  },\n\n  // This function iterates the dashMask bitset\n  // forward once and backward once. Each time it\n  // comes accross a set bit it flips that bit in\n  // in the minTerm bitset and stores the new\n  // minTerm value. Aka O(n).\n  extractMinTerms(qmTerm) {\n    let minTerm = qmTerm.term;\n    let resultant = [parseInt(minTerm.toString(10))];\n    let curCount = 1;\n    let dashPos = -1;\n    let forward = true;\n    let minTermCount = 2 ** qmTerm.dashMask.cardinality();\n\n    while (curCount < minTermCount) {\n      let nextPos = -1;\n      if (forward) nextPos = this.nextDash(qmTerm.dashMask, dashPos);else nextPos = this.prevDash(qmTerm.dashMask, dashPos);\n\n      if (nextPos === -1) {\n        forward = !forward;\n        continue;\n      }\n\n      dashPos = nextPos;\n      minTerm.flip(dashPos);\n      resultant.push(parseInt(minTerm.toString(10)));\n      curCount++;\n    }\n\n    return resultant;\n  },\n\n  reduceQMTerms(qmTerms, resultant, log) {\n    let tmpTerms = qmTerms.slice();\n    let reducedTerms = [];\n    if (log) log.push(qmTerms);\n\n    for (let i = 0; i < tmpTerms.length;) {\n      for (let j = i + 1; j < tmpTerms.length; j++) {\n        if (tmpTerms[i].dashMask.equals(tmpTerms[j].dashMask)) {\n          // Core of QM Method\n          let resultant = new QMTerm(tmpTerms[i].term.and(tmpTerms[j].term), tmpTerms[i].term.xor(tmpTerms[j].term), false); // Real resultant will always have 1 more dash mark than the original terms\n\n          if (resultant.dashMask.cardinality() != 1) continue;\n          resultant.dashMask = resultant.dashMask.or(tmpTerms[i].dashMask);\n          reducedTerms.push(resultant);\n          tmpTerms[i].used = true;\n          tmpTerms[j].used = true;\n        }\n      } // Remove Used Terms\n\n\n      if (tmpTerms[i].used) tmpTerms.splice(i, 1);else i++;\n    } // Remove any remaining used terms\n\n\n    for (let i = 0; i < tmpTerms.length;) {\n      if (tmpTerms[i].used) tmpTerms.splice(i, 1);else i++;\n    } // Save unused Terms\n\n\n    resultant.push(...tmpTerms); // If we're not done reducing\n\n    if (reducedTerms.length != 0) {\n      this.removeDuplicateTerms(reducedTerms);\n      this.reduceQMTerms(reducedTerms, resultant, log);\n    }\n  },\n\n  removeDuplicateTerms(qmTerms) {\n    for (let i = 0; i < qmTerms.length; i++) {\n      for (let j = i + 1; j < qmTerms.length;) {\n        if (qmTerms[i].term.equals(qmTerms[j].term) && qmTerms[i].dashMask.equals(qmTerms[j].dashMask)) qmTerms.splice(j, 1);else j++;\n      }\n    }\n  },\n\n  compareQMTerms(qmTerm1, qmTerm2) {\n    let term1 = parseInt(qmTerm1.term.toString(10));\n    let term2 = parseInt(qmTerm2.term.toString(10));\n    return term1 < term2 ? -1 : term1 > term2 ? 1 : 0;\n  },\n\n  prevDash(dashMask, pos) {\n    for (let i = pos === -1 ? dashMask.cardinality() - 1 : pos - 1; i >= 0; i--) {\n      if (dashMask.get(i) === 1) return i;\n    }\n\n    return -1;\n  },\n\n  nextDash(dashMask, pos) {\n    for (let i = pos === -1 ? 0 : pos + 1; i < dashMask.toString().length; i++) {\n      if (dashMask.get(i) === 1) return i;\n    }\n\n    return -1;\n  },\n\n  parseString(expression) {\n    return [false, [], []];\n  },\n\n  getVariableCount(minTerms, dontCares) {\n    let highest = 0;\n    minTerms.forEach(term => {\n      if (term > highest) highest = term;else if (!highest && !term) highest = 1;\n    });\n    dontCares.forEach(term => {\n      if (term > highest) highest = term;\n    });\n    let bits = 0;\n\n    while (highest) {\n      highest >>>= 1;\n      bits++;\n    }\n\n    return bits;\n  },\n\n  getEssentialTerms(qmTerms, minTerms) {\n    let essentialTerms = [];\n\n    for (let i = 0; i < qmTerms.length; i++) {\n      let mins = this.extractMinTerms(qmTerms[i]);\n\n      for (let j = 0; j < mins.length; j++) {\n        if (minTerms.find(element => element === mins[j])) {\n          essentialTerms.push(qmTerms[i]);\n          break;\n        }\n      }\n    }\n\n    return essentialTerms;\n  },\n\n  isQMTermEqual(qmTerm1, qmTerm2) {\n    return qmTerm1.term.equals(qmTerm2.term) && qmTerm1.dashMask.equals(qmTerm2.dashMask);\n  }\n\n};\nexport default QM;","map":{"version":3,"sources":["C:/Users/Andrew/Documents/JavaScript Projects/bool-simp/src/scripts/BooleanSimplifier/QMFunctions.js"],"names":["StructFactory","BitSet","QMTerm","REG_TERMS","REG_DONTS","QM","getPrimeImplicants","minTerms","dontCares","log","allTerms","concat","qmTerms","getQMArray","fromatQMArray","reducedTerms","reduceQMTerms","removeDuplicateTerms","toString","qmTerm","variableCount","varLimit","str","i","dashMask","get","term","intTerms","terms","forEach","push","sort","term1","term2","compareQMTerms","extractMinTerms","minTerm","resultant","parseInt","curCount","dashPos","forward","minTermCount","cardinality","nextPos","nextDash","prevDash","flip","tmpTerms","slice","length","j","equals","and","xor","or","used","splice","qmTerm1","qmTerm2","pos","parseString","expression","getVariableCount","highest","bits","getEssentialTerms","essentialTerms","mins","find","element","isQMTermEqual"],"mappings":"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","sourcesContent":["import StructFactory from \"../StructFactory\";\r\nimport BitSet from \"bitset\";\r\nconst QMTerm = StructFactory(\"term dashMask used\");\r\nconst REG_TERMS = \"/ *m *\\\\( *(\\\\d+)(?:, *\\\\d+)* *\\\\)/\";\r\nconst REG_DONTS = \"/ *\\\\+ *d *\\\\( *(\\\\d+)(?:, *\\\\d+)* *\\\\)\";\r\n\r\nconst QM = {\r\n    getPrimeImplicants(minTerms, dontCares, log) {\r\n        let allTerms = dontCares ? minTerms.concat(dontCares) : minTerms;\r\n        let qmTerms = this.getQMArray(allTerms);\r\n        qmTerms = this.fromatQMArray(qmTerms);\r\n\r\n        let reducedTerms = [];\r\n        this.reduceQMTerms(qmTerms, reducedTerms, log);\r\n        this.removeDuplicateTerms(reducedTerms);\r\n        return reducedTerms;\r\n    },\r\n\r\n    toString(qmTerm, variableCount) {\r\n        let varLimit = variableCount === 0 ? 25 : variableCount - 1;\r\n\r\n        let str = \"\";\r\n        for (let i = varLimit; i >= 0; i--) {\r\n            if ((i + 1) % 4 === 0) str += \" \";\r\n            if (qmTerm.dashMask.get(i) === 1) str += \"-\";\r\n            else str += qmTerm.term.get(i);\r\n        }\r\n        return str;\r\n    },\r\n\r\n    getQMArray(intTerms) {\r\n        let terms = [];\r\n        intTerms.forEach((term) => {\r\n            terms.push(new QMTerm(new BitSet(term), new BitSet(0), false));\r\n        });\r\n        return terms;\r\n    },\r\n\r\n    fromatQMArray(qmTerms) {\r\n        // compareQMTerms works like a standard comparison function\r\n        // and must be multiplied by -1 to sort in decending order\r\n        return qmTerms.sort((term1, term2) => {\r\n            return QM.compareQMTerms(term1, term2) * -1;\r\n        });\r\n    },\r\n\r\n    // This function iterates the dashMask bitset\r\n    // forward once and backward once. Each time it\r\n    // comes accross a set bit it flips that bit in\r\n    // in the minTerm bitset and stores the new\r\n    // minTerm value. Aka O(n).\r\n    extractMinTerms(qmTerm) {\r\n        let minTerm = qmTerm.term;\r\n        let resultant = [parseInt(minTerm.toString(10))];\r\n\r\n        let curCount = 1;\r\n        let dashPos = -1;\r\n        let forward = true;\r\n        let minTermCount = 2 ** qmTerm.dashMask.cardinality();\r\n\r\n        while (curCount < minTermCount) {\r\n            let nextPos = -1;\r\n\r\n            if (forward) nextPos = this.nextDash(qmTerm.dashMask, dashPos);\r\n            else nextPos = this.prevDash(qmTerm.dashMask, dashPos);\r\n\r\n            if (nextPos === -1) {\r\n                forward = !forward;\r\n                continue;\r\n            }\r\n\r\n            dashPos = nextPos;\r\n            minTerm.flip(dashPos);\r\n            resultant.push(parseInt(minTerm.toString(10)));\r\n            curCount++;\r\n        }\r\n\r\n        return resultant;\r\n    },\r\n\r\n    reduceQMTerms(qmTerms, resultant, log) {\r\n        let tmpTerms = qmTerms.slice();\r\n        let reducedTerms = [];\r\n\r\n        if (log) log.push(qmTerms);\r\n\r\n        for (let i = 0; i < tmpTerms.length; ) {\r\n            for (let j = i + 1; j < tmpTerms.length; j++) {\r\n                if (tmpTerms[i].dashMask.equals(tmpTerms[j].dashMask)) {\r\n                    // Core of QM Method\r\n                    let resultant = new QMTerm(\r\n                        tmpTerms[i].term.and(tmpTerms[j].term),\r\n                        tmpTerms[i].term.xor(tmpTerms[j].term),\r\n                        false\r\n                    );\r\n\r\n                    // Real resultant will always have 1 more dash mark than the original terms\r\n                    if (resultant.dashMask.cardinality() != 1) continue;\r\n\r\n                    resultant.dashMask = resultant.dashMask.or(tmpTerms[i].dashMask);\r\n\r\n                    reducedTerms.push(resultant);\r\n\r\n                    tmpTerms[i].used = true;\r\n                    tmpTerms[j].used = true;\r\n                }\r\n            }\r\n\r\n            // Remove Used Terms\r\n            if (tmpTerms[i].used) tmpTerms.splice(i, 1);\r\n            else i++;\r\n        }\r\n\r\n        // Remove any remaining used terms\r\n        for (let i = 0; i < tmpTerms.length; ) {\r\n            if (tmpTerms[i].used) tmpTerms.splice(i, 1);\r\n            else i++;\r\n        }\r\n\r\n        // Save unused Terms\r\n        resultant.push(...tmpTerms);\r\n\r\n        // If we're not done reducing\r\n        if (reducedTerms.length != 0) {\r\n            this.removeDuplicateTerms(reducedTerms);\r\n            this.reduceQMTerms(reducedTerms, resultant, log);\r\n        }\r\n    },\r\n\r\n    removeDuplicateTerms(qmTerms) {\r\n        for (let i = 0; i < qmTerms.length; i++) {\r\n            for (let j = i + 1; j < qmTerms.length; ) {\r\n                if (\r\n                    qmTerms[i].term.equals(qmTerms[j].term) &&\r\n                    qmTerms[i].dashMask.equals(qmTerms[j].dashMask)\r\n                )\r\n                    qmTerms.splice(j, 1);\r\n                else j++;\r\n            }\r\n        }\r\n    },\r\n\r\n    compareQMTerms(qmTerm1, qmTerm2) {\r\n        let term1 = parseInt(qmTerm1.term.toString(10));\r\n        let term2 = parseInt(qmTerm2.term.toString(10));\r\n        return term1 < term2 ? -1 : term1 > term2 ? 1 : 0;\r\n    },\r\n\r\n    prevDash(dashMask, pos) {\r\n        for (let i = pos === -1 ? dashMask.cardinality() - 1 : pos - 1; i >= 0; i--) {\r\n            if (dashMask.get(i) === 1) return i;\r\n        }\r\n        return -1;\r\n    },\r\n\r\n    nextDash(dashMask, pos) {\r\n        for (let i = pos === -1 ? 0 : pos + 1; i < dashMask.toString().length; i++) {\r\n            if (dashMask.get(i) === 1) return i;\r\n        }\r\n        return -1;\r\n    },\r\n\r\n    parseString(expression) {\r\n        return [false, [], []];\r\n    },\r\n\r\n    getVariableCount(minTerms, dontCares) {\r\n        let highest = 0;\r\n\r\n        minTerms.forEach((term) => {\r\n            if (term > highest) highest = term;\r\n            else if (!highest && !term) highest = 1;\r\n        });\r\n\r\n        dontCares.forEach((term) => {\r\n            if (term > highest) highest = term;\r\n        });\r\n\r\n        let bits = 0;\r\n        while (highest) {\r\n            highest >>>= 1;\r\n            bits++;\r\n        }\r\n\r\n        return bits;\r\n    },\r\n\r\n    getEssentialTerms(qmTerms, minTerms) {\r\n        let essentialTerms = [];\r\n\r\n        for (let i = 0; i < qmTerms.length; i++) {\r\n            let mins = this.extractMinTerms(qmTerms[i]);\r\n            for (let j = 0; j < mins.length; j++) {\r\n                if (minTerms.find((element) => element === mins[j])) {\r\n                    essentialTerms.push(qmTerms[i]);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return essentialTerms;\r\n    },\r\n\r\n    isQMTermEqual(qmTerm1, qmTerm2) {\r\n        return (\r\n            qmTerm1.term.equals(qmTerm2.term) && qmTerm1.dashMask.equals(qmTerm2.dashMask)\r\n        );\r\n    },\r\n};\r\n\r\nexport default QM;\r\n"]},"metadata":{},"sourceType":"module"}