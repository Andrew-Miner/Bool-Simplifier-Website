{"ast":null,"code":"import StructFactory from \"../StructFactory\";\nimport QM from \"./QMFunctions\";\nconst LabelPair = StructFactory(\"qmTerm varName\");\nconst PM = {\n  getPetrickSOP(primeImps, minTerms, log) {\n    let groupsMap = this.groupPrimeImplicants(primeImps, minTerms);\n    let labels = [];\n\n    if (log && primeImps.length) {\n      let count = 0;\n\n      for (const term of primeImps) {\n        labels.push(new LabelPair(term, String.fromCharCode((\"K\".charCodeAt(0) - 65 + count++) % 26 + 65)));\n      }\n\n      let str = \"\";\n\n      for (const value of groupsMap) str += this.sumToString(value, labels);\n\n      log.push(str);\n    }\n\n    let solution = this.expandGroups(groupsMap, log, labels);\n    this.removeLargerTerms(solution);\n    this.removeSmallerDashes(solution);\n\n    if (log && primeImps.length) {\n      let str = \"(\" + this.sopToString(solution, labels) + \")\";\n      if (log[log.length - 1] !== str) log.push(str);\n    }\n\n    return solution;\n  },\n\n  sumToString(sum, labels) {\n    if (sum.length === 0) return \"\";\n    let str = \"(\";\n\n    for (const term of sum) {\n      let found = labels.find(pair => pair.qmTerm.term.equals(term.term) && pair.qmTerm.dashMask.equals(term.dashMask));\n\n      if (found !== undefined) {\n        str += found.varName + \" + \";\n      }\n    }\n\n    str = str.substr(0, str.length - 3) + \")\";\n    return str;\n  },\n\n  groupPrimeImplicants(primeImps, minTerms) {\n    let groups = new Map(); // Initialize Groups\n\n    for (let i = 0; i < minTerms.length; i++) groups.set(minTerms[i], []); // Group Prime Imps (QMTerms)\n\n\n    for (let i = 0; i < primeImps.length; i++) {\n      // Calculate min terms using dash positions\n      let piMinTerms = QM.extractMinTerms(primeImps[i]);\n\n      for (let j = 0; j < piMinTerms.length; j++) {\n        // If extracted min term is not a don't care, insert it into the map\n        if (groups.has(piMinTerms[j])) groups.get(piMinTerms[j]).push(primeImps[i]);\n      }\n    }\n\n    return groups;\n  },\n\n  // returns SOP\n  expandGroups(groups, log, labels) {\n    if (!groups.size) return [];\n    let keys = Array.from(groups.keys());\n    if (keys.length === 0) return [];\n    let workingSOP = this.toSOP(groups.get(keys[0]));\n\n    for (let i = 1; i < keys.length; i++) {\n      let group = groups.get(keys[i]);\n\n      if (group.length) {\n        let nextSOP = this.toSOP(group);\n        workingSOP = this.foilSums(workingSOP, nextSOP);\n        workingSOP.sort((sop1, sop2) => sop1.length < sop2.length ? -1 : sop1.length > sop2.length ? 1 : 0);\n\n        let logSOP = sop => {\n          let logStr = \"(\" + this.sopToString(sop, labels) + \")\";\n\n          for (let j = i + 1; j < keys.length; j++) logStr += this.sumToString(groups.get(keys[j]), labels);\n\n          log.push(logStr);\n        };\n\n        if (log) logSOP(workingSOP);\n        workingSOP = this.simplifySOP(workingSOP);\n        if (log) logSOP(workingSOP);\n      }\n    }\n\n    return workingSOP;\n  },\n\n  // returns SOP\n  oldExpandGroups(groups, log, labels) {\n    if (!groups.size) return [];\n    let workingSOP;\n\n    for (let value of groups.values()) {\n      if (workingSOP === undefined) {\n        workingSOP = this.toSOP(value);\n        continue;\n      }\n\n      if (value.length) {\n        let nextSOP = this.toSOP(value);\n        workingSOP = this.foilSums(workingSOP, nextSOP);\n        workingSOP.sort((sop1, sop2) => sop1.length > sop2.length && 1 || -1);\n        workingSOP = this.simplifySOP(workingSOP);\n      }\n    }\n\n    return workingSOP;\n  },\n\n  toSOP(sum) {\n    let result = [];\n\n    for (let i = 0; i < sum.length; i++) {\n      result.push([sum[i]]);\n    }\n\n    return result;\n  },\n\n  removeLargerTerms(expression) {\n    if (expression.length === 0) return; // Find smallest term size and remove those larger\n\n    let smallest = expression[0].length;\n\n    for (let i = 1; i < expression.length;) {\n      if (expression[i].length > smallest) expression.splice(i, 1);else {\n        if (expression[i].length < smallest) smallest = expression[i].length;\n        i++;\n      }\n    } // Iterate one more time to remove remaining large terms\n\n\n    for (let i = 0; i < expression.length;) {\n      if (expression[i].length > smallest) expression.splice(i, 1);else i++;\n    }\n  },\n\n  removeSmallerDashes(expression) {\n    if (expression.length === 0) return; // Find largest dash count and remove those smaller\n\n    let largestDash = 0;\n\n    for (let i = 0; i < expression.length;) {\n      let dashCount = 0;\n\n      for (let j = 0; j < expression[i].length; j++) dashCount += expression[i][j].dashMask.cardinality();\n\n      if (dashCount < largestDash) expression.splice(i, 1);else {\n        largestDash = dashCount;\n        i++;\n      }\n    } // Iterate one more time to remove remaning small (larger) terms\n\n\n    for (let i = 0; i < expression.length;) {\n      let dashCount = 0;\n\n      for (let j = 0; j < expression[i].length; j++) dashCount += expression[i][j].dashMask.cardinality();\n\n      if (dashCount < largestDash) expression.splice(i, 1);else i++;\n    }\n  },\n\n  foilSums(firstSum, secondSum) {\n    let result = [];\n\n    for (let i = 0; i < firstSum.length; i++) {\n      for (let j = 0; j < secondSum.length; j++) {\n        for (let k = 0; k < secondSum[j].length; k++) {\n          let product = firstSum[i].slice();\n          let findVar = product.find(element => element === secondSum[j][k]);\n          if (findVar === undefined) product.push(secondSum[j][k]);\n          result.push(product);\n        }\n      }\n    }\n\n    return result;\n  },\n\n  // Precondition: SOP is sorted by var count per term\n  simplifySOP(sop) {\n    let simplified = sop.slice();\n\n    for (let i = 0; i < simplified.length; i++) {\n      for (let j = i + 1; j < simplified.length;) {\n        if (this.isProductSubset(simplified[i], simplified[j])) simplified.splice(j, 1);else j++;\n      }\n    }\n\n    return simplified;\n  },\n\n  lessThanQMArray(array1, array2) {},\n\n  isQMArrayEqual(array1, array2) {},\n\n  isProductUnique(sop, product) {},\n\n  isProductSubset(subset, superset) {\n    if (subset.length > superset.length) return false;\n\n    for (let i = 0; i < subset.length; i++) {\n      if (superset.find(element => {\n        return element.term.equals(subset[i].term) && element.dashMask.equals(subset[i].dashMask);\n      }) === undefined) return false;\n    }\n\n    return true;\n  },\n\n  productToString(product, varCount) {\n    let varLimit = varCount === 0 ? 25 : varCount - 1; // Edge case for contradictions\n\n    if (product.length === 0) return \"0\"; // Edge case for tautologies\n\n    if (product.length === 1 && product[0].term.cardinality() === 0 && product[0].dashMask.cardinality() === varCount + 1) return \"1\";\n    let string = \"\";\n\n    for (let i = product.length - 1; i >= 0; i--) {\n      let firstVar = true;\n\n      for (let j = varLimit; j >= 0; j--) {\n        if (product[i].dashMask.get(j) === 0) {\n          if (!firstVar) string += \"*\";else firstVar = false;\n          if (product[i].term.get(j) === 0) string += \"~\";\n          string += String.fromCharCode(65 + (varLimit - j));\n        }\n      }\n\n      if (i - 1 >= 0) string += \" + \";\n    }\n\n    return string;\n  },\n\n  mapProductToString(product, varBitSet) {\n    // Edge case for contradictions\n    if (product.length === 0) return \"0\"; // Edge case for tautologies\n\n    if (product.length === 1 && product[0].term.cardinality() === 0 && product[0].dashMask.cardinality() === varBitSet.cardinality()) return \"1\";\n    let varLimit = varBitSet.cardinality() - 1;\n    let varPos = 0;\n    let conversionMap = new Map();\n\n    for (let i = 0; i < 26; i++) {\n      if (varBitSet.get(i) === 0) continue;\n      conversionMap.set(varLimit - varPos++, String.fromCharCode(i + 65));\n    }\n\n    let string = \"\";\n\n    for (let i = product.length - 1; i >= 0; i--) {\n      let firstVar = true;\n\n      for (let j = varLimit; j >= 0; j--) {\n        if (product[i].dashMask.get(j) === 0) {\n          if (!firstVar) string += \"*\";else firstVar = false;\n          if (product[i].term.get(j) === 0) string += \"~\";\n          string += conversionMap.get(j);\n        }\n      }\n\n      if (i - 1 >= 0) string += \" + \";\n    }\n\n    return string;\n  },\n\n  sopToString(sop, labels) {\n    let str = \"\";\n\n    for (const term of sop) {\n      for (const product of term) {\n        let found = labels.find(pair => pair.qmTerm.term.equals(product.term) && pair.qmTerm.dashMask.equals(product.dashMask));\n        if (found !== undefined) str += found.varName;\n      }\n\n      str += \" + \";\n    }\n\n    str = str.substr(0, str.length - 3);\n    return str;\n  }\n\n};\nexport default PM;","map":{"version":3,"sources":["C:/Users/Andrew/Documents/JavaScript Projects/bool-simp/src/scripts/BooleanSimplifier/PMFunctions.js"],"names":["StructFactory","QM","LabelPair","PM","getPetrickSOP","primeImps","minTerms","log","groupsMap","groupPrimeImplicants","labels","length","count","term","push","String","fromCharCode","charCodeAt","str","value","sumToString","solution","expandGroups","removeLargerTerms","removeSmallerDashes","sopToString","sum","found","find","pair","qmTerm","equals","dashMask","undefined","varName","substr","groups","Map","i","set","piMinTerms","extractMinTerms","j","has","get","size","keys","Array","from","workingSOP","toSOP","group","nextSOP","foilSums","sort","sop1","sop2","logSOP","sop","logStr","simplifySOP","oldExpandGroups","values","result","expression","smallest","splice","largestDash","dashCount","cardinality","firstSum","secondSum","k","product","slice","findVar","element","simplified","isProductSubset","lessThanQMArray","array1","array2","isQMArrayEqual","isProductUnique","subset","superset","productToString","varCount","varLimit","string","firstVar","mapProductToString","varBitSet","varPos","conversionMap"],"mappings":"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","sourcesContent":["import StructFactory from \"../StructFactory\";\r\nimport QM from \"./QMFunctions\";\r\n\r\nconst LabelPair = StructFactory(\"qmTerm varName\");\r\n\r\nconst PM = {\r\n    getPetrickSOP(primeImps, minTerms, log) {\r\n        let groupsMap = this.groupPrimeImplicants(primeImps, minTerms);\r\n\r\n        let labels = [];\r\n        if (log && primeImps.length) {\r\n            let count = 0;\r\n            for (const term of primeImps) {\r\n                labels.push(\r\n                    new LabelPair(\r\n                        term,\r\n                        String.fromCharCode(\r\n                            ((\"K\".charCodeAt(0) - 65 + count++) % 26) + 65\r\n                        )\r\n                    )\r\n                );\r\n            }\r\n\r\n            let str = \"\";\r\n            for (const value of groupsMap) str += this.sumToString(value, labels);\r\n            log.push(str);\r\n        }\r\n\r\n        let solution = this.expandGroups(groupsMap, log, labels);\r\n        this.removeLargerTerms(solution);\r\n        this.removeSmallerDashes(solution);\r\n\r\n        if (log && primeImps.length) {\r\n            let str = \"(\" + this.sopToString(solution, labels) + \")\";\r\n            if (log[log.length - 1] !== str) log.push(str);\r\n        }\r\n\r\n        return solution;\r\n    },\r\n\r\n    sumToString(sum, labels) {\r\n        if (sum.length === 0) return \"\";\r\n\r\n        let str = \"(\";\r\n        for (const term of sum) {\r\n            let found = labels.find(\r\n                (pair) =>\r\n                    pair.qmTerm.term.equals(term.term) &&\r\n                    pair.qmTerm.dashMask.equals(term.dashMask)\r\n            );\r\n            if (found !== undefined) {\r\n                str += found.varName + \" + \";\r\n            }\r\n        }\r\n        str = str.substr(0, str.length - 3) + \")\";\r\n        return str;\r\n    },\r\n\r\n    groupPrimeImplicants(primeImps, minTerms) {\r\n        let groups = new Map();\r\n\r\n        // Initialize Groups\r\n        for (let i = 0; i < minTerms.length; i++) groups.set(minTerms[i], []);\r\n\r\n        // Group Prime Imps (QMTerms)\r\n        for (let i = 0; i < primeImps.length; i++) {\r\n            // Calculate min terms using dash positions\r\n            let piMinTerms = QM.extractMinTerms(primeImps[i]);\r\n\r\n            for (let j = 0; j < piMinTerms.length; j++) {\r\n                // If extracted min term is not a don't care, insert it into the map\r\n                if (groups.has(piMinTerms[j]))\r\n                    groups.get(piMinTerms[j]).push(primeImps[i]);\r\n            }\r\n        }\r\n\r\n        return groups;\r\n    },\r\n\r\n    // returns SOP\r\n    expandGroups(groups, log, labels) {\r\n        if (!groups.size) return [];\r\n\r\n        let keys = Array.from(groups.keys());\r\n        if (keys.length === 0) return [];\r\n\r\n        let workingSOP = this.toSOP(groups.get(keys[0]));\r\n        for (let i = 1; i < keys.length; i++) {\r\n            let group = groups.get(keys[i]);\r\n            if (group.length) {\r\n                let nextSOP = this.toSOP(group);\r\n                workingSOP = this.foilSums(workingSOP, nextSOP);\r\n\r\n                workingSOP.sort((sop1, sop2) =>\r\n                    sop1.length < sop2.length ? -1 : sop1.length > sop2.length ? 1 : 0\r\n                );\r\n\r\n                let logSOP = (sop) => {\r\n                    let logStr = \"(\" + this.sopToString(sop, labels) + \")\";\r\n                    for (let j = i + 1; j < keys.length; j++)\r\n                        logStr += this.sumToString(groups.get(keys[j]), labels);\r\n                    log.push(logStr);\r\n                };\r\n\r\n                if (log) logSOP(workingSOP);\r\n                workingSOP = this.simplifySOP(workingSOP);\r\n                if (log) logSOP(workingSOP);\r\n            }\r\n        }\r\n\r\n        return workingSOP;\r\n    },\r\n\r\n    // returns SOP\r\n    oldExpandGroups(groups, log, labels) {\r\n        if (!groups.size) return [];\r\n\r\n        let workingSOP;\r\n        for (let value of groups.values()) {\r\n            if (workingSOP === undefined) {\r\n                workingSOP = this.toSOP(value);\r\n                continue;\r\n            }\r\n\r\n            if (value.length) {\r\n                let nextSOP = this.toSOP(value);\r\n                workingSOP = this.foilSums(workingSOP, nextSOP);\r\n\r\n                workingSOP.sort((sop1, sop2) => (sop1.length > sop2.length && 1) || -1);\r\n                workingSOP = this.simplifySOP(workingSOP);\r\n            }\r\n        }\r\n\r\n        return workingSOP;\r\n    },\r\n\r\n    toSOP(sum) {\r\n        let result = [];\r\n\r\n        for (let i = 0; i < sum.length; i++) {\r\n            result.push([sum[i]]);\r\n        }\r\n\r\n        return result;\r\n    },\r\n\r\n    removeLargerTerms(expression) {\r\n        if (expression.length === 0) return;\r\n\r\n        // Find smallest term size and remove those larger\r\n        let smallest = expression[0].length;\r\n\r\n        for (let i = 1; i < expression.length; ) {\r\n            if (expression[i].length > smallest) expression.splice(i, 1);\r\n            else {\r\n                if (expression[i].length < smallest) smallest = expression[i].length;\r\n                i++;\r\n            }\r\n        }\r\n\r\n        // Iterate one more time to remove remaining large terms\r\n        for (let i = 0; i < expression.length; ) {\r\n            if (expression[i].length > smallest) expression.splice(i, 1);\r\n            else i++;\r\n        }\r\n    },\r\n\r\n    removeSmallerDashes(expression) {\r\n        if (expression.length === 0) return;\r\n\r\n        // Find largest dash count and remove those smaller\r\n        let largestDash = 0;\r\n        for (let i = 0; i < expression.length; ) {\r\n            let dashCount = 0;\r\n            for (let j = 0; j < expression[i].length; j++)\r\n                dashCount += expression[i][j].dashMask.cardinality();\r\n\r\n            if (dashCount < largestDash) expression.splice(i, 1);\r\n            else {\r\n                largestDash = dashCount;\r\n                i++;\r\n            }\r\n        }\r\n\r\n        // Iterate one more time to remove remaning small (larger) terms\r\n        for (let i = 0; i < expression.length; ) {\r\n            let dashCount = 0;\r\n            for (let j = 0; j < expression[i].length; j++)\r\n                dashCount += expression[i][j].dashMask.cardinality();\r\n\r\n            if (dashCount < largestDash) expression.splice(i, 1);\r\n            else i++;\r\n        }\r\n    },\r\n\r\n    foilSums(firstSum, secondSum) {\r\n        let result = [];\r\n        for (let i = 0; i < firstSum.length; i++) {\r\n            for (let j = 0; j < secondSum.length; j++) {\r\n                for (let k = 0; k < secondSum[j].length; k++) {\r\n                    let product = firstSum[i].slice();\r\n                    let findVar = product.find((element) => element === secondSum[j][k]);\r\n                    if (findVar === undefined) product.push(secondSum[j][k]);\r\n                    result.push(product);\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    },\r\n\r\n    // Precondition: SOP is sorted by var count per term\r\n    simplifySOP(sop) {\r\n        let simplified = sop.slice();\r\n        for (let i = 0; i < simplified.length; i++) {\r\n            for (let j = i + 1; j < simplified.length; ) {\r\n                if (this.isProductSubset(simplified[i], simplified[j]))\r\n                    simplified.splice(j, 1);\r\n                else j++;\r\n            }\r\n        }\r\n        return simplified;\r\n    },\r\n\r\n    lessThanQMArray(array1, array2) {},\r\n    isQMArrayEqual(array1, array2) {},\r\n    isProductUnique(sop, product) {},\r\n    isProductSubset(subset, superset) {\r\n        if (subset.length > superset.length) return false;\r\n\r\n        for (let i = 0; i < subset.length; i++) {\r\n            if (\r\n                superset.find((element) => {\r\n                    return (\r\n                        element.term.equals(subset[i].term) &&\r\n                        element.dashMask.equals(subset[i].dashMask)\r\n                    );\r\n                }) === undefined\r\n            )\r\n                return false;\r\n        }\r\n\r\n        return true;\r\n    },\r\n\r\n    productToString(product, varCount) {\r\n        let varLimit = varCount === 0 ? 25 : varCount - 1;\r\n\r\n        // Edge case for contradictions\r\n        if (product.length === 0) return \"0\";\r\n\r\n        // Edge case for tautologies\r\n        if (\r\n            product.length === 1 &&\r\n            product[0].term.cardinality() === 0 &&\r\n            product[0].dashMask.cardinality() === varCount + 1\r\n        )\r\n            return \"1\";\r\n\r\n        let string = \"\";\r\n        for (let i = product.length - 1; i >= 0; i--) {\r\n            let firstVar = true;\r\n            for (let j = varLimit; j >= 0; j--) {\r\n                if (product[i].dashMask.get(j) === 0) {\r\n                    if (!firstVar) string += \"*\";\r\n                    else firstVar = false;\r\n\r\n                    if (product[i].term.get(j) === 0) string += \"~\";\r\n                    string += String.fromCharCode(65 + (varLimit - j));\r\n                }\r\n            }\r\n\r\n            if (i - 1 >= 0) string += \" + \";\r\n        }\r\n        return string;\r\n    },\r\n\r\n    mapProductToString(product, varBitSet) {\r\n        // Edge case for contradictions\r\n        if (product.length === 0) return \"0\";\r\n\r\n        // Edge case for tautologies\r\n        if (\r\n            product.length === 1 &&\r\n            product[0].term.cardinality() === 0 &&\r\n            product[0].dashMask.cardinality() === varBitSet.cardinality()\r\n        )\r\n            return \"1\";\r\n\r\n        let varLimit = varBitSet.cardinality() - 1;\r\n        let varPos = 0;\r\n        let conversionMap = new Map();\r\n        for (let i = 0; i < 26; i++) {\r\n            if (varBitSet.get(i) === 0) continue;\r\n            conversionMap.set(varLimit - varPos++, String.fromCharCode(i + 65));\r\n        }\r\n\r\n        let string = \"\";\r\n        for (let i = product.length - 1; i >= 0; i--) {\r\n            let firstVar = true;\r\n            for (let j = varLimit; j >= 0; j--) {\r\n                if (product[i].dashMask.get(j) === 0) {\r\n                    if (!firstVar) string += \"*\";\r\n                    else firstVar = false;\r\n\r\n                    if (product[i].term.get(j) === 0) string += \"~\";\r\n                    string += conversionMap.get(j);\r\n                }\r\n            }\r\n\r\n            if (i - 1 >= 0) string += \" + \";\r\n        }\r\n        return string;\r\n    },\r\n\r\n    sopToString(sop, labels) {\r\n        let str = \"\";\r\n        for (const term of sop) {\r\n            for (const product of term) {\r\n                let found = labels.find(\r\n                    (pair) =>\r\n                        pair.qmTerm.term.equals(product.term) &&\r\n                        pair.qmTerm.dashMask.equals(product.dashMask)\r\n                );\r\n                if (found !== undefined) str += found.varName;\r\n            }\r\n            str += \" + \";\r\n        }\r\n        str = str.substr(0, str.length - 3);\r\n\r\n        return str;\r\n    },\r\n};\r\n\r\nexport default PM;\r\n"]},"metadata":{},"sourceType":"module"}