{"ast":null,"code":"import _createForOfIteratorHelper from\"C:/Users/Andrew/Documents/JavaScript Projects/bool-simp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import{BOOL_GRAMMAR,BOOL_CALC_ACTIONS}from\"./BoolExpressionGrammar\";import Recognizer from\"../Earley Parser/EarleyRecognizer\";import Parser,{ParseNode}from\"../Earley Parser/EarleyParser\";import BitSet from\"bitset\";import{bnfGrammar,bnfActions,interpretBNF}from\"../Earley Parser/BNFInterpreter\";//import BoolExpression from \"./BoolExpression\";\n/*export default function boolMain(expStr) {\r\n    try {\r\n        let exp = BoolExpression.ExpressionInstance(expStr, true);\r\n\r\n        console.log(\"Expression: \", exp.toString());\r\n        console.log(\"Min Terms: \", exp.getMinTerms());\r\n        console.log(\"Var Count: \", exp.getVarCount());\r\n        console.log(\"Prime Implicants: \", exp.getPrimeImplicants());\r\n        console.log(\"Petrick SOP: \", exp.getPetrickSOP());\r\n        // Print Prime Implicants\r\n        for (const implicant of exp.getPrimeImpStrings()) {\r\n            console.log(implicant);\r\n        }\r\n\r\n        let petrickSOP = exp.getSOPStrings();\r\n        for (let i = 0; i < petrickSOP.length; i++) {\r\n            console.log(\"Solution \", i + 1, \": \", petrickSOP[i]);\r\n        }\r\n\r\n        let test = exp.getQMLog();\r\n        console.log(\"QM Log: \", test);\r\n        console.log(\"PM Log: \", exp.getPMLog());\r\n    } catch (error) {\r\n        console.log(error);\r\n    }\r\n}*/export function buildBoolGrammar(){try{var grammar=BOOL_GRAMMAR.replaceAll(\"\\\\n\",\"\\n\");var s=Recognizer.buildItems(grammar,bnfGrammar);var invertedS=Parser.invertEarleySets(s,bnfGrammar);var parseTree=Parser.buildParseTree(grammar,invertedS,bnfGrammar);if(parseTree===null){throw new Error(\"invalid grammar\");}var simplifiedTree=Parser.applySemanticAction(function(token){return new ParseNode(-1,token);},parseTree,bnfActions);return interpretBNF(simplifiedTree);}catch(error){console.log(error);return null;}}export function calculateMinTerms(parseTree,varBitSet){var varCount=varBitSet.cardinality();var minTerms=[];// array to be filled with minTerms\nvar rowCount=Math.pow(2,varCount);for(var i=rowCount-1;i>=0;i--){var normalizedVariables=BitSet(i);var boolVal=calculateExpression(parseTree,varBitSet,normalizedVariables);if(boolVal)minTerms.push(i);}return minTerms;}function calculateExpression(parseTree,varBitSet,normVars){var semanticActions=BOOL_CALC_ACTIONS.slice();var varCount=varBitSet.cardinality();var varPos=0;for(var i=0;i<26;i++){if(varBitSet.get(i)===0)continue;var bool=normVars.get(varCount-1-varPos++);if(bool){semanticActions[i+semanticActions.length-52]=function(){return true;};semanticActions[i+semanticActions.length-26]=function(){return true;};}else{semanticActions[i+semanticActions.length-52]=function(){return false;};semanticActions[i+semanticActions.length-26]=function(){return false;};}}return Parser.applySemanticAction(function(token){return token;},parseTree,semanticActions);}export function validateTerms(minTerms,dontCares){if(minTerms.length===0)return[false,-1];var _iterator=_createForOfIteratorHelper(dontCares),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var term=_step.value;if(minTerms.includes(term))return[false,term];}}catch(err){_iterator.e(err);}finally{_iterator.f();}return[true,-2];}export function getVarBitSet(expStr){var variables=new BitSet();for(var i=0;i<expStr.length;i++){if(/[A-Z]/.test(expStr[i])){variables.set(expStr.charCodeAt(i)-65,1);}}return variables;}export function mapVariable(variable,varBitSet){var setBits=varBitSet.toArray();// variable is an index\nif(variable===parseInt(variable))return String.fromCharCode(setBits[variable]+65);//variable is a character\nreturn String.fromCharCode(setBits[variable.charCodeAt(0)-65]+65);}export function deepCopy(src){var target=Array.isArray(src)?[]:{};for(var key in src){var v=src[key];if(v){if(typeof v===\"object\"){target[key]=deepCopy(v);}else{target[key]=v;}}else{target[key]=v;}}return target;}","map":{"version":3,"sources":["C:/Users/Andrew/Documents/JavaScript Projects/bool-simp/src/scripts/BooleanSimplifier/BoolExpressionUtils.js"],"names":["BOOL_GRAMMAR","BOOL_CALC_ACTIONS","Recognizer","Parser","ParseNode","BitSet","bnfGrammar","bnfActions","interpretBNF","buildBoolGrammar","grammar","replaceAll","s","buildItems","invertedS","invertEarleySets","parseTree","buildParseTree","Error","simplifiedTree","applySemanticAction","token","error","console","log","calculateMinTerms","varBitSet","varCount","cardinality","minTerms","rowCount","i","normalizedVariables","boolVal","calculateExpression","push","normVars","semanticActions","slice","varPos","get","bool","length","validateTerms","dontCares","term","includes","getVarBitSet","expStr","variables","test","set","charCodeAt","mapVariable","variable","setBits","toArray","parseInt","String","fromCharCode","deepCopy","src","target","Array","isArray","key","v"],"mappings":"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","sourcesContent":["import { BOOL_GRAMMAR, BOOL_CALC_ACTIONS } from \"./BoolExpressionGrammar\";\r\nimport Recognizer from \"../Earley Parser/EarleyRecognizer\";\r\nimport Parser, { ParseNode } from \"../Earley Parser/EarleyParser\";\r\nimport BitSet from \"bitset\";\r\nimport { bnfGrammar, bnfActions, interpretBNF } from \"../Earley Parser/BNFInterpreter\";\r\n//import BoolExpression from \"./BoolExpression\";\r\n\r\n/*export default function boolMain(expStr) {\r\n    try {\r\n        let exp = BoolExpression.ExpressionInstance(expStr, true);\r\n\r\n        console.log(\"Expression: \", exp.toString());\r\n        console.log(\"Min Terms: \", exp.getMinTerms());\r\n        console.log(\"Var Count: \", exp.getVarCount());\r\n        console.log(\"Prime Implicants: \", exp.getPrimeImplicants());\r\n        console.log(\"Petrick SOP: \", exp.getPetrickSOP());\r\n        // Print Prime Implicants\r\n        for (const implicant of exp.getPrimeImpStrings()) {\r\n            console.log(implicant);\r\n        }\r\n\r\n        let petrickSOP = exp.getSOPStrings();\r\n        for (let i = 0; i < petrickSOP.length; i++) {\r\n            console.log(\"Solution \", i + 1, \": \", petrickSOP[i]);\r\n        }\r\n\r\n        let test = exp.getQMLog();\r\n        console.log(\"QM Log: \", test);\r\n        console.log(\"PM Log: \", exp.getPMLog());\r\n    } catch (error) {\r\n        console.log(error);\r\n    }\r\n}*/\r\n\r\nexport function buildBoolGrammar() {\r\n    try {\r\n        let grammar = BOOL_GRAMMAR.replaceAll(\"\\\\n\", \"\\n\");\r\n        let s = Recognizer.buildItems(grammar, bnfGrammar);\r\n        let invertedS = Parser.invertEarleySets(s, bnfGrammar);\r\n        let parseTree = Parser.buildParseTree(grammar, invertedS, bnfGrammar);\r\n\r\n        if (parseTree === null) {\r\n            throw new Error(\"invalid grammar\");\r\n        }\r\n\r\n        let simplifiedTree = Parser.applySemanticAction(\r\n            (token) => new ParseNode(-1, token),\r\n            parseTree,\r\n            bnfActions\r\n        );\r\n\r\n        return interpretBNF(simplifiedTree);\r\n    } catch (error) {\r\n        console.log(error);\r\n        return null;\r\n    }\r\n}\r\n\r\nexport function calculateMinTerms(parseTree, varBitSet) {\r\n    let varCount = varBitSet.cardinality();\r\n    let minTerms = []; // array to be filled with minTerms\r\n    let rowCount = 2 ** varCount;\r\n\r\n    for (let i = rowCount - 1; i >= 0; i--) {\r\n        let normalizedVariables = BitSet(i);\r\n        let boolVal = calculateExpression(parseTree, varBitSet, normalizedVariables);\r\n        if (boolVal) minTerms.push(i);\r\n    }\r\n    return minTerms;\r\n}\r\n\r\nfunction calculateExpression(parseTree, varBitSet, normVars) {\r\n    let semanticActions = BOOL_CALC_ACTIONS.slice();\r\n    let varCount = varBitSet.cardinality();\r\n\r\n    let varPos = 0;\r\n    for (let i = 0; i < 26; i++) {\r\n        if (varBitSet.get(i) === 0) continue;\r\n        let bool = normVars.get(varCount - 1 - varPos++);\r\n        if (bool) {\r\n            semanticActions[i + semanticActions.length - 52] = () => true;\r\n            semanticActions[i + semanticActions.length - 26] = () => true;\r\n        } else {\r\n            semanticActions[i + semanticActions.length - 52] = () => false;\r\n            semanticActions[i + semanticActions.length - 26] = () => false;\r\n        }\r\n    }\r\n\r\n    return Parser.applySemanticAction((token) => token, parseTree, semanticActions);\r\n}\r\n\r\nexport function validateTerms(minTerms, dontCares) {\r\n    if (minTerms.length === 0) return [false, -1];\r\n    for (const term of dontCares) if (minTerms.includes(term)) return [false, term];\r\n    return [true, -2];\r\n}\r\n\r\nexport function getVarBitSet(expStr) {\r\n    let variables = new BitSet();\r\n    for (let i = 0; i < expStr.length; i++) {\r\n        if (/[A-Z]/.test(expStr[i])) {\r\n            variables.set(expStr.charCodeAt(i) - 65, 1);\r\n        }\r\n    }\r\n    return variables;\r\n}\r\n\r\nexport function mapVariable(variable, varBitSet) {\r\n    let setBits = varBitSet.toArray();\r\n\r\n    // variable is an index\r\n    if (variable === parseInt(variable))\r\n        return String.fromCharCode(setBits[variable] + 65);\r\n\r\n    //variable is a character\r\n    return String.fromCharCode(setBits[variable.charCodeAt(0) - 65] + 65);\r\n}\r\n\r\nexport function deepCopy(src) {\r\n    let target = Array.isArray(src) ? [] : {};\r\n    for (let key in src) {\r\n        let v = src[key];\r\n        if (v) {\r\n            if (typeof v === \"object\") {\r\n                target[key] = deepCopy(v);\r\n            } else {\r\n                target[key] = v;\r\n            }\r\n        } else {\r\n            target[key] = v;\r\n        }\r\n    }\r\n\r\n    return target;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}