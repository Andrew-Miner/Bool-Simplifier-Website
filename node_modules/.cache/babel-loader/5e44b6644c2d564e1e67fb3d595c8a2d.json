{"ast":null,"code":"import StructFactory from \"../StructFactory\";\nimport QM from \"./QMFunctions\";\nconst LabelPair = StructFactory(\"qmTerm varName\");\nconst PM = {\n  getPetrickSOP(primeImps, minTerms, log) {\n    let groupsMap = this.groupPrimeImplicants(primeImps, minTerms);\n    let labels = [];\n\n    if (log && primeImps.length) {\n      let count = 0;\n\n      for (const term of primeImps) {\n        labels.push(new LabelPair(term, String.fromCharCode((\"K\".charCodeAt(0) - 65 + count++) % 26 + 65)));\n      }\n\n      let str = \"\";\n\n      for (const [key, value] of groupsMap) str += this.sumToString(value, labels);\n\n      log.push(str);\n    }\n\n    let solution = this.expandGroups(groupsMap, log, labels);\n    this.removeLargerTerms(solution);\n    this.removeSmallerDashes(solution);\n\n    if (log && primeImps.length) {\n      let str = \"(\" + this.sopToString(solution, labels) + \")\";\n      if (log[log.length - 1] !== str) log.push(str);\n    }\n\n    return solution;\n  },\n\n  sumToString(sum, labels) {\n    if (sum.length === 0) return \"\";\n    let str = \"(\";\n\n    for (const term of sum) {\n      let found = labels.find(pair => pair.qmTerm.term.equals(term.term) && pair.qmTerm.dashMask.equals(term.dashMask));\n\n      if (found !== undefined) {\n        str += found.varName + \" + \";\n      }\n    }\n\n    str = str.substr(0, str.length - 3) + \")\";\n    return str;\n  },\n\n  groupPrimeImplicants(primeImps, minTerms) {\n    let groups = new Map(); // Initialize Groups\n\n    for (let i = 0; i < minTerms.length; i++) groups.set(minTerms[i], []); // Group Prime Imps (QMTerms)\n\n\n    for (let i = 0; i < primeImps.length; i++) {\n      // Calculate min terms using dash positions\n      let piMinTerms = QM.extractMinTerms(primeImps[i]);\n\n      for (let j = 0; j < piMinTerms.length; j++) {\n        // If extracted min term is not a don't care, insert it into the map\n        if (groups.has(piMinTerms[j])) groups.get(piMinTerms[j]).push(primeImps[i]);\n      }\n    }\n\n    return groups;\n  },\n\n  // returns SOP\n  expandGroups(groups, log, labels) {\n    if (!groups.size) return [];\n    let keys = Array.from(groups.keys());\n    if (keys.length === 0) return [];\n    let workingSOP = this.toSOP(groups.get(keys[0]));\n\n    for (let i = 1; i < keys.length; i++) {\n      let group = groups.get(keys[i]);\n\n      if (group.length) {\n        let nextSOP = this.toSOP(group);\n        workingSOP = this.foilSums(workingSOP, nextSOP);\n        workingSOP.sort((sop1, sop2) => sop1.length < sop2.length ? -1 : sop1.length > sop2.length ? 1 : 0);\n\n        let logSOP = sop => {\n          let logStr = \"(\" + this.sopToString(sop, labels) + \")\";\n\n          for (let j = i + 1; j < keys.length; j++) logStr += this.sumToString(groups.get(keys[j]), labels);\n\n          log.push(logStr);\n        };\n\n        if (log) logSOP(workingSOP);\n        workingSOP = this.simplifySOP(workingSOP);\n        if (log) logSOP(workingSOP);\n      }\n    }\n\n    return workingSOP;\n  },\n\n  // returns SOP\n  oldExpandGroups(groups, log, labels) {\n    if (!groups.size) return [];\n    let workingSOP;\n\n    for (let value of groups) {\n      if (workingSOP === undefined) {\n        workingSOP = this.toSOP(value);\n        continue;\n      }\n\n      if (value.length) {\n        let nextSOP = this.toSOP(value);\n        workingSOP = this.foilSums(workingSOP, nextSOP);\n        workingSOP.sort((sop1, sop2) => sop1.length > sop2.length && 1 || -1);\n        workingSOP = this.simplifySOP(workingSOP);\n      }\n    }\n\n    return workingSOP;\n  },\n\n  toSOP(sum) {\n    let result = [];\n\n    for (let i = 0; i < sum.length; i++) {\n      result.push([sum[i]]);\n    }\n\n    return result;\n  },\n\n  removeLargerTerms(expression) {\n    if (expression.length === 0) return; // Find smallest term size and remove those larger\n\n    let smallest = expression[0].length;\n\n    for (let i = 1; i < expression.length;) {\n      if (expression[i].length > smallest) expression.splice(i, 1);else {\n        if (expression[i].length < smallest) smallest = expression[i].length;\n        i++;\n      }\n    } // Iterate one more time to remove remaining large terms\n\n\n    for (let i = 0; i < expression.length;) {\n      if (expression[i].length > smallest) expression.splice(i, 1);else i++;\n    }\n  },\n\n  removeSmallerDashes(expression) {\n    if (expression.length === 0) return; // Find largest dash count and remove those smaller\n\n    let largestDash = 0;\n\n    for (let i = 0; i < expression.length;) {\n      let dashCount = 0;\n\n      for (let j = 0; j < expression[i].length; j++) dashCount += expression[i][j].dashMask.cardinality();\n\n      if (dashCount < largestDash) expression.splice(i, 1);else {\n        largestDash = dashCount;\n        i++;\n      }\n    } // Iterate one more time to remove remaning small (larger) terms\n\n\n    for (let i = 0; i < expression.length;) {\n      let dashCount = 0;\n\n      for (let j = 0; j < expression[i].length; j++) dashCount += expression[i][j].dashMask.cardinality();\n\n      if (dashCount < largestDash) expression.splice(i, 1);else i++;\n    }\n  },\n\n  foilSums(firstSum, secondSum) {\n    let result = [];\n\n    for (let i = 0; i < firstSum.length; i++) {\n      for (let j = 0; j < secondSum.length; j++) {\n        for (let k = 0; k < secondSum[j].length; k++) {\n          let product = firstSum[i].slice();\n          let findVar = product.find(element => element === secondSum[j][k]);\n          if (findVar === undefined) product.push(secondSum[j][k]);\n          result.push(product);\n        }\n      }\n    }\n\n    return result;\n  },\n\n  // Precondition: SOP is sorted by var count per term\n  simplifySOP(sop) {\n    let simplified = sop.slice();\n\n    for (let i = 0; i < simplified.length; i++) {\n      for (let j = i + 1; j < simplified.length;) {\n        if (this.isProductSubset(simplified[i], simplified[j])) simplified.splice(j, 1);else j++;\n      }\n    }\n\n    return simplified;\n  },\n\n  lessThanQMArray(array1, array2) {},\n\n  isQMArrayEqual(array1, array2) {},\n\n  isProductUnique(sop, product) {},\n\n  isProductSubset(subset, superset) {\n    if (subset.length > superset.length) return false;\n\n    for (let i = 0; i < subset.length; i++) {\n      if (superset.find(element => {\n        return element.term.equals(subset[i].term) && element.dashMask.equals(subset[i].dashMask);\n      }) === undefined) return false;\n    }\n\n    return true;\n  },\n\n  productToString(product, varCount) {\n    let varLimit = varCount === 0 ? 25 : varCount - 1; // Edge case for contradictions\n\n    if (product.length === 0) return \"0\"; // Edge case for tautologies\n\n    if (product.length === 1 && product[0].term.cardinality() === 0 && product[0].dashMask.cardinality() === varCount + 1) return \"1\";\n    let string = \"\";\n\n    for (let i = product.length - 1; i >= 0; i--) {\n      let firstVar = true;\n\n      for (let j = varLimit; j >= 0; j--) {\n        if (product[i].dashMask.get(j) === 0) {\n          if (!firstVar) string += \"*\";else firstVar = false;\n          if (product[i].term.get(j) === 0) string += \"~\";\n          string += String.fromCharCode(65 + (varLimit - j));\n        }\n      }\n\n      if (i - 1 >= 0) string += \" + \";\n    }\n\n    return string;\n  },\n\n  mapProductToString(product, varBitSet) {\n    // Edge case for contradictions\n    if (product.length === 0) return \"0\"; // Edge case for tautologies\n\n    if (product.length === 1 && product[0].term.cardinality() === 0 && product[0].dashMask.cardinality() === varBitSet.cardinality()) return \"1\";\n    let varLimit = varBitSet.cardinality() - 1;\n    let varPos = 0;\n    let conversionMap = new Map();\n\n    for (let i = 0; i < 26; i++) {\n      if (varBitSet.get(i) === 0) continue;\n      conversionMap.set(varLimit - varPos++, String.fromCharCode(i + 65));\n    }\n\n    let string = \"\";\n\n    for (let i = product.length - 1; i >= 0; i--) {\n      let firstVar = true;\n\n      for (let j = varLimit; j >= 0; j--) {\n        if (product[i].dashMask.get(j) === 0) {\n          if (!firstVar) string += \"*\";else firstVar = false;\n          if (product[i].term.get(j) === 0) string += \"~\";\n          string += conversionMap.get(j);\n        }\n      }\n\n      if (i - 1 >= 0) string += \" + \";\n    }\n\n    return string;\n  },\n\n  sopToString(sop, labels) {\n    let str = \"\";\n\n    for (const term of sop) {\n      for (const product of term) {\n        let found = labels.find(pair => pair.qmTerm.term.equals(product.term) && pair.qmTerm.dashMask.equals(product.dashMask));\n        if (found !== undefined) str += found.varName;\n      }\n\n      str += \" + \";\n    }\n\n    str = str.substr(0, str.length - 3);\n    return str;\n  }\n\n};\nexport default PM;","map":{"version":3,"sources":["C:/Users/Andrew/Documents/JavaScript Projects/bool-simp/src/scripts/BooleanSimplifier/PMFunctions.js"],"names":["StructFactory","QM","LabelPair","PM","getPetrickSOP","primeImps","minTerms","log","groupsMap","groupPrimeImplicants","labels","length","count","term","push","String","fromCharCode","charCodeAt","str","key","value","sumToString","solution","expandGroups","removeLargerTerms","removeSmallerDashes","sopToString","sum","found","find","pair","qmTerm","equals","dashMask","undefined","varName","substr","groups","Map","i","set","piMinTerms","extractMinTerms","j","has","get","size","keys","Array","from","workingSOP","toSOP","group","nextSOP","foilSums","sort","sop1","sop2","logSOP","sop","logStr","simplifySOP","oldExpandGroups","result","expression","smallest","splice","largestDash","dashCount","cardinality","firstSum","secondSum","k","product","slice","findVar","element","simplified","isProductSubset","lessThanQMArray","array1","array2","isQMArrayEqual","isProductUnique","subset","superset","productToString","varCount","varLimit","string","firstVar","mapProductToString","varBitSet","varPos","conversionMap"],"mappings":"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","sourcesContent":["import StructFactory from \"../StructFactory\";\r\nimport QM from \"./QMFunctions\";\r\n\r\nconst LabelPair = StructFactory(\"qmTerm varName\");\r\n\r\nconst PM = {\r\n    getPetrickSOP(primeImps, minTerms, log) {\r\n        let groupsMap = this.groupPrimeImplicants(primeImps, minTerms);\r\n\r\n        let labels = [];\r\n        if (log && primeImps.length) {\r\n            let count = 0;\r\n            for (const term of primeImps) {\r\n                labels.push(\r\n                    new LabelPair(\r\n                        term,\r\n                        String.fromCharCode(\r\n                            ((\"K\".charCodeAt(0) - 65 + count++) % 26) + 65\r\n                        )\r\n                    )\r\n                );\r\n            }\r\n\r\n            let str = \"\";\r\n            for (const [key, value] of groupsMap) str += this.sumToString(value, labels);\r\n            log.push(str);\r\n        }\r\n\r\n        let solution = this.expandGroups(groupsMap, log, labels);\r\n        this.removeLargerTerms(solution);\r\n        this.removeSmallerDashes(solution);\r\n\r\n        if (log && primeImps.length) {\r\n            let str = \"(\" + this.sopToString(solution, labels) + \")\";\r\n            if (log[log.length - 1] !== str) log.push(str);\r\n        }\r\n\r\n        return solution;\r\n    },\r\n\r\n    sumToString(sum, labels) {\r\n        if (sum.length === 0) return \"\";\r\n\r\n        let str = \"(\";\r\n        for (const term of sum) {\r\n            let found = labels.find(\r\n                (pair) =>\r\n                    pair.qmTerm.term.equals(term.term) &&\r\n                    pair.qmTerm.dashMask.equals(term.dashMask)\r\n            );\r\n            if (found !== undefined) {\r\n                str += found.varName + \" + \";\r\n            }\r\n        }\r\n        str = str.substr(0, str.length - 3) + \")\";\r\n        return str;\r\n    },\r\n\r\n    groupPrimeImplicants(primeImps, minTerms) {\r\n        let groups = new Map();\r\n\r\n        // Initialize Groups\r\n        for (let i = 0; i < minTerms.length; i++) groups.set(minTerms[i], []);\r\n\r\n        // Group Prime Imps (QMTerms)\r\n        for (let i = 0; i < primeImps.length; i++) {\r\n            // Calculate min terms using dash positions\r\n            let piMinTerms = QM.extractMinTerms(primeImps[i]);\r\n\r\n            for (let j = 0; j < piMinTerms.length; j++) {\r\n                // If extracted min term is not a don't care, insert it into the map\r\n                if (groups.has(piMinTerms[j]))\r\n                    groups.get(piMinTerms[j]).push(primeImps[i]);\r\n            }\r\n        }\r\n\r\n        return groups;\r\n    },\r\n\r\n    // returns SOP\r\n    expandGroups(groups, log, labels) {\r\n        if (!groups.size) return [];\r\n\r\n        let keys = Array.from(groups.keys());\r\n        if (keys.length === 0) return [];\r\n\r\n        let workingSOP = this.toSOP(groups.get(keys[0]));\r\n        for (let i = 1; i < keys.length; i++) {\r\n            let group = groups.get(keys[i]);\r\n            if (group.length) {\r\n                let nextSOP = this.toSOP(group);\r\n                workingSOP = this.foilSums(workingSOP, nextSOP);\r\n\r\n                workingSOP.sort((sop1, sop2) =>\r\n                    sop1.length < sop2.length ? -1 : sop1.length > sop2.length ? 1 : 0\r\n                );\r\n\r\n                let logSOP = (sop) => {\r\n                    let logStr = \"(\" + this.sopToString(sop, labels) + \")\";\r\n                    for (let j = i + 1; j < keys.length; j++)\r\n                        logStr += this.sumToString(groups.get(keys[j]), labels);\r\n                    log.push(logStr);\r\n                };\r\n\r\n                if (log) logSOP(workingSOP);\r\n                workingSOP = this.simplifySOP(workingSOP);\r\n                if (log) logSOP(workingSOP);\r\n            }\r\n        }\r\n\r\n        return workingSOP;\r\n    },\r\n\r\n    // returns SOP\r\n    oldExpandGroups(groups, log, labels) {\r\n        if (!groups.size) return [];\r\n\r\n        let workingSOP;\r\n        for (let value of groups) {\r\n            if (workingSOP === undefined) {\r\n                workingSOP = this.toSOP(value);\r\n                continue;\r\n            }\r\n\r\n            if (value.length) {\r\n                let nextSOP = this.toSOP(value);\r\n                workingSOP = this.foilSums(workingSOP, nextSOP);\r\n\r\n                workingSOP.sort((sop1, sop2) => (sop1.length > sop2.length && 1) || -1);\r\n                workingSOP = this.simplifySOP(workingSOP);\r\n            }\r\n        }\r\n\r\n        return workingSOP;\r\n    },\r\n\r\n    toSOP(sum) {\r\n        let result = [];\r\n\r\n        for (let i = 0; i < sum.length; i++) {\r\n            result.push([sum[i]]);\r\n        }\r\n\r\n        return result;\r\n    },\r\n\r\n    removeLargerTerms(expression) {\r\n        if (expression.length === 0) return;\r\n\r\n        // Find smallest term size and remove those larger\r\n        let smallest = expression[0].length;\r\n\r\n        for (let i = 1; i < expression.length; ) {\r\n            if (expression[i].length > smallest) expression.splice(i, 1);\r\n            else {\r\n                if (expression[i].length < smallest) smallest = expression[i].length;\r\n                i++;\r\n            }\r\n        }\r\n\r\n        // Iterate one more time to remove remaining large terms\r\n        for (let i = 0; i < expression.length; ) {\r\n            if (expression[i].length > smallest) expression.splice(i, 1);\r\n            else i++;\r\n        }\r\n    },\r\n\r\n    removeSmallerDashes(expression) {\r\n        if (expression.length === 0) return;\r\n\r\n        // Find largest dash count and remove those smaller\r\n        let largestDash = 0;\r\n        for (let i = 0; i < expression.length; ) {\r\n            let dashCount = 0;\r\n            for (let j = 0; j < expression[i].length; j++)\r\n                dashCount += expression[i][j].dashMask.cardinality();\r\n\r\n            if (dashCount < largestDash) expression.splice(i, 1);\r\n            else {\r\n                largestDash = dashCount;\r\n                i++;\r\n            }\r\n        }\r\n\r\n        // Iterate one more time to remove remaning small (larger) terms\r\n        for (let i = 0; i < expression.length; ) {\r\n            let dashCount = 0;\r\n            for (let j = 0; j < expression[i].length; j++)\r\n                dashCount += expression[i][j].dashMask.cardinality();\r\n\r\n            if (dashCount < largestDash) expression.splice(i, 1);\r\n            else i++;\r\n        }\r\n    },\r\n\r\n    foilSums(firstSum, secondSum) {\r\n        let result = [];\r\n        for (let i = 0; i < firstSum.length; i++) {\r\n            for (let j = 0; j < secondSum.length; j++) {\r\n                for (let k = 0; k < secondSum[j].length; k++) {\r\n                    let product = firstSum[i].slice();\r\n                    let findVar = product.find((element) => element === secondSum[j][k]);\r\n                    if (findVar === undefined) product.push(secondSum[j][k]);\r\n                    result.push(product);\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    },\r\n\r\n    // Precondition: SOP is sorted by var count per term\r\n    simplifySOP(sop) {\r\n        let simplified = sop.slice();\r\n        for (let i = 0; i < simplified.length; i++) {\r\n            for (let j = i + 1; j < simplified.length; ) {\r\n                if (this.isProductSubset(simplified[i], simplified[j]))\r\n                    simplified.splice(j, 1);\r\n                else j++;\r\n            }\r\n        }\r\n        return simplified;\r\n    },\r\n\r\n    lessThanQMArray(array1, array2) {},\r\n    isQMArrayEqual(array1, array2) {},\r\n    isProductUnique(sop, product) {},\r\n    isProductSubset(subset, superset) {\r\n        if (subset.length > superset.length) return false;\r\n\r\n        for (let i = 0; i < subset.length; i++) {\r\n            if (\r\n                superset.find((element) => {\r\n                    return (\r\n                        element.term.equals(subset[i].term) &&\r\n                        element.dashMask.equals(subset[i].dashMask)\r\n                    );\r\n                }) === undefined\r\n            )\r\n                return false;\r\n        }\r\n\r\n        return true;\r\n    },\r\n\r\n    productToString(product, varCount) {\r\n        let varLimit = varCount === 0 ? 25 : varCount - 1;\r\n\r\n        // Edge case for contradictions\r\n        if (product.length === 0) return \"0\";\r\n\r\n        // Edge case for tautologies\r\n        if (\r\n            product.length === 1 &&\r\n            product[0].term.cardinality() === 0 &&\r\n            product[0].dashMask.cardinality() === varCount + 1\r\n        )\r\n            return \"1\";\r\n\r\n        let string = \"\";\r\n        for (let i = product.length - 1; i >= 0; i--) {\r\n            let firstVar = true;\r\n            for (let j = varLimit; j >= 0; j--) {\r\n                if (product[i].dashMask.get(j) === 0) {\r\n                    if (!firstVar) string += \"*\";\r\n                    else firstVar = false;\r\n\r\n                    if (product[i].term.get(j) === 0) string += \"~\";\r\n                    string += String.fromCharCode(65 + (varLimit - j));\r\n                }\r\n            }\r\n\r\n            if (i - 1 >= 0) string += \" + \";\r\n        }\r\n        return string;\r\n    },\r\n\r\n    mapProductToString(product, varBitSet) {\r\n        // Edge case for contradictions\r\n        if (product.length === 0) return \"0\";\r\n\r\n        // Edge case for tautologies\r\n        if (\r\n            product.length === 1 &&\r\n            product[0].term.cardinality() === 0 &&\r\n            product[0].dashMask.cardinality() === varBitSet.cardinality()\r\n        )\r\n            return \"1\";\r\n\r\n        let varLimit = varBitSet.cardinality() - 1;\r\n        let varPos = 0;\r\n        let conversionMap = new Map();\r\n        for (let i = 0; i < 26; i++) {\r\n            if (varBitSet.get(i) === 0) continue;\r\n            conversionMap.set(varLimit - varPos++, String.fromCharCode(i + 65));\r\n        }\r\n\r\n        let string = \"\";\r\n        for (let i = product.length - 1; i >= 0; i--) {\r\n            let firstVar = true;\r\n            for (let j = varLimit; j >= 0; j--) {\r\n                if (product[i].dashMask.get(j) === 0) {\r\n                    if (!firstVar) string += \"*\";\r\n                    else firstVar = false;\r\n\r\n                    if (product[i].term.get(j) === 0) string += \"~\";\r\n                    string += conversionMap.get(j);\r\n                }\r\n            }\r\n\r\n            if (i - 1 >= 0) string += \" + \";\r\n        }\r\n        return string;\r\n    },\r\n\r\n    sopToString(sop, labels) {\r\n        let str = \"\";\r\n        for (const term of sop) {\r\n            for (const product of term) {\r\n                let found = labels.find(\r\n                    (pair) =>\r\n                        pair.qmTerm.term.equals(product.term) &&\r\n                        pair.qmTerm.dashMask.equals(product.dashMask)\r\n                );\r\n                if (found !== undefined) str += found.varName;\r\n            }\r\n            str += \" + \";\r\n        }\r\n        str = str.substr(0, str.length - 3);\r\n\r\n        return str;\r\n    },\r\n};\r\n\r\nexport default PM;\r\n"]},"metadata":{},"sourceType":"module"}