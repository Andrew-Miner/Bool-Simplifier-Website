{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.classMethodOrDeclareMethodCommon = exports.classMethodOrPropertyCommon = exports.patternLikeCommon = exports.functionDeclarationCommon = exports.functionTypeAnnotationCommon = exports.functionCommon = void 0;\n\nvar _is = require(\"../validators/is\");\n\nvar _isValidIdentifier = require(\"../validators/isValidIdentifier\");\n\nvar _helperValidatorIdentifier = require(\"@babel/helper-validator-identifier\");\n\nvar _constants = require(\"../constants\");\n\nvar _utils = require(\"./utils\");\n\n(0, _utils.default)(\"ArrayExpression\", {\n  fields: {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)(\"null\", \"Expression\", \"SpreadElement\"))),\n      default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined\n    }\n  },\n  visitor: [\"elements\"],\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"AssignmentExpression\", {\n  fields: {\n    operator: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertValueType)(\"string\");\n        }\n\n        const identifier = (0, _utils.assertOneOf)(..._constants.ASSIGNMENT_OPERATORS);\n        const pattern = (0, _utils.assertOneOf)(\"=\");\n        return function (node, key, val) {\n          const validator = (0, _is.default)(\"Pattern\", node.left) ? pattern : identifier;\n          validator(node, key, val);\n        };\n      }()\n    },\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"BinaryExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.BINARY_OPERATORS)\n    },\n    left: {\n      validate: function () {\n        const expression = (0, _utils.assertNodeType)(\"Expression\");\n        const inOp = (0, _utils.assertNodeType)(\"Expression\", \"PrivateName\");\n\n        const validator = function (node, key, val) {\n          const validator = node.operator === \"in\" ? inOp : expression;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"PrivateName\"];\n        return validator;\n      }()\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"]\n});\n(0, _utils.default)(\"InterpreterDirective\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\n(0, _utils.default)(\"Directive\", {\n  visitor: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertNodeType)(\"DirectiveLiteral\")\n    }\n  }\n});\n(0, _utils.default)(\"DirectiveLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\n(0, _utils.default)(\"BlockStatement\", {\n  builder: [\"body\", \"directives\"],\n  visitor: [\"directives\", \"body\"],\n  fields: {\n    directives: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Directive\"))),\n      default: []\n    },\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\", \"Statement\"]\n});\n(0, _utils.default)(\"BreakStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\n(0, _utils.default)(\"CallExpression\", {\n  visitor: [\"callee\", \"arguments\", \"typeParameters\", \"typeArguments\"],\n  builder: [\"callee\", \"arguments\"],\n  aliases: [\"Expression\"],\n  fields: Object.assign({\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"V8IntrinsicIdentifier\")\n    },\n    arguments: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"SpreadElement\", \"JSXNamespacedName\", \"ArgumentPlaceholder\")))\n    }\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertOneOf)(true, false),\n      optional: true\n    }\n  } : {}, {\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  })\n});\n(0, _utils.default)(\"CatchClause\", {\n  visitor: [\"param\", \"body\"],\n  fields: {\n    param: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\"]\n});\n(0, _utils.default)(\"ConditionalExpression\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    alternate: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Expression\", \"Conditional\"]\n});\n(0, _utils.default)(\"ContinueStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\n(0, _utils.default)(\"DebuggerStatement\", {\n  aliases: [\"Statement\"]\n});\n(0, _utils.default)(\"DoWhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  },\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"]\n});\n(0, _utils.default)(\"EmptyStatement\", {\n  aliases: [\"Statement\"]\n});\n(0, _utils.default)(\"ExpressionStatement\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Statement\", \"ExpressionWrapper\"]\n});\n(0, _utils.default)(\"File\", {\n  builder: [\"program\", \"comments\", \"tokens\"],\n  visitor: [\"program\"],\n  fields: {\n    program: {\n      validate: (0, _utils.assertNodeType)(\"Program\")\n    },\n    comments: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => {}, {\n        each: {\n          oneOfNodeTypes: [\"CommentBlock\", \"CommentLine\"]\n        }\n      }) : (0, _utils.assertEach)((0, _utils.assertNodeType)(\"CommentBlock\", \"CommentLine\")),\n      optional: true\n    },\n    tokens: {\n      validate: (0, _utils.assertEach)(Object.assign(() => {}, {\n        type: \"any\"\n      })),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"ForInStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\") : (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"ForStatement\", {\n  visitor: [\"init\", \"test\", \"update\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\"],\n  fields: {\n    init: {\n      validate: (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Expression\"),\n      optional: true\n    },\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    update: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\nconst functionCommon = {\n  params: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"RestElement\")))\n  },\n  generator: {\n    default: false\n  },\n  async: {\n    default: false\n  }\n};\nexports.functionCommon = functionCommon;\nconst functionTypeAnnotationCommon = {\n  returnType: {\n    validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  typeParameters: {\n    validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n    optional: true\n  }\n};\nexports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;\nconst functionDeclarationCommon = Object.assign({}, functionCommon, {\n  declare: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  id: {\n    validate: (0, _utils.assertNodeType)(\"Identifier\"),\n    optional: true\n  }\n});\nexports.functionDeclarationCommon = functionDeclarationCommon;\n(0, _utils.default)(\"FunctionDeclaration\", {\n  builder: [\"id\", \"params\", \"body\", \"generator\", \"async\"],\n  visitor: [\"id\", \"params\", \"body\", \"returnType\", \"typeParameters\"],\n  fields: Object.assign({}, functionDeclarationCommon, functionTypeAnnotationCommon, {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }),\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Statement\", \"Pureish\", \"Declaration\"],\n  validate: function () {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return () => {};\n    const identifier = (0, _utils.assertNodeType)(\"Identifier\");\n    return function (parent, key, node) {\n      if (!(0, _is.default)(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  }()\n});\n(0, _utils.default)(\"FunctionExpression\", {\n  inherits: \"FunctionDeclaration\",\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n});\nconst patternLikeCommon = {\n  typeAnnotation: {\n    validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\")))\n  }\n};\nexports.patternLikeCommon = patternLikeCommon;\n(0, _utils.default)(\"Identifier\", {\n  builder: [\"name\"],\n  visitor: [\"typeAnnotation\", \"decorators\"],\n  aliases: [\"Expression\", \"PatternLike\", \"LVal\", \"TSEntityName\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    name: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (!(0, _isValidIdentifier.default)(val, false)) {\n          throw new TypeError(`\"${val}\" is not a valid identifier name`);\n        }\n      }, {\n        type: \"string\"\n      }))\n    },\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  }),\n\n  validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    const match = /\\.(\\w+)$/.exec(key);\n    if (!match) return;\n    const [, parentKey] = match;\n    const nonComp = {\n      computed: false\n    };\n\n    if (parentKey === \"property\") {\n      if ((0, _is.default)(\"MemberExpression\", parent, nonComp)) return;\n      if ((0, _is.default)(\"OptionalMemberExpression\", parent, nonComp)) return;\n    } else if (parentKey === \"key\") {\n      if ((0, _is.default)(\"Property\", parent, nonComp)) return;\n      if ((0, _is.default)(\"Method\", parent, nonComp)) return;\n    } else if (parentKey === \"exported\") {\n      if ((0, _is.default)(\"ExportSpecifier\", parent)) return;\n    } else if (parentKey === \"imported\") {\n      if ((0, _is.default)(\"ImportSpecifier\", parent, {\n        imported: node\n      })) return;\n    } else if (parentKey === \"meta\") {\n      if ((0, _is.default)(\"MetaProperty\", parent, {\n        meta: node\n      })) return;\n    }\n\n    if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) && node.name !== \"this\") {\n      throw new TypeError(`\"${node.name}\" is not a valid identifier`);\n    }\n  }\n\n});\n(0, _utils.default)(\"IfStatement\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  aliases: [\"Statement\", \"Conditional\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    },\n    alternate: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"LabeledStatement\", {\n  visitor: [\"label\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"StringLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"NumericLiteral\", {\n  builder: [\"value\"],\n  deprecatedAlias: \"NumberLiteral\",\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"number\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"NullLiteral\", {\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"BooleanLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"RegExpLiteral\", {\n  builder: [\"pattern\", \"flags\"],\n  deprecatedAlias: \"RegexLiteral\",\n  aliases: [\"Expression\", \"Pureish\", \"Literal\"],\n  fields: {\n    pattern: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    flags: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        const invalid = /[^gimsuy]/.exec(val);\n\n        if (invalid) {\n          throw new TypeError(`\"${invalid[0]}\" is not a valid RegExp flag`);\n        }\n      }, {\n        type: \"string\"\n      })),\n      default: \"\"\n    }\n  }\n});\n(0, _utils.default)(\"LogicalExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.LOGICAL_OPERATORS)\n    },\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"MemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", ...(!process.env.BABEL_TYPES_8_BREAKING ? [\"optional\"] : [])],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\", \"LVal\"],\n  fields: Object.assign({\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    property: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"PrivateName\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"PrivateName\"];\n        return validator;\n      }()\n    },\n    computed: {\n      default: false\n    }\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertOneOf)(true, false),\n      optional: true\n    }\n  } : {})\n});\n(0, _utils.default)(\"NewExpression\", {\n  inherits: \"CallExpression\"\n});\n(0, _utils.default)(\"Program\", {\n  visitor: [\"directives\", \"body\"],\n  builder: [\"body\", \"directives\", \"sourceType\", \"interpreter\"],\n  fields: {\n    sourceFile: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    sourceType: {\n      validate: (0, _utils.assertOneOf)(\"script\", \"module\"),\n      default: \"script\"\n    },\n    interpreter: {\n      validate: (0, _utils.assertNodeType)(\"InterpreterDirective\"),\n      default: null,\n      optional: true\n    },\n    directives: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Directive\"))),\n      default: []\n    },\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\"]\n});\n(0, _utils.default)(\"ObjectExpression\", {\n  visitor: [\"properties\"],\n  aliases: [\"Expression\"],\n  fields: {\n    properties: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ObjectMethod\", \"ObjectProperty\", \"SpreadElement\")))\n    }\n  }\n});\n(0, _utils.default)(\"ObjectMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"generator\", \"async\"],\n  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {\n    kind: Object.assign({\n      validate: (0, _utils.assertOneOf)(\"method\", \"get\", \"set\")\n    }, !process.env.BABEL_TYPES_8_BREAKING ? {\n      default: \"method\"\n    } : {}),\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"StringLiteral\", \"NumericLiteral\"];\n        return validator;\n      }()\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }),\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  aliases: [\"UserWhitespacable\", \"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\", \"ObjectMember\"]\n});\n(0, _utils.default)(\"ObjectProperty\", {\n  builder: [\"key\", \"value\", \"computed\", \"shorthand\", ...(!process.env.BABEL_TYPES_8_BREAKING ? [\"decorators\"] : [])],\n  fields: {\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"StringLiteral\", \"NumericLiteral\"];\n        return validator;\n      }()\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"PatternLike\")\n    },\n    shorthand: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.computed) {\n          throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if computed is true\");\n        }\n      }, {\n        type: \"boolean\"\n      }), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && !(0, _is.default)(\"Identifier\", node.key)) {\n          throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if key is not an Identifier\");\n        }\n      }),\n      default: false\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  },\n  visitor: [\"key\", \"value\", \"decorators\"],\n  aliases: [\"UserWhitespacable\", \"Property\", \"ObjectMember\"],\n  validate: function () {\n    const pattern = (0, _utils.assertNodeType)(\"Identifier\", \"Pattern\");\n    const expression = (0, _utils.assertNodeType)(\"Expression\");\n    return function (parent, key, node) {\n      if (!process.env.BABEL_TYPES_8_BREAKING) return;\n      const validator = (0, _is.default)(\"ObjectPattern\", parent) ? pattern : expression;\n      validator(node, \"value\", node.value);\n    };\n  }()\n});\n(0, _utils.default)(\"RestElement\", {\n  visitor: [\"argument\", \"typeAnnotation\"],\n  builder: [\"argument\"],\n  aliases: [\"LVal\", \"PatternLike\"],\n  deprecatedAlias: \"RestProperty\",\n  fields: Object.assign({}, patternLikeCommon, {\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\") : (0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"MemberExpression\")\n    }\n  }),\n\n  validate(parent, key) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    const match = /(\\w+)\\[(\\d+)\\]/.exec(key);\n    if (!match) throw new Error(\"Internal Babel error: malformed key.\");\n    const [, listKey, index] = match;\n\n    if (parent[listKey].length > index + 1) {\n      throw new TypeError(`RestElement must be last element of ${listKey}`);\n    }\n  }\n\n});\n(0, _utils.default)(\"ReturnStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"SequenceExpression\", {\n  visitor: [\"expressions\"],\n  fields: {\n    expressions: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\")))\n    }\n  },\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"ParenthesizedExpression\", {\n  visitor: [\"expression\"],\n  aliases: [\"Expression\", \"ExpressionWrapper\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"SwitchCase\", {\n  visitor: [\"test\", \"consequent\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    consequent: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  }\n});\n(0, _utils.default)(\"SwitchStatement\", {\n  visitor: [\"discriminant\", \"cases\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Scopable\"],\n  fields: {\n    discriminant: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    cases: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"SwitchCase\")))\n    }\n  }\n});\n(0, _utils.default)(\"ThisExpression\", {\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"ThrowStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"TryStatement\", {\n  visitor: [\"block\", \"handler\", \"finalizer\"],\n  aliases: [\"Statement\"],\n  fields: {\n    block: {\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"BlockStatement\"), Object.assign(function (node) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (!node.handler && !node.finalizer) {\n          throw new TypeError(\"TryStatement expects either a handler or finalizer, or both\");\n        }\n      }, {\n        oneOfNodeTypes: [\"BlockStatement\"]\n      }))\n    },\n    handler: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"CatchClause\")\n    },\n    finalizer: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }\n});\n(0, _utils.default)(\"UnaryExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: true\n    },\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.UNARY_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\", \"Expression\"]\n});\n(0, _utils.default)(\"UpdateExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: false\n    },\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"Expression\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.UPDATE_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"VariableDeclaration\", {\n  builder: [\"kind\", \"declarations\"],\n  visitor: [\"declarations\"],\n  aliases: [\"Statement\", \"Declaration\"],\n  fields: {\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    kind: {\n      validate: (0, _utils.assertOneOf)(\"var\", \"let\", \"const\")\n    },\n    declarations: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"VariableDeclarator\")))\n    }\n  },\n\n  validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    if (!(0, _is.default)(\"ForXStatement\", parent, {\n      left: node\n    })) return;\n\n    if (node.declarations.length !== 1) {\n      throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);\n    }\n  }\n\n});\n(0, _utils.default)(\"VariableDeclarator\", {\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertNodeType)(\"LVal\");\n        }\n\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\");\n        const without = (0, _utils.assertNodeType)(\"Identifier\");\n        return function (node, key, val) {\n          const validator = node.init ? normal : without;\n          validator(node, key, val);\n        };\n      }()\n    },\n    definite: {\n      optional: true,\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    init: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"WhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"WithStatement\", {\n  visitor: [\"object\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"AssignmentPattern\", {\n  visitor: [\"left\", \"right\", \"decorators\"],\n  builder: [\"left\", \"right\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"ObjectPattern\", \"ArrayPattern\", \"MemberExpression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  })\n});\n(0, _utils.default)(\"ArrayPattern\", {\n  visitor: [\"elements\", \"typeAnnotation\"],\n  builder: [\"elements\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)(\"null\", \"PatternLike\")))\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  })\n});\n(0, _utils.default)(\"ArrowFunctionExpression\", {\n  builder: [\"params\", \"body\", \"async\"],\n  visitor: [\"params\", \"body\", \"returnType\", \"typeParameters\"],\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {\n    expression: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\", \"Expression\")\n    }\n  })\n});\n(0, _utils.default)(\"ClassBody\", {\n  visitor: [\"body\"],\n  fields: {\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ClassMethod\", \"ClassPrivateMethod\", \"ClassProperty\", \"ClassPrivateProperty\", \"TSDeclareMethod\", \"TSIndexSignature\")))\n    }\n  }\n});\n(0, _utils.default)(\"ClassExpression\", {\n  builder: [\"id\", \"superClass\", \"body\", \"decorators\"],\n  visitor: [\"id\", \"body\", \"superClass\", \"mixins\", \"typeParameters\", \"superTypeParameters\", \"implements\", \"decorators\"],\n  aliases: [\"Scopable\", \"Class\", \"Expression\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"ClassBody\")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    superTypeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    },\n    implements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSExpressionWithTypeArguments\", \"ClassImplements\"))),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    mixins: {\n      validate: (0, _utils.assertNodeType)(\"InterfaceExtends\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"ClassDeclaration\", {\n  inherits: \"ClassExpression\",\n  aliases: [\"Scopable\", \"Class\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"ClassBody\")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    superTypeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    },\n    implements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSExpressionWithTypeArguments\", \"ClassImplements\"))),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    mixins: {\n      validate: (0, _utils.assertNodeType)(\"InterfaceExtends\"),\n      optional: true\n    },\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    abstract: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  },\n  validate: function () {\n    const identifier = (0, _utils.assertNodeType)(\"Identifier\");\n    return function (parent, key, node) {\n      if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n      if (!(0, _is.default)(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  }()\n});\n(0, _utils.default)(\"ExportAllDeclaration\", {\n  visitor: [\"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"type\", \"value\")),\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    }\n  }\n});\n(0, _utils.default)(\"ExportDefaultDeclaration\", {\n  visitor: [\"declaration\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    declaration: {\n      validate: (0, _utils.assertNodeType)(\"FunctionDeclaration\", \"TSDeclareFunction\", \"ClassDeclaration\", \"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"ExportNamedDeclaration\", {\n  visitor: [\"declaration\", \"specifiers\", \"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    declaration: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"Declaration\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.specifiers.length) {\n          throw new TypeError(\"Only declaration or specifiers is allowed on ExportNamedDeclaration\");\n        }\n      }, {\n        oneOfNodeTypes: [\"Declaration\"]\n      }), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.source) {\n          throw new TypeError(\"Cannot export a declaration from a source\");\n        }\n      })\n    },\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    },\n    specifiers: {\n      default: [],\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)(function () {\n        const sourced = (0, _utils.assertNodeType)(\"ExportSpecifier\", \"ExportDefaultSpecifier\", \"ExportNamespaceSpecifier\");\n        const sourceless = (0, _utils.assertNodeType)(\"ExportSpecifier\");\n        if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;\n        return function (node, key, val) {\n          const validator = node.source ? sourced : sourceless;\n          validator(node, key, val);\n        };\n      }()))\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\"),\n      optional: true\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"type\", \"value\"))\n  }\n});\n(0, _utils.default)(\"ExportSpecifier\", {\n  visitor: [\"local\", \"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    exported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\")\n    }\n  }\n});\n(0, _utils.default)(\"ForOfStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  builder: [\"left\", \"right\", \"body\", \"await\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\");\n        }\n\n        const declaration = (0, _utils.assertNodeType)(\"VariableDeclaration\");\n        const lval = (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\");\n        return function (node, key, val) {\n          if ((0, _is.default)(\"VariableDeclaration\", val)) {\n            declaration(node, key, val);\n          } else {\n            lval(node, key, val);\n          }\n        };\n      }()\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    },\n    await: {\n      default: false\n    }\n  }\n});\n(0, _utils.default)(\"ImportDeclaration\", {\n  visitor: [\"specifiers\", \"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\"],\n  fields: {\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    },\n    specifiers: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportSpecifier\", \"ImportDefaultSpecifier\", \"ImportNamespaceSpecifier\")))\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n    },\n    importKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"typeof\", \"value\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"ImportDefaultSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n(0, _utils.default)(\"ImportNamespaceSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n(0, _utils.default)(\"ImportSpecifier\", {\n  visitor: [\"local\", \"imported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    imported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\")\n    },\n    importKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"typeof\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"MetaProperty\", {\n  visitor: [\"meta\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    meta: {\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"Identifier\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        let property;\n\n        switch (val.name) {\n          case \"function\":\n            property = \"sent\";\n            break;\n\n          case \"new\":\n            property = \"target\";\n            break;\n\n          case \"import\":\n            property = \"meta\";\n            break;\n        }\n\n        if (!(0, _is.default)(\"Identifier\", node.property, {\n          name: property\n        })) {\n          throw new TypeError(\"Unrecognised MetaProperty\");\n        }\n      }, {\n        oneOfNodeTypes: [\"Identifier\"]\n      }))\n    },\n    property: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\nconst classMethodOrPropertyCommon = {\n  abstract: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  accessibility: {\n    validate: (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\"),\n    optional: true\n  },\n  static: {\n    default: false\n  },\n  override: {\n    default: false\n  },\n  computed: {\n    default: false\n  },\n  optional: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  key: {\n    validate: (0, _utils.chain)(function () {\n      const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n      const computed = (0, _utils.assertNodeType)(\"Expression\");\n      return function (node, key, val) {\n        const validator = node.computed ? computed : normal;\n        validator(node, key, val);\n      };\n    }(), (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"Expression\"))\n  }\n};\nexports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;\nconst classMethodOrDeclareMethodCommon = Object.assign({}, functionCommon, classMethodOrPropertyCommon, {\n  params: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"RestElement\", \"TSParameterProperty\")))\n  },\n  kind: {\n    validate: (0, _utils.assertOneOf)(\"get\", \"set\", \"method\", \"constructor\"),\n    default: \"method\"\n  },\n  access: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\")),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n    optional: true\n  }\n});\nexports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;\n(0, _utils.default)(\"ClassMethod\", {\n  aliases: [\"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\"],\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"static\", \"generator\", \"async\"],\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  fields: Object.assign({}, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n});\n(0, _utils.default)(\"ObjectPattern\", {\n  visitor: [\"properties\", \"typeAnnotation\", \"decorators\"],\n  builder: [\"properties\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    properties: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"RestElement\", \"ObjectProperty\")))\n    }\n  })\n});\n(0, _utils.default)(\"SpreadElement\", {\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\"],\n  deprecatedAlias: \"SpreadProperty\",\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"Super\", {\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"TaggedTemplateExpression\", {\n  visitor: [\"tag\", \"quasi\"],\n  aliases: [\"Expression\"],\n  fields: {\n    tag: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    quasi: {\n      validate: (0, _utils.assertNodeType)(\"TemplateLiteral\")\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"TemplateElement\", {\n  builder: [\"value\", \"tail\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertShape)({\n        raw: {\n          validate: (0, _utils.assertValueType)(\"string\")\n        },\n        cooked: {\n          validate: (0, _utils.assertValueType)(\"string\"),\n          optional: true\n        }\n      })\n    },\n    tail: {\n      default: false\n    }\n  }\n});\n(0, _utils.default)(\"TemplateLiteral\", {\n  visitor: [\"quasis\", \"expressions\"],\n  aliases: [\"Expression\", \"Literal\"],\n  fields: {\n    quasis: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TemplateElement\")))\n    },\n    expressions: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"TSType\")), function (node, key, val) {\n        if (node.quasis.length !== val.length + 1) {\n          throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.\\nExpected ${val.length + 1} quasis but got ${node.quasis.length}`);\n        }\n      })\n    }\n  }\n});\n(0, _utils.default)(\"YieldExpression\", {\n  builder: [\"argument\", \"delegate\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    delegate: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && !node.argument) {\n          throw new TypeError(\"Property delegate of YieldExpression cannot be true if there is no argument\");\n        }\n      }, {\n        type: \"boolean\"\n      })),\n      default: false\n    },\n    argument: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"AwaitExpression\", {\n  builder: [\"argument\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"Import\", {\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"BigIntLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"ExportNamespaceSpecifier\", {\n  visitor: [\"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    exported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n(0, _utils.default)(\"OptionalMemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", \"optional\"],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    property: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\"];\n        return validator;\n      }()\n    },\n    computed: {\n      default: false\n    },\n    optional: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)(\"boolean\") : (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), (0, _utils.assertOptionalChainStart)())\n    }\n  }\n});\n(0, _utils.default)(\"OptionalCallExpression\", {\n  visitor: [\"callee\", \"arguments\", \"typeParameters\", \"typeArguments\"],\n  builder: [\"callee\", \"arguments\", \"optional\"],\n  aliases: [\"Expression\"],\n  fields: {\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    arguments: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"SpreadElement\", \"JSXNamespacedName\", \"ArgumentPlaceholder\")))\n    },\n    optional: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)(\"boolean\") : (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), (0, _utils.assertOptionalChainStart)())\n    },\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  }\n});","map":{"version":3,"sources":["C:/Users/Andrew/Documents/JavaScript Projects/bool-simp/node_modules/@babel/types/lib/definitions/core.js"],"names":["Object","defineProperty","exports","value","classMethodOrDeclareMethodCommon","classMethodOrPropertyCommon","patternLikeCommon","functionDeclarationCommon","functionTypeAnnotationCommon","functionCommon","_is","require","_isValidIdentifier","_helperValidatorIdentifier","_constants","_utils","default","fields","elements","validate","chain","assertValueType","assertEach","assertNodeOrValueType","process","env","BABEL_TYPES_8_BREAKING","undefined","visitor","aliases","operator","identifier","assertOneOf","ASSIGNMENT_OPERATORS","pattern","node","key","val","validator","left","assertNodeType","right","builder","BINARY_OPERATORS","expression","inOp","oneOfNodeTypes","directives","body","label","optional","assign","callee","arguments","typeArguments","typeParameters","param","test","consequent","alternate","program","comments","each","tokens","type","init","update","params","generator","async","returnType","declare","id","parent","inherits","typeAnnotation","decorators","name","TypeError","match","exec","parentKey","nonComp","computed","imported","meta","isKeyword","isReservedWord","deprecatedAlias","flags","invalid","LOGICAL_OPERATORS","object","property","normal","sourceFile","sourceType","interpreter","properties","kind","shorthand","argument","Error","listKey","index","length","expressions","discriminant","cases","block","handler","finalizer","prefix","UNARY_OPERATORS","UPDATE_OPERATORS","declarations","without","definite","superClass","superTypeParameters","implements","mixins","abstract","source","exportKind","validateOptional","assertions","declaration","specifiers","sourced","sourceless","local","exported","lval","await","importKind","accessibility","static","override","access","tag","quasi","assertShape","raw","cooked","tail","quasis","delegate","assertOptionalChainStart"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.classMethodOrDeclareMethodCommon = exports.classMethodOrPropertyCommon = exports.patternLikeCommon = exports.functionDeclarationCommon = exports.functionTypeAnnotationCommon = exports.functionCommon = void 0;\n\nvar _is = require(\"../validators/is\");\n\nvar _isValidIdentifier = require(\"../validators/isValidIdentifier\");\n\nvar _helperValidatorIdentifier = require(\"@babel/helper-validator-identifier\");\n\nvar _constants = require(\"../constants\");\n\nvar _utils = require(\"./utils\");\n\n(0, _utils.default)(\"ArrayExpression\", {\n  fields: {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)(\"null\", \"Expression\", \"SpreadElement\"))),\n      default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined\n    }\n  },\n  visitor: [\"elements\"],\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"AssignmentExpression\", {\n  fields: {\n    operator: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertValueType)(\"string\");\n        }\n\n        const identifier = (0, _utils.assertOneOf)(..._constants.ASSIGNMENT_OPERATORS);\n        const pattern = (0, _utils.assertOneOf)(\"=\");\n        return function (node, key, val) {\n          const validator = (0, _is.default)(\"Pattern\", node.left) ? pattern : identifier;\n          validator(node, key, val);\n        };\n      }()\n    },\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"BinaryExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.BINARY_OPERATORS)\n    },\n    left: {\n      validate: function () {\n        const expression = (0, _utils.assertNodeType)(\"Expression\");\n        const inOp = (0, _utils.assertNodeType)(\"Expression\", \"PrivateName\");\n\n        const validator = function (node, key, val) {\n          const validator = node.operator === \"in\" ? inOp : expression;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"PrivateName\"];\n        return validator;\n      }()\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"]\n});\n(0, _utils.default)(\"InterpreterDirective\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\n(0, _utils.default)(\"Directive\", {\n  visitor: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertNodeType)(\"DirectiveLiteral\")\n    }\n  }\n});\n(0, _utils.default)(\"DirectiveLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\n(0, _utils.default)(\"BlockStatement\", {\n  builder: [\"body\", \"directives\"],\n  visitor: [\"directives\", \"body\"],\n  fields: {\n    directives: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Directive\"))),\n      default: []\n    },\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\", \"Statement\"]\n});\n(0, _utils.default)(\"BreakStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\n(0, _utils.default)(\"CallExpression\", {\n  visitor: [\"callee\", \"arguments\", \"typeParameters\", \"typeArguments\"],\n  builder: [\"callee\", \"arguments\"],\n  aliases: [\"Expression\"],\n  fields: Object.assign({\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"V8IntrinsicIdentifier\")\n    },\n    arguments: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"SpreadElement\", \"JSXNamespacedName\", \"ArgumentPlaceholder\")))\n    }\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertOneOf)(true, false),\n      optional: true\n    }\n  } : {}, {\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  })\n});\n(0, _utils.default)(\"CatchClause\", {\n  visitor: [\"param\", \"body\"],\n  fields: {\n    param: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\"]\n});\n(0, _utils.default)(\"ConditionalExpression\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    alternate: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Expression\", \"Conditional\"]\n});\n(0, _utils.default)(\"ContinueStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\n(0, _utils.default)(\"DebuggerStatement\", {\n  aliases: [\"Statement\"]\n});\n(0, _utils.default)(\"DoWhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  },\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"]\n});\n(0, _utils.default)(\"EmptyStatement\", {\n  aliases: [\"Statement\"]\n});\n(0, _utils.default)(\"ExpressionStatement\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Statement\", \"ExpressionWrapper\"]\n});\n(0, _utils.default)(\"File\", {\n  builder: [\"program\", \"comments\", \"tokens\"],\n  visitor: [\"program\"],\n  fields: {\n    program: {\n      validate: (0, _utils.assertNodeType)(\"Program\")\n    },\n    comments: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => {}, {\n        each: {\n          oneOfNodeTypes: [\"CommentBlock\", \"CommentLine\"]\n        }\n      }) : (0, _utils.assertEach)((0, _utils.assertNodeType)(\"CommentBlock\", \"CommentLine\")),\n      optional: true\n    },\n    tokens: {\n      validate: (0, _utils.assertEach)(Object.assign(() => {}, {\n        type: \"any\"\n      })),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"ForInStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\") : (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"ForStatement\", {\n  visitor: [\"init\", \"test\", \"update\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\"],\n  fields: {\n    init: {\n      validate: (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Expression\"),\n      optional: true\n    },\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    update: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\nconst functionCommon = {\n  params: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"RestElement\")))\n  },\n  generator: {\n    default: false\n  },\n  async: {\n    default: false\n  }\n};\nexports.functionCommon = functionCommon;\nconst functionTypeAnnotationCommon = {\n  returnType: {\n    validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  typeParameters: {\n    validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n    optional: true\n  }\n};\nexports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;\nconst functionDeclarationCommon = Object.assign({}, functionCommon, {\n  declare: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  id: {\n    validate: (0, _utils.assertNodeType)(\"Identifier\"),\n    optional: true\n  }\n});\nexports.functionDeclarationCommon = functionDeclarationCommon;\n(0, _utils.default)(\"FunctionDeclaration\", {\n  builder: [\"id\", \"params\", \"body\", \"generator\", \"async\"],\n  visitor: [\"id\", \"params\", \"body\", \"returnType\", \"typeParameters\"],\n  fields: Object.assign({}, functionDeclarationCommon, functionTypeAnnotationCommon, {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }),\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Statement\", \"Pureish\", \"Declaration\"],\n  validate: function () {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return () => {};\n    const identifier = (0, _utils.assertNodeType)(\"Identifier\");\n    return function (parent, key, node) {\n      if (!(0, _is.default)(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  }()\n});\n(0, _utils.default)(\"FunctionExpression\", {\n  inherits: \"FunctionDeclaration\",\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n});\nconst patternLikeCommon = {\n  typeAnnotation: {\n    validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\")))\n  }\n};\nexports.patternLikeCommon = patternLikeCommon;\n(0, _utils.default)(\"Identifier\", {\n  builder: [\"name\"],\n  visitor: [\"typeAnnotation\", \"decorators\"],\n  aliases: [\"Expression\", \"PatternLike\", \"LVal\", \"TSEntityName\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    name: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (!(0, _isValidIdentifier.default)(val, false)) {\n          throw new TypeError(`\"${val}\" is not a valid identifier name`);\n        }\n      }, {\n        type: \"string\"\n      }))\n    },\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  }),\n\n  validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    const match = /\\.(\\w+)$/.exec(key);\n    if (!match) return;\n    const [, parentKey] = match;\n    const nonComp = {\n      computed: false\n    };\n\n    if (parentKey === \"property\") {\n      if ((0, _is.default)(\"MemberExpression\", parent, nonComp)) return;\n      if ((0, _is.default)(\"OptionalMemberExpression\", parent, nonComp)) return;\n    } else if (parentKey === \"key\") {\n      if ((0, _is.default)(\"Property\", parent, nonComp)) return;\n      if ((0, _is.default)(\"Method\", parent, nonComp)) return;\n    } else if (parentKey === \"exported\") {\n      if ((0, _is.default)(\"ExportSpecifier\", parent)) return;\n    } else if (parentKey === \"imported\") {\n      if ((0, _is.default)(\"ImportSpecifier\", parent, {\n        imported: node\n      })) return;\n    } else if (parentKey === \"meta\") {\n      if ((0, _is.default)(\"MetaProperty\", parent, {\n        meta: node\n      })) return;\n    }\n\n    if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) && node.name !== \"this\") {\n      throw new TypeError(`\"${node.name}\" is not a valid identifier`);\n    }\n  }\n\n});\n(0, _utils.default)(\"IfStatement\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  aliases: [\"Statement\", \"Conditional\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    },\n    alternate: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"LabeledStatement\", {\n  visitor: [\"label\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"StringLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"NumericLiteral\", {\n  builder: [\"value\"],\n  deprecatedAlias: \"NumberLiteral\",\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"number\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"NullLiteral\", {\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"BooleanLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"RegExpLiteral\", {\n  builder: [\"pattern\", \"flags\"],\n  deprecatedAlias: \"RegexLiteral\",\n  aliases: [\"Expression\", \"Pureish\", \"Literal\"],\n  fields: {\n    pattern: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    flags: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        const invalid = /[^gimsuy]/.exec(val);\n\n        if (invalid) {\n          throw new TypeError(`\"${invalid[0]}\" is not a valid RegExp flag`);\n        }\n      }, {\n        type: \"string\"\n      })),\n      default: \"\"\n    }\n  }\n});\n(0, _utils.default)(\"LogicalExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.LOGICAL_OPERATORS)\n    },\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"MemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", ...(!process.env.BABEL_TYPES_8_BREAKING ? [\"optional\"] : [])],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\", \"LVal\"],\n  fields: Object.assign({\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    property: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"PrivateName\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"PrivateName\"];\n        return validator;\n      }()\n    },\n    computed: {\n      default: false\n    }\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertOneOf)(true, false),\n      optional: true\n    }\n  } : {})\n});\n(0, _utils.default)(\"NewExpression\", {\n  inherits: \"CallExpression\"\n});\n(0, _utils.default)(\"Program\", {\n  visitor: [\"directives\", \"body\"],\n  builder: [\"body\", \"directives\", \"sourceType\", \"interpreter\"],\n  fields: {\n    sourceFile: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    sourceType: {\n      validate: (0, _utils.assertOneOf)(\"script\", \"module\"),\n      default: \"script\"\n    },\n    interpreter: {\n      validate: (0, _utils.assertNodeType)(\"InterpreterDirective\"),\n      default: null,\n      optional: true\n    },\n    directives: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Directive\"))),\n      default: []\n    },\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\"]\n});\n(0, _utils.default)(\"ObjectExpression\", {\n  visitor: [\"properties\"],\n  aliases: [\"Expression\"],\n  fields: {\n    properties: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ObjectMethod\", \"ObjectProperty\", \"SpreadElement\")))\n    }\n  }\n});\n(0, _utils.default)(\"ObjectMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"generator\", \"async\"],\n  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {\n    kind: Object.assign({\n      validate: (0, _utils.assertOneOf)(\"method\", \"get\", \"set\")\n    }, !process.env.BABEL_TYPES_8_BREAKING ? {\n      default: \"method\"\n    } : {}),\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"StringLiteral\", \"NumericLiteral\"];\n        return validator;\n      }()\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }),\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  aliases: [\"UserWhitespacable\", \"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\", \"ObjectMember\"]\n});\n(0, _utils.default)(\"ObjectProperty\", {\n  builder: [\"key\", \"value\", \"computed\", \"shorthand\", ...(!process.env.BABEL_TYPES_8_BREAKING ? [\"decorators\"] : [])],\n  fields: {\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"StringLiteral\", \"NumericLiteral\"];\n        return validator;\n      }()\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"PatternLike\")\n    },\n    shorthand: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.computed) {\n          throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if computed is true\");\n        }\n      }, {\n        type: \"boolean\"\n      }), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && !(0, _is.default)(\"Identifier\", node.key)) {\n          throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if key is not an Identifier\");\n        }\n      }),\n      default: false\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  },\n  visitor: [\"key\", \"value\", \"decorators\"],\n  aliases: [\"UserWhitespacable\", \"Property\", \"ObjectMember\"],\n  validate: function () {\n    const pattern = (0, _utils.assertNodeType)(\"Identifier\", \"Pattern\");\n    const expression = (0, _utils.assertNodeType)(\"Expression\");\n    return function (parent, key, node) {\n      if (!process.env.BABEL_TYPES_8_BREAKING) return;\n      const validator = (0, _is.default)(\"ObjectPattern\", parent) ? pattern : expression;\n      validator(node, \"value\", node.value);\n    };\n  }()\n});\n(0, _utils.default)(\"RestElement\", {\n  visitor: [\"argument\", \"typeAnnotation\"],\n  builder: [\"argument\"],\n  aliases: [\"LVal\", \"PatternLike\"],\n  deprecatedAlias: \"RestProperty\",\n  fields: Object.assign({}, patternLikeCommon, {\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\") : (0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"MemberExpression\")\n    }\n  }),\n\n  validate(parent, key) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    const match = /(\\w+)\\[(\\d+)\\]/.exec(key);\n    if (!match) throw new Error(\"Internal Babel error: malformed key.\");\n    const [, listKey, index] = match;\n\n    if (parent[listKey].length > index + 1) {\n      throw new TypeError(`RestElement must be last element of ${listKey}`);\n    }\n  }\n\n});\n(0, _utils.default)(\"ReturnStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"SequenceExpression\", {\n  visitor: [\"expressions\"],\n  fields: {\n    expressions: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\")))\n    }\n  },\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"ParenthesizedExpression\", {\n  visitor: [\"expression\"],\n  aliases: [\"Expression\", \"ExpressionWrapper\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"SwitchCase\", {\n  visitor: [\"test\", \"consequent\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    consequent: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  }\n});\n(0, _utils.default)(\"SwitchStatement\", {\n  visitor: [\"discriminant\", \"cases\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Scopable\"],\n  fields: {\n    discriminant: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    cases: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"SwitchCase\")))\n    }\n  }\n});\n(0, _utils.default)(\"ThisExpression\", {\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"ThrowStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"TryStatement\", {\n  visitor: [\"block\", \"handler\", \"finalizer\"],\n  aliases: [\"Statement\"],\n  fields: {\n    block: {\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"BlockStatement\"), Object.assign(function (node) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (!node.handler && !node.finalizer) {\n          throw new TypeError(\"TryStatement expects either a handler or finalizer, or both\");\n        }\n      }, {\n        oneOfNodeTypes: [\"BlockStatement\"]\n      }))\n    },\n    handler: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"CatchClause\")\n    },\n    finalizer: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }\n});\n(0, _utils.default)(\"UnaryExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: true\n    },\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.UNARY_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\", \"Expression\"]\n});\n(0, _utils.default)(\"UpdateExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: false\n    },\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"Expression\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.UPDATE_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"VariableDeclaration\", {\n  builder: [\"kind\", \"declarations\"],\n  visitor: [\"declarations\"],\n  aliases: [\"Statement\", \"Declaration\"],\n  fields: {\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    kind: {\n      validate: (0, _utils.assertOneOf)(\"var\", \"let\", \"const\")\n    },\n    declarations: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"VariableDeclarator\")))\n    }\n  },\n\n  validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    if (!(0, _is.default)(\"ForXStatement\", parent, {\n      left: node\n    })) return;\n\n    if (node.declarations.length !== 1) {\n      throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);\n    }\n  }\n\n});\n(0, _utils.default)(\"VariableDeclarator\", {\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertNodeType)(\"LVal\");\n        }\n\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\");\n        const without = (0, _utils.assertNodeType)(\"Identifier\");\n        return function (node, key, val) {\n          const validator = node.init ? normal : without;\n          validator(node, key, val);\n        };\n      }()\n    },\n    definite: {\n      optional: true,\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    init: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"WhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"WithStatement\", {\n  visitor: [\"object\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n(0, _utils.default)(\"AssignmentPattern\", {\n  visitor: [\"left\", \"right\", \"decorators\"],\n  builder: [\"left\", \"right\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"ObjectPattern\", \"ArrayPattern\", \"MemberExpression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  })\n});\n(0, _utils.default)(\"ArrayPattern\", {\n  visitor: [\"elements\", \"typeAnnotation\"],\n  builder: [\"elements\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)(\"null\", \"PatternLike\")))\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  })\n});\n(0, _utils.default)(\"ArrowFunctionExpression\", {\n  builder: [\"params\", \"body\", \"async\"],\n  visitor: [\"params\", \"body\", \"returnType\", \"typeParameters\"],\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {\n    expression: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\", \"Expression\")\n    }\n  })\n});\n(0, _utils.default)(\"ClassBody\", {\n  visitor: [\"body\"],\n  fields: {\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ClassMethod\", \"ClassPrivateMethod\", \"ClassProperty\", \"ClassPrivateProperty\", \"TSDeclareMethod\", \"TSIndexSignature\")))\n    }\n  }\n});\n(0, _utils.default)(\"ClassExpression\", {\n  builder: [\"id\", \"superClass\", \"body\", \"decorators\"],\n  visitor: [\"id\", \"body\", \"superClass\", \"mixins\", \"typeParameters\", \"superTypeParameters\", \"implements\", \"decorators\"],\n  aliases: [\"Scopable\", \"Class\", \"Expression\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"ClassBody\")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    superTypeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    },\n    implements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSExpressionWithTypeArguments\", \"ClassImplements\"))),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    mixins: {\n      validate: (0, _utils.assertNodeType)(\"InterfaceExtends\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"ClassDeclaration\", {\n  inherits: \"ClassExpression\",\n  aliases: [\"Scopable\", \"Class\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"ClassBody\")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    superTypeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    },\n    implements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSExpressionWithTypeArguments\", \"ClassImplements\"))),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    mixins: {\n      validate: (0, _utils.assertNodeType)(\"InterfaceExtends\"),\n      optional: true\n    },\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    abstract: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  },\n  validate: function () {\n    const identifier = (0, _utils.assertNodeType)(\"Identifier\");\n    return function (parent, key, node) {\n      if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n      if (!(0, _is.default)(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  }()\n});\n(0, _utils.default)(\"ExportAllDeclaration\", {\n  visitor: [\"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"type\", \"value\")),\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    }\n  }\n});\n(0, _utils.default)(\"ExportDefaultDeclaration\", {\n  visitor: [\"declaration\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    declaration: {\n      validate: (0, _utils.assertNodeType)(\"FunctionDeclaration\", \"TSDeclareFunction\", \"ClassDeclaration\", \"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"ExportNamedDeclaration\", {\n  visitor: [\"declaration\", \"specifiers\", \"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    declaration: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"Declaration\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.specifiers.length) {\n          throw new TypeError(\"Only declaration or specifiers is allowed on ExportNamedDeclaration\");\n        }\n      }, {\n        oneOfNodeTypes: [\"Declaration\"]\n      }), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.source) {\n          throw new TypeError(\"Cannot export a declaration from a source\");\n        }\n      })\n    },\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    },\n    specifiers: {\n      default: [],\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)(function () {\n        const sourced = (0, _utils.assertNodeType)(\"ExportSpecifier\", \"ExportDefaultSpecifier\", \"ExportNamespaceSpecifier\");\n        const sourceless = (0, _utils.assertNodeType)(\"ExportSpecifier\");\n        if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;\n        return function (node, key, val) {\n          const validator = node.source ? sourced : sourceless;\n          validator(node, key, val);\n        };\n      }()))\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\"),\n      optional: true\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"type\", \"value\"))\n  }\n});\n(0, _utils.default)(\"ExportSpecifier\", {\n  visitor: [\"local\", \"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    exported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\")\n    }\n  }\n});\n(0, _utils.default)(\"ForOfStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  builder: [\"left\", \"right\", \"body\", \"await\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\");\n        }\n\n        const declaration = (0, _utils.assertNodeType)(\"VariableDeclaration\");\n        const lval = (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\");\n        return function (node, key, val) {\n          if ((0, _is.default)(\"VariableDeclaration\", val)) {\n            declaration(node, key, val);\n          } else {\n            lval(node, key, val);\n          }\n        };\n      }()\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    },\n    await: {\n      default: false\n    }\n  }\n});\n(0, _utils.default)(\"ImportDeclaration\", {\n  visitor: [\"specifiers\", \"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\"],\n  fields: {\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    },\n    specifiers: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportSpecifier\", \"ImportDefaultSpecifier\", \"ImportNamespaceSpecifier\")))\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n    },\n    importKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"typeof\", \"value\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"ImportDefaultSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n(0, _utils.default)(\"ImportNamespaceSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n(0, _utils.default)(\"ImportSpecifier\", {\n  visitor: [\"local\", \"imported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    imported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\")\n    },\n    importKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"typeof\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"MetaProperty\", {\n  visitor: [\"meta\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    meta: {\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"Identifier\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        let property;\n\n        switch (val.name) {\n          case \"function\":\n            property = \"sent\";\n            break;\n\n          case \"new\":\n            property = \"target\";\n            break;\n\n          case \"import\":\n            property = \"meta\";\n            break;\n        }\n\n        if (!(0, _is.default)(\"Identifier\", node.property, {\n          name: property\n        })) {\n          throw new TypeError(\"Unrecognised MetaProperty\");\n        }\n      }, {\n        oneOfNodeTypes: [\"Identifier\"]\n      }))\n    },\n    property: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\nconst classMethodOrPropertyCommon = {\n  abstract: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  accessibility: {\n    validate: (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\"),\n    optional: true\n  },\n  static: {\n    default: false\n  },\n  override: {\n    default: false\n  },\n  computed: {\n    default: false\n  },\n  optional: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  key: {\n    validate: (0, _utils.chain)(function () {\n      const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n      const computed = (0, _utils.assertNodeType)(\"Expression\");\n      return function (node, key, val) {\n        const validator = node.computed ? computed : normal;\n        validator(node, key, val);\n      };\n    }(), (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"Expression\"))\n  }\n};\nexports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;\nconst classMethodOrDeclareMethodCommon = Object.assign({}, functionCommon, classMethodOrPropertyCommon, {\n  params: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"RestElement\", \"TSParameterProperty\")))\n  },\n  kind: {\n    validate: (0, _utils.assertOneOf)(\"get\", \"set\", \"method\", \"constructor\"),\n    default: \"method\"\n  },\n  access: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\")),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n    optional: true\n  }\n});\nexports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;\n(0, _utils.default)(\"ClassMethod\", {\n  aliases: [\"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\"],\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"static\", \"generator\", \"async\"],\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  fields: Object.assign({}, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n});\n(0, _utils.default)(\"ObjectPattern\", {\n  visitor: [\"properties\", \"typeAnnotation\", \"decorators\"],\n  builder: [\"properties\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon, {\n    properties: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"RestElement\", \"ObjectProperty\")))\n    }\n  })\n});\n(0, _utils.default)(\"SpreadElement\", {\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\"],\n  deprecatedAlias: \"SpreadProperty\",\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"Super\", {\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"TaggedTemplateExpression\", {\n  visitor: [\"tag\", \"quasi\"],\n  aliases: [\"Expression\"],\n  fields: {\n    tag: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    quasi: {\n      validate: (0, _utils.assertNodeType)(\"TemplateLiteral\")\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  }\n});\n(0, _utils.default)(\"TemplateElement\", {\n  builder: [\"value\", \"tail\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertShape)({\n        raw: {\n          validate: (0, _utils.assertValueType)(\"string\")\n        },\n        cooked: {\n          validate: (0, _utils.assertValueType)(\"string\"),\n          optional: true\n        }\n      })\n    },\n    tail: {\n      default: false\n    }\n  }\n});\n(0, _utils.default)(\"TemplateLiteral\", {\n  visitor: [\"quasis\", \"expressions\"],\n  aliases: [\"Expression\", \"Literal\"],\n  fields: {\n    quasis: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TemplateElement\")))\n    },\n    expressions: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"TSType\")), function (node, key, val) {\n        if (node.quasis.length !== val.length + 1) {\n          throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.\\nExpected ${val.length + 1} quasis but got ${node.quasis.length}`);\n        }\n      })\n    }\n  }\n});\n(0, _utils.default)(\"YieldExpression\", {\n  builder: [\"argument\", \"delegate\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    delegate: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && !node.argument) {\n          throw new TypeError(\"Property delegate of YieldExpression cannot be true if there is no argument\");\n        }\n      }, {\n        type: \"boolean\"\n      })),\n      default: false\n    },\n    argument: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"AwaitExpression\", {\n  builder: [\"argument\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\n(0, _utils.default)(\"Import\", {\n  aliases: [\"Expression\"]\n});\n(0, _utils.default)(\"BigIntLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n(0, _utils.default)(\"ExportNamespaceSpecifier\", {\n  visitor: [\"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    exported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n(0, _utils.default)(\"OptionalMemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", \"optional\"],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    property: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\"];\n        return validator;\n      }()\n    },\n    computed: {\n      default: false\n    },\n    optional: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)(\"boolean\") : (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), (0, _utils.assertOptionalChainStart)())\n    }\n  }\n});\n(0, _utils.default)(\"OptionalCallExpression\", {\n  visitor: [\"callee\", \"arguments\", \"typeParameters\", \"typeArguments\"],\n  builder: [\"callee\", \"arguments\", \"optional\"],\n  aliases: [\"Expression\"],\n  fields: {\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    arguments: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"SpreadElement\", \"JSXNamespacedName\", \"ArgumentPlaceholder\")))\n    },\n    optional: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)(\"boolean\") : (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), (0, _utils.assertOptionalChainStart)())\n    },\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  }\n});"]},"metadata":{},"sourceType":"script"}