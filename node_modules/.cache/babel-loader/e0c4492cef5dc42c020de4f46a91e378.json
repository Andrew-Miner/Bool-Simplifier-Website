{"ast":null,"code":"import _toConsumableArray from\"C:/Users/Andrew/Documents/JavaScript Projects/bool-simp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import StructFactory from\"../StructFactory\";import BitSet from\"bitset\";var QMTerm=StructFactory(\"term dashMask used\");var REG_EXP=/^( *m *\\( *\\d+(?:, *\\d+)* *\\))( *\\+ *d *\\( *\\d+(?:, *\\d+)* *\\))?$/;var REG_NUMBS=/([\\d,\\s]+)/;var QM={getPrimeImplicants:function getPrimeImplicants(minTerms,dontCares,log){var allTerms=dontCares?minTerms.concat(dontCares):minTerms;var qmTerms=this.getQMArray(allTerms);qmTerms=this.fromatQMArray(qmTerms);var reducedTerms=[];this.reduceQMTerms(qmTerms,reducedTerms,log);this.removeDuplicateTerms(reducedTerms);return reducedTerms;},toString:function toString(qmTerm,variableCount){var varLimit=variableCount===0?25:variableCount-1;var str=\"\";for(var i=varLimit;i>=0;i--){if((i+1)%4===0)str+=\" \";if(qmTerm.dashMask.get(i)===1)str+=\"-\";else str+=qmTerm.term.get(i);}return str;},getQMArray:function getQMArray(intTerms){var terms=[];intTerms.forEach(function(term){terms.push(new QMTerm(new BitSet(term),new BitSet(0),false));});return terms;},fromatQMArray:function fromatQMArray(qmTerms){// compareQMTerms works like a standard comparison function\n// and must be multiplied by -1 to sort in decending order\nreturn qmTerms.sort(function(term1,term2){return QM.compareQMTerms(term1,term2)*-1;});},// This function iterates the dashMask bitset\n// forward once and backward once. Each time it\n// comes accross a set bit it flips that bit in\n// in the minTerm bitset and stores the new\n// minTerm value. Aka O(2n) where n is the number\n// of variable in an expression. There is one other\n// algorithm I came up with that that is\n// O(2^(d+2) - 1) where d is the number of set\n// bits in the qmTerm's dashMask. Which algorithm\n// is better is heavily dependent on the number of\n// variables in an expression how reducable said\n// expression is. I decided to stick with the O(n)\n// case for the sake of being linear.\nextractMinTerms:function extractMinTerms(qmTerm){var minTerm=qmTerm.term;var resultant=[parseInt(minTerm.toString(10))];var curCount=1;var dashPos=-1;var forward=true;var minTermCount=Math.pow(2,qmTerm.dashMask.cardinality());while(curCount<minTermCount){var nextPos=-1;if(forward)nextPos=this.nextDash(qmTerm.dashMask,dashPos);else nextPos=this.prevDash(qmTerm.dashMask,dashPos);if(nextPos===-1){forward=!forward;continue;}dashPos=nextPos;minTerm.flip(dashPos);resultant.push(parseInt(minTerm.toString(10)));curCount++;}return resultant;},reduceQMTerms:function reduceQMTerms(qmTerms,resultant,log){var tmpTerms=qmTerms.slice();var reducedTerms=[];if(log)log.push(qmTerms);for(var i=0;i<tmpTerms.length;){for(var j=i+1;j<tmpTerms.length;j++){if(tmpTerms[i].dashMask.equals(tmpTerms[j].dashMask)){// Core of QM Method\nvar _resultant=new QMTerm(tmpTerms[i].term.and(tmpTerms[j].term),tmpTerms[i].term.xor(tmpTerms[j].term),false);// Real resultant will always have 1 more dash mark than the original terms\nif(_resultant.dashMask.cardinality()!==1)continue;_resultant.dashMask=_resultant.dashMask.or(tmpTerms[i].dashMask);reducedTerms.push(_resultant);tmpTerms[i].used=true;tmpTerms[j].used=true;}}// Remove Used Terms\nif(tmpTerms[i].used)tmpTerms.splice(i,1);else i++;}// Remove any remaining used terms\nfor(var _i=0;_i<tmpTerms.length;){if(tmpTerms[_i].used)tmpTerms.splice(_i,1);else _i++;}// Save unused Terms\nresultant.push.apply(resultant,_toConsumableArray(tmpTerms));// If we're not done reducing\nif(reducedTerms.length!==0){this.removeDuplicateTerms(reducedTerms);this.reduceQMTerms(reducedTerms,resultant,log);}},removeDuplicateTerms:function removeDuplicateTerms(qmTerms){for(var i=0;i<qmTerms.length;i++){for(var j=i+1;j<qmTerms.length;){if(qmTerms[i].term.equals(qmTerms[j].term)&&qmTerms[i].dashMask.equals(qmTerms[j].dashMask))qmTerms.splice(j,1);else j++;}}},compareQMTerms:function compareQMTerms(qmTerm1,qmTerm2){var term1=parseInt(qmTerm1.term.toString(10));var term2=parseInt(qmTerm2.term.toString(10));return term1<term2?-1:term1>term2?1:0;},prevDash:function prevDash(dashMask,pos){for(var i=pos===-1?dashMask.cardinality()-1:pos-1;i>=0;i--){if(dashMask.get(i)===1)return i;}return-1;},nextDash:function nextDash(dashMask,pos){for(var i=pos===-1?0:pos+1;i<dashMask.toString().length;i++){if(dashMask.get(i)===1)return i;}return-1;},parseString:function parseString(expression){if(!REG_EXP.test(expression))return[false,[],[]];var matches=expression.match(REG_EXP);var mNumbers=matches[1].match(REG_NUMBS);var minTerms=mNumbers[1].split(\",\").map(function(e){return parseInt(e);});if(matches[2]===undefined)return[true,minTerms,[]];var dNumbers=matches[2].match(REG_NUMBS);var dontCares=dNumbers[1].split(\",\").map(function(e){return parseInt(e);});return[true,minTerms,dontCares];},getVariableCount:function getVariableCount(minTerms,dontCares){var highest=0;minTerms.forEach(function(term){if(term>highest)highest=term;else if(!highest&&!term)highest=1;});dontCares.forEach(function(term){if(term>highest)highest=term;});var bits=0;while(highest){highest>>>=1;bits++;}return bits;},getEssentialTerms:function getEssentialTerms(qmTerms,minTerms){var _this=this;var essentialTerms=[];var _loop=function _loop(i){var mins=_this.extractMinTerms(qmTerms[i]);var _loop2=function _loop2(j){if(minTerms.find(function(element){return element===mins[j];})){essentialTerms.push(qmTerms[i]);return\"break\";}};for(var j=0;j<mins.length;j++){var _ret=_loop2(j);if(_ret===\"break\")break;}};for(var i=0;i<qmTerms.length;i++){_loop(i);}return essentialTerms;},isQMTermEqual:function isQMTermEqual(qmTerm1,qmTerm2){return qmTerm1.term.equals(qmTerm2.term)&&qmTerm1.dashMask.equals(qmTerm2.dashMask);}};export default QM;","map":{"version":3,"sources":["C:/Users/Andrew/Documents/JavaScript Projects/bool-simp/src/scripts/BooleanSimplifier/QMFunctions.js"],"names":["StructFactory","BitSet","QMTerm","REG_EXP","REG_NUMBS","QM","getPrimeImplicants","minTerms","dontCares","log","allTerms","concat","qmTerms","getQMArray","fromatQMArray","reducedTerms","reduceQMTerms","removeDuplicateTerms","toString","qmTerm","variableCount","varLimit","str","i","dashMask","get","term","intTerms","terms","forEach","push","sort","term1","term2","compareQMTerms","extractMinTerms","minTerm","resultant","parseInt","curCount","dashPos","forward","minTermCount","cardinality","nextPos","nextDash","prevDash","flip","tmpTerms","slice","length","j","equals","and","xor","or","used","splice","qmTerm1","qmTerm2","pos","parseString","expression","test","matches","match","mNumbers","split","map","e","undefined","dNumbers","getVariableCount","highest","bits","getEssentialTerms","essentialTerms","mins","find","element","isQMTermEqual"],"mappings":"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","sourcesContent":["import StructFactory from \"../StructFactory\";\r\nimport BitSet from \"bitset\";\r\nconst QMTerm = StructFactory(\"term dashMask used\");\r\nconst REG_EXP = /^( *m *\\( *\\d+(?:, *\\d+)* *\\))( *\\+ *d *\\( *\\d+(?:, *\\d+)* *\\))?$/;\r\nconst REG_NUMBS = /([\\d,\\s]+)/;\r\n\r\nconst QM = {\r\n    getPrimeImplicants(minTerms, dontCares, log) {\r\n        let allTerms = dontCares ? minTerms.concat(dontCares) : minTerms;\r\n        let qmTerms = this.getQMArray(allTerms);\r\n        qmTerms = this.fromatQMArray(qmTerms);\r\n\r\n        let reducedTerms = [];\r\n        this.reduceQMTerms(qmTerms, reducedTerms, log);\r\n        this.removeDuplicateTerms(reducedTerms);\r\n        return reducedTerms;\r\n    },\r\n\r\n    toString(qmTerm, variableCount) {\r\n        let varLimit = variableCount === 0 ? 25 : variableCount - 1;\r\n\r\n        let str = \"\";\r\n        for (let i = varLimit; i >= 0; i--) {\r\n            if ((i + 1) % 4 === 0) str += \" \";\r\n            if (qmTerm.dashMask.get(i) === 1) str += \"-\";\r\n            else str += qmTerm.term.get(i);\r\n        }\r\n        return str;\r\n    },\r\n\r\n    getQMArray(intTerms) {\r\n        let terms = [];\r\n        intTerms.forEach((term) => {\r\n            terms.push(new QMTerm(new BitSet(term), new BitSet(0), false));\r\n        });\r\n        return terms;\r\n    },\r\n\r\n    fromatQMArray(qmTerms) {\r\n        // compareQMTerms works like a standard comparison function\r\n        // and must be multiplied by -1 to sort in decending order\r\n        return qmTerms.sort((term1, term2) => {\r\n            return QM.compareQMTerms(term1, term2) * -1;\r\n        });\r\n    },\r\n\r\n    // This function iterates the dashMask bitset\r\n    // forward once and backward once. Each time it\r\n    // comes accross a set bit it flips that bit in\r\n    // in the minTerm bitset and stores the new\r\n    // minTerm value. Aka O(2n) where n is the number\r\n    // of variable in an expression. There is one other\r\n    // algorithm I came up with that that is\r\n    // O(2^(d+2) - 1) where d is the number of set\r\n    // bits in the qmTerm's dashMask. Which algorithm\r\n    // is better is heavily dependent on the number of\r\n    // variables in an expression how reducable said\r\n    // expression is. I decided to stick with the O(n)\r\n    // case for the sake of being linear.\r\n    extractMinTerms(qmTerm) {\r\n        let minTerm = qmTerm.term;\r\n        let resultant = [parseInt(minTerm.toString(10))];\r\n\r\n        let curCount = 1;\r\n        let dashPos = -1;\r\n        let forward = true;\r\n        let minTermCount = 2 ** qmTerm.dashMask.cardinality();\r\n\r\n        while (curCount < minTermCount) {\r\n            let nextPos = -1;\r\n\r\n            if (forward) nextPos = this.nextDash(qmTerm.dashMask, dashPos);\r\n            else nextPos = this.prevDash(qmTerm.dashMask, dashPos);\r\n\r\n            if (nextPos === -1) {\r\n                forward = !forward;\r\n                continue;\r\n            }\r\n\r\n            dashPos = nextPos;\r\n            minTerm.flip(dashPos);\r\n            resultant.push(parseInt(minTerm.toString(10)));\r\n            curCount++;\r\n        }\r\n\r\n        return resultant;\r\n    },\r\n\r\n    reduceQMTerms(qmTerms, resultant, log) {\r\n        let tmpTerms = qmTerms.slice();\r\n        let reducedTerms = [];\r\n\r\n        if (log) log.push(qmTerms);\r\n\r\n        for (let i = 0; i < tmpTerms.length; ) {\r\n            for (let j = i + 1; j < tmpTerms.length; j++) {\r\n                if (tmpTerms[i].dashMask.equals(tmpTerms[j].dashMask)) {\r\n                    // Core of QM Method\r\n                    let resultant = new QMTerm(\r\n                        tmpTerms[i].term.and(tmpTerms[j].term),\r\n                        tmpTerms[i].term.xor(tmpTerms[j].term),\r\n                        false\r\n                    );\r\n\r\n                    // Real resultant will always have 1 more dash mark than the original terms\r\n                    if (resultant.dashMask.cardinality() !== 1) continue;\r\n\r\n                    resultant.dashMask = resultant.dashMask.or(tmpTerms[i].dashMask);\r\n\r\n                    reducedTerms.push(resultant);\r\n\r\n                    tmpTerms[i].used = true;\r\n                    tmpTerms[j].used = true;\r\n                }\r\n            }\r\n\r\n            // Remove Used Terms\r\n            if (tmpTerms[i].used) tmpTerms.splice(i, 1);\r\n            else i++;\r\n        }\r\n\r\n        // Remove any remaining used terms\r\n        for (let i = 0; i < tmpTerms.length; ) {\r\n            if (tmpTerms[i].used) tmpTerms.splice(i, 1);\r\n            else i++;\r\n        }\r\n\r\n        // Save unused Terms\r\n        resultant.push(...tmpTerms);\r\n\r\n        // If we're not done reducing\r\n        if (reducedTerms.length !== 0) {\r\n            this.removeDuplicateTerms(reducedTerms);\r\n            this.reduceQMTerms(reducedTerms, resultant, log);\r\n        }\r\n    },\r\n\r\n    removeDuplicateTerms(qmTerms) {\r\n        for (let i = 0; i < qmTerms.length; i++) {\r\n            for (let j = i + 1; j < qmTerms.length; ) {\r\n                if (\r\n                    qmTerms[i].term.equals(qmTerms[j].term) &&\r\n                    qmTerms[i].dashMask.equals(qmTerms[j].dashMask)\r\n                )\r\n                    qmTerms.splice(j, 1);\r\n                else j++;\r\n            }\r\n        }\r\n    },\r\n\r\n    compareQMTerms(qmTerm1, qmTerm2) {\r\n        let term1 = parseInt(qmTerm1.term.toString(10));\r\n        let term2 = parseInt(qmTerm2.term.toString(10));\r\n        return term1 < term2 ? -1 : term1 > term2 ? 1 : 0;\r\n    },\r\n\r\n    prevDash(dashMask, pos) {\r\n        for (let i = pos === -1 ? dashMask.cardinality() - 1 : pos - 1; i >= 0; i--) {\r\n            if (dashMask.get(i) === 1) return i;\r\n        }\r\n        return -1;\r\n    },\r\n\r\n    nextDash(dashMask, pos) {\r\n        for (let i = pos === -1 ? 0 : pos + 1; i < dashMask.toString().length; i++) {\r\n            if (dashMask.get(i) === 1) return i;\r\n        }\r\n        return -1;\r\n    },\r\n\r\n    parseString(expression) {\r\n        if (!REG_EXP.test(expression)) return [false, [], []];\r\n\r\n        let matches = expression.match(REG_EXP);\r\n        let mNumbers = matches[1].match(REG_NUMBS);\r\n        let minTerms = mNumbers[1].split(\",\").map((e) => parseInt(e));\r\n\r\n        if (matches[2] === undefined) return [true, minTerms, []];\r\n\r\n        let dNumbers = matches[2].match(REG_NUMBS);\r\n        let dontCares = dNumbers[1].split(\",\").map((e) => parseInt(e));\r\n        return [true, minTerms, dontCares];\r\n    },\r\n\r\n    getVariableCount(minTerms, dontCares) {\r\n        let highest = 0;\r\n\r\n        minTerms.forEach((term) => {\r\n            if (term > highest) highest = term;\r\n            else if (!highest && !term) highest = 1;\r\n        });\r\n\r\n        dontCares.forEach((term) => {\r\n            if (term > highest) highest = term;\r\n        });\r\n\r\n        let bits = 0;\r\n        while (highest) {\r\n            highest >>>= 1;\r\n            bits++;\r\n        }\r\n\r\n        return bits;\r\n    },\r\n\r\n    getEssentialTerms(qmTerms, minTerms) {\r\n        let essentialTerms = [];\r\n\r\n        for (let i = 0; i < qmTerms.length; i++) {\r\n            let mins = this.extractMinTerms(qmTerms[i]);\r\n            for (let j = 0; j < mins.length; j++) {\r\n                if (minTerms.find((element) => element === mins[j])) {\r\n                    essentialTerms.push(qmTerms[i]);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return essentialTerms;\r\n    },\r\n\r\n    isQMTermEqual(qmTerm1, qmTerm2) {\r\n        return (\r\n            qmTerm1.term.equals(qmTerm2.term) && qmTerm1.dashMask.equals(qmTerm2.dashMask)\r\n        );\r\n    },\r\n};\r\n\r\nexport default QM;\r\n"]},"metadata":{},"sourceType":"module"}