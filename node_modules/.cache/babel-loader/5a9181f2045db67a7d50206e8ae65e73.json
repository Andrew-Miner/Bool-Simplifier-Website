{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = cloneNode;\n\nvar _definitions = require(\"../definitions\");\n\nvar _generated = require(\"../validators/generated\");\n\nconst has = Function.call.bind(Object.prototype.hasOwnProperty);\n\nfunction cloneIfNode(obj, deep, withoutLoc) {\n  if (obj && typeof obj.type === \"string\") {\n    return cloneNode(obj, deep, withoutLoc);\n  }\n\n  return obj;\n}\n\nfunction cloneIfNodeOrArray(obj, deep, withoutLoc) {\n  if (Array.isArray(obj)) {\n    return obj.map(node => cloneIfNode(node, deep, withoutLoc));\n  }\n\n  return cloneIfNode(obj, deep, withoutLoc);\n}\n\nfunction cloneNode(node, deep = true, withoutLoc = false) {\n  if (!node) return node;\n  const {\n    type\n  } = node;\n  const newNode = {\n    type: node.type\n  };\n\n  if ((0, _generated.isIdentifier)(node)) {\n    newNode.name = node.name;\n\n    if (has(node, \"optional\") && typeof node.optional === \"boolean\") {\n      newNode.optional = node.optional;\n    }\n\n    if (has(node, \"typeAnnotation\")) {\n      newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc) : node.typeAnnotation;\n    }\n  } else if (!has(_definitions.NODE_FIELDS, type)) {\n    throw new Error(`Unknown node type: \"${type}\"`);\n  } else {\n    for (const field of Object.keys(_definitions.NODE_FIELDS[type])) {\n      if (has(node, field)) {\n        if (deep) {\n          newNode[field] = (0, _generated.isFile)(node) && field === \"comments\" ? maybeCloneComments(node.comments, deep, withoutLoc) : cloneIfNodeOrArray(node[field], true, withoutLoc);\n        } else {\n          newNode[field] = node[field];\n        }\n      }\n    }\n  }\n\n  if (has(node, \"loc\")) {\n    if (withoutLoc) {\n      newNode.loc = null;\n    } else {\n      newNode.loc = node.loc;\n    }\n  }\n\n  if (has(node, \"leadingComments\")) {\n    newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc);\n  }\n\n  if (has(node, \"innerComments\")) {\n    newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc);\n  }\n\n  if (has(node, \"trailingComments\")) {\n    newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc);\n  }\n\n  if (has(node, \"extra\")) {\n    newNode.extra = Object.assign({}, node.extra);\n  }\n\n  return newNode;\n}\n\nfunction maybeCloneComments(comments, deep, withoutLoc) {\n  if (!comments || !deep) {\n    return comments;\n  }\n\n  return comments.map(({\n    type,\n    value,\n    loc\n  }) => {\n    if (withoutLoc) {\n      return {\n        type,\n        value,\n        loc: null\n      };\n    }\n\n    return {\n      type,\n      value,\n      loc\n    };\n  });\n}","map":{"version":3,"sources":["C:/Users/Andrew/Documents/JavaScript Projects/bool-simp/node_modules/@babel/types/lib/clone/cloneNode.js"],"names":["Object","defineProperty","exports","value","default","cloneNode","_definitions","require","_generated","has","Function","call","bind","prototype","hasOwnProperty","cloneIfNode","obj","deep","withoutLoc","type","cloneIfNodeOrArray","Array","isArray","map","node","newNode","isIdentifier","name","optional","typeAnnotation","NODE_FIELDS","Error","field","keys","isFile","maybeCloneComments","comments","loc","leadingComments","innerComments","trailingComments","extra","assign"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = cloneNode;\n\nvar _definitions = require(\"../definitions\");\n\nvar _generated = require(\"../validators/generated\");\n\nconst has = Function.call.bind(Object.prototype.hasOwnProperty);\n\nfunction cloneIfNode(obj, deep, withoutLoc) {\n  if (obj && typeof obj.type === \"string\") {\n    return cloneNode(obj, deep, withoutLoc);\n  }\n\n  return obj;\n}\n\nfunction cloneIfNodeOrArray(obj, deep, withoutLoc) {\n  if (Array.isArray(obj)) {\n    return obj.map(node => cloneIfNode(node, deep, withoutLoc));\n  }\n\n  return cloneIfNode(obj, deep, withoutLoc);\n}\n\nfunction cloneNode(node, deep = true, withoutLoc = false) {\n  if (!node) return node;\n  const {\n    type\n  } = node;\n  const newNode = {\n    type: node.type\n  };\n\n  if ((0, _generated.isIdentifier)(node)) {\n    newNode.name = node.name;\n\n    if (has(node, \"optional\") && typeof node.optional === \"boolean\") {\n      newNode.optional = node.optional;\n    }\n\n    if (has(node, \"typeAnnotation\")) {\n      newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc) : node.typeAnnotation;\n    }\n  } else if (!has(_definitions.NODE_FIELDS, type)) {\n    throw new Error(`Unknown node type: \"${type}\"`);\n  } else {\n    for (const field of Object.keys(_definitions.NODE_FIELDS[type])) {\n      if (has(node, field)) {\n        if (deep) {\n          newNode[field] = (0, _generated.isFile)(node) && field === \"comments\" ? maybeCloneComments(node.comments, deep, withoutLoc) : cloneIfNodeOrArray(node[field], true, withoutLoc);\n        } else {\n          newNode[field] = node[field];\n        }\n      }\n    }\n  }\n\n  if (has(node, \"loc\")) {\n    if (withoutLoc) {\n      newNode.loc = null;\n    } else {\n      newNode.loc = node.loc;\n    }\n  }\n\n  if (has(node, \"leadingComments\")) {\n    newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc);\n  }\n\n  if (has(node, \"innerComments\")) {\n    newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc);\n  }\n\n  if (has(node, \"trailingComments\")) {\n    newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc);\n  }\n\n  if (has(node, \"extra\")) {\n    newNode.extra = Object.assign({}, node.extra);\n  }\n\n  return newNode;\n}\n\nfunction maybeCloneComments(comments, deep, withoutLoc) {\n  if (!comments || !deep) {\n    return comments;\n  }\n\n  return comments.map(({\n    type,\n    value,\n    loc\n  }) => {\n    if (withoutLoc) {\n      return {\n        type,\n        value,\n        loc: null\n      };\n    }\n\n    return {\n      type,\n      value,\n      loc\n    };\n  });\n}"]},"metadata":{},"sourceType":"script"}