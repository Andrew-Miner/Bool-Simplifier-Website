{"ast":null,"code":"import _classPrivateFieldLooseBase from \"C:/Users/Andrew/Documents/JavaScript Projects/bool-simp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"C:/Users/Andrew/Documents/JavaScript Projects/bool-simp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\nimport { buildBoolGrammar, deepCopy, validateTerms, getVarBitSet, calculateMinTerms } from \"./BoolExpressionUtils\";\nimport QMFuncs from \"./QMFunctions\";\nimport PMFuncs from \"./PMFunctions\";\nimport Recognizer from \"../Earley Parser/EarleyRecognizer\";\nimport Parser from \"../Earley Parser/EarleyParser\";\n\nvar _varCount = /*#__PURE__*/_classPrivateFieldLooseKey(\"varCount\");\n\nvar _minTerms = /*#__PURE__*/_classPrivateFieldLooseKey(\"minTerms\");\n\nvar _dontCares = /*#__PURE__*/_classPrivateFieldLooseKey(\"dontCares\");\n\nvar _primeImps = /*#__PURE__*/_classPrivateFieldLooseKey(\"primeImps\");\n\nvar _petrickSOP = /*#__PURE__*/_classPrivateFieldLooseKey(\"petrickSOP\");\n\nvar _sSet = /*#__PURE__*/_classPrivateFieldLooseKey(\"sSet\");\n\nvar _invertedS = /*#__PURE__*/_classPrivateFieldLooseKey(\"invertedS\");\n\nvar _parseTree = /*#__PURE__*/_classPrivateFieldLooseKey(\"parseTree\");\n\nvar _varBitSet = /*#__PURE__*/_classPrivateFieldLooseKey(\"varBitSet\");\n\nvar _expression = /*#__PURE__*/_classPrivateFieldLooseKey(\"expression\");\n\nvar _errorCode = /*#__PURE__*/_classPrivateFieldLooseKey(\"errorCode\");\n\nvar _isLogged = /*#__PURE__*/_classPrivateFieldLooseKey(\"isLogged\");\n\nvar _qmLog = /*#__PURE__*/_classPrivateFieldLooseKey(\"qmLog\");\n\nvar _pmLog = /*#__PURE__*/_classPrivateFieldLooseKey(\"pmLog\");\n\nvar _truthTable = /*#__PURE__*/_classPrivateFieldLooseKey(\"truthTable\");\n\nvar _BOOL_GRAMMAR = /*#__PURE__*/_classPrivateFieldLooseKey(\"BOOL_GRAMMAR\");\n\nvar _reduce = /*#__PURE__*/_classPrivateFieldLooseKey(\"reduce\");\n\nvar _buildTruthTable = /*#__PURE__*/_classPrivateFieldLooseKey(\"buildTruthTable\");\n\nexport default class BoolExpression {\n  constructor(_expression2, _minTerms2, _dontCares2, isLogged = false) {\n    Object.defineProperty(this, _varCount, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _minTerms, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _dontCares, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _primeImps, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _petrickSOP, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _sSet, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _invertedS, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _parseTree, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _varBitSet, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _expression, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _errorCode, {\n      writable: true,\n      value: -2\n    });\n    Object.defineProperty(this, _isLogged, {\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, _qmLog, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _pmLog, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _truthTable, {\n      writable: true,\n      value: void 0\n    });\n\n    this.getMinTerms = () => deepCopy(_classPrivateFieldLooseBase(this, _minTerms)[_minTerms]);\n\n    this.getDontCares = () => deepCopy(_classPrivateFieldLooseBase(this, _dontCares)[_dontCares]);\n\n    this.getPetrickSOP = () => deepCopy(_classPrivateFieldLooseBase(this, _petrickSOP)[_petrickSOP]);\n\n    this.getEssentialImplicants = () => deepCopy(_classPrivateFieldLooseBase(this, _primeImps)[_primeImps]);\n\n    this.getVarCount = () => _classPrivateFieldLooseBase(this, _varCount)[_varCount];\n\n    this.getQMLog = () => _classPrivateFieldLooseBase(this, _isLogged)[_isLogged] ? deepCopy(_classPrivateFieldLooseBase(this, _qmLog)[_qmLog]) : [];\n\n    this.getPMLog = () => _classPrivateFieldLooseBase(this, _isLogged)[_isLogged] ? deepCopy(_classPrivateFieldLooseBase(this, _pmLog)[_pmLog]) : [];\n\n    this.getTruthTable = () => deepCopy(_classPrivateFieldLooseBase(this, _truthTable)[_truthTable]);\n\n    this.getPrimeImpStrings = () => {\n      let piStrs = [];\n\n      for (const implicant of _classPrivateFieldLooseBase(this, _primeImps)[_primeImps]) {\n        let str = \"[\";\n        let minTerms = QMFuncs.extractMinTerms(implicant);\n\n        for (const term of minTerms) str += parseInt(term) + \"-\";\n\n        str = str.substring(0, str.length - 1) + \"] \";\n        str += QMFuncs.toString(implicant, _classPrivateFieldLooseBase(this, _varCount)[_varCount]);\n        piStrs.push(str);\n      }\n\n      return piStrs;\n    };\n\n    this.getSOPStrings = () => {\n      let sopStrs = [];\n\n      for (const product of _classPrivateFieldLooseBase(this, _petrickSOP)[_petrickSOP]) {\n        if (_classPrivateFieldLooseBase(this, _varBitSet)[_varBitSet]) sopStrs.push(PMFuncs.mapProductToString(product, _classPrivateFieldLooseBase(this, _varBitSet)[_varBitSet]));else sopStrs.push(PMFuncs.productToString(product, _classPrivateFieldLooseBase(this, _varCount)[_varCount]));\n      }\n\n      return sopStrs;\n    };\n\n    this.setExpression = expression => {\n      let sSet = Recognizer.buildItems(expression, _classPrivateFieldLooseBase(BoolExpression, _BOOL_GRAMMAR)[_BOOL_GRAMMAR]);\n      let invertedS = Parser.invertEarleySets(sSet, _classPrivateFieldLooseBase(BoolExpression, _BOOL_GRAMMAR)[_BOOL_GRAMMAR]);\n      let parseTree = Parser.buildParseTree(expression, invertedS, _classPrivateFieldLooseBase(BoolExpression, _BOOL_GRAMMAR)[_BOOL_GRAMMAR]);\n\n      if (parseTree !== null) {\n        _classPrivateFieldLooseBase(this, _sSet)[_sSet] = sSet;\n        _classPrivateFieldLooseBase(this, _invertedS)[_invertedS] = invertedS;\n        _classPrivateFieldLooseBase(this, _parseTree)[_parseTree] = parseTree;\n        _classPrivateFieldLooseBase(this, _varBitSet)[_varBitSet] = getVarBitSet(expression);\n        _classPrivateFieldLooseBase(this, _varCount)[_varCount] = _classPrivateFieldLooseBase(this, _varBitSet)[_varBitSet].cardinality();\n        _classPrivateFieldLooseBase(this, _minTerms)[_minTerms] = calculateMinTerms(expression, parseTree, _classPrivateFieldLooseBase(this, _varBitSet)[_varBitSet]);\n      } else {\n        let [parsed, minTerms, dontCares] = QMFuncs.parseString(expression);\n\n        if (!parsed) {\n          _classPrivateFieldLooseBase(this, _errorCode)[_errorCode] = -2;\n          return false;\n        }\n\n        let [validated, errorCode] = validateTerms(minTerms, dontCares);\n\n        if (!validated) {\n          _classPrivateFieldLooseBase(this, _errorCode)[_errorCode] = errorCode;\n          return false;\n        }\n\n        _classPrivateFieldLooseBase(this, _varCount)[_varCount] = QMFuncs.getVariableCount(minTerms, dontCares);\n        _classPrivateFieldLooseBase(this, _minTerms)[_minTerms] = minTerms;\n        _classPrivateFieldLooseBase(this, _dontCares)[_dontCares] = dontCares;\n      }\n\n      if (_classPrivateFieldLooseBase(this, _isLogged)[_isLogged]) {\n        _classPrivateFieldLooseBase(this, _qmLog)[_qmLog] = [];\n        _classPrivateFieldLooseBase(this, _pmLog)[_pmLog] = [];\n      }\n\n      _classPrivateFieldLooseBase(this, _reduce)[_reduce]();\n\n      _classPrivateFieldLooseBase(this, _buildTruthTable)[_buildTruthTable]();\n\n      return true;\n    };\n\n    this.setMinTerms = (minTerms, dontCares) => {\n      let [success, errorCode] = validateTerms(minTerms, dontCares);\n\n      if (!success) {\n        _classPrivateFieldLooseBase(this, _errorCode)[_errorCode] = errorCode;\n        return false;\n      }\n\n      _classPrivateFieldLooseBase(this, _minTerms)[_minTerms] = minTerms;\n      _classPrivateFieldLooseBase(this, _dontCares)[_dontCares] = dontCares;\n      _classPrivateFieldLooseBase(this, _varCount)[_varCount] = QMFuncs.getVariableCount(minTerms, dontCares);\n      _classPrivateFieldLooseBase(this, _sSet)[_sSet] = null;\n      this.expression = null;\n      _classPrivateFieldLooseBase(this, _invertedS)[_invertedS] = null;\n      _classPrivateFieldLooseBase(this, _parseTree)[_parseTree] = null;\n      _classPrivateFieldLooseBase(this, _varBitSet)[_varBitSet] = null;\n\n      if (_classPrivateFieldLooseBase(this, _isLogged)[_isLogged]) {\n        _classPrivateFieldLooseBase(this, _qmLog)[_qmLog] = [];\n        _classPrivateFieldLooseBase(this, _pmLog)[_pmLog] = [];\n      }\n\n      _classPrivateFieldLooseBase(this, _reduce)[_reduce]();\n\n      _classPrivateFieldLooseBase(this, _buildTruthTable)[_buildTruthTable]();\n\n      return true;\n    };\n\n    Object.defineProperty(this, _reduce, {\n      writable: true,\n      value: () => {\n        let nonEssentialPrimeImps = QMFuncs.getPrimeImplicants(_classPrivateFieldLooseBase(this, _minTerms)[_minTerms], _classPrivateFieldLooseBase(this, _dontCares)[_dontCares], _classPrivateFieldLooseBase(this, _qmLog)[_qmLog]);\n        _classPrivateFieldLooseBase(this, _petrickSOP)[_petrickSOP] = PMFuncs.getPetrickSOP(nonEssentialPrimeImps, _classPrivateFieldLooseBase(this, _minTerms)[_minTerms], _classPrivateFieldLooseBase(this, _pmLog)[_pmLog]);\n        _classPrivateFieldLooseBase(this, _primeImps)[_primeImps] = QMFuncs.getEssentialTerms(nonEssentialPrimeImps, _classPrivateFieldLooseBase(this, _minTerms)[_minTerms]);\n      }\n    });\n    Object.defineProperty(this, _buildTruthTable, {\n      writable: true,\n      value: () => {\n        let varRow = [\"#\"];\n\n        for (let i = 0; i < 26; i++) {\n          if (_classPrivateFieldLooseBase(this, _varBitSet)[_varBitSet].get(i) === 0) continue;\n          varRow.push(String.fromCharCode(i + 65));\n        }\n\n        varRow.push(\"f\");\n      }\n    });\n\n    this.toString = () => {\n      if (_classPrivateFieldLooseBase(this, _expression)[_expression]) return _classPrivateFieldLooseBase(this, _expression)[_expression];\n      let str = \"m(\";\n\n      for (const term of _classPrivateFieldLooseBase(this, _minTerms)[_minTerms]) str += parseInt(term) + \" \";\n\n      str = str.substr(0, str.length - 1) + \")\";\n\n      if (_classPrivateFieldLooseBase(this, _dontCares)[_dontCares].length) {\n        str += \"+d(\";\n\n        for (const term of _classPrivateFieldLooseBase(this, _dontCares)[_dontCares]) str += parseInt(term) + \" \";\n\n        str = str.substr(0, str.length - 1) + \")\";\n      }\n\n      return str;\n    };\n\n    if (!_expression2 && !_minTerms2 && !_dontCares2) {\n      throw \"null expression\";\n    }\n\n    _classPrivateFieldLooseBase(this, _minTerms)[_minTerms] = _minTerms2;\n    _classPrivateFieldLooseBase(this, _dontCares)[_dontCares] = _dontCares2;\n    _classPrivateFieldLooseBase(this, _expression)[_expression] = _expression2;\n    _classPrivateFieldLooseBase(this, _isLogged)[_isLogged] = true;\n\n    let _success;\n\n    if (_expression2) _success = this.setExpression(_expression2);else _success = this.setMinTerms(_minTerms2, _dontCares2);\n\n    if (!_success) {\n      if (_classPrivateFieldLooseBase(this, _errorCode)[_errorCode] == -1) throw \"cannot have 0 minimum terms\";else if (_classPrivateFieldLooseBase(this, _errorCode)[_errorCode] >= 0) throw parseInt(_classPrivateFieldLooseBase(this, _errorCode)[_errorCode]) + \" cannot be both a min term and a don't care\";else throw \"expression is not valid\";\n    }\n  }\n\n  static ExpressionInstance(expression, isLogged = false) {\n    return new BoolExpression(expression, null, null, isLogged);\n  }\n\n  static MinTermInstance(minTerms, dontCares, isLogged = false) {\n    return new BoolExpression(null, minTerms, dontCares, isLogged);\n  }\n\n  isEssentialImplicant(qmTerm) {\n    return _classPrivateFieldLooseBase(this, _primeImps)[_primeImps].some(e => QMFuncs.isQMTermEqual(qmTerm, e));\n  }\n\n  isMinTerm(intTerm) {\n    return _classPrivateFieldLooseBase(this, _minTerms)[_minTerms].includes(intTerm);\n  }\n\n  isDontCare(intTerm) {\n    return _classPrivateFieldLooseBase(this, _dontCares)[_dontCares].includes(intTerm);\n  }\n\n}\nObject.defineProperty(BoolExpression, _BOOL_GRAMMAR, {\n  writable: true,\n  value: buildBoolGrammar()\n});","map":{"version":3,"sources":["C:/Users/Andrew/Documents/JavaScript Projects/bool-simp/src/scripts/BooleanSimplifier/BoolExpression.js"],"names":["buildBoolGrammar","deepCopy","validateTerms","getVarBitSet","calculateMinTerms","QMFuncs","PMFuncs","Recognizer","Parser","BoolExpression","constructor","expression","minTerms","dontCares","isLogged","getMinTerms","getDontCares","getPetrickSOP","getEssentialImplicants","getVarCount","getQMLog","getPMLog","getTruthTable","getPrimeImpStrings","piStrs","implicant","str","extractMinTerms","term","parseInt","substring","length","toString","push","getSOPStrings","sopStrs","product","mapProductToString","productToString","setExpression","sSet","buildItems","invertedS","invertEarleySets","parseTree","buildParseTree","cardinality","parsed","parseString","validated","errorCode","getVariableCount","setMinTerms","success","nonEssentialPrimeImps","getPrimeImplicants","getEssentialTerms","varRow","i","get","String","fromCharCode","substr","ExpressionInstance","MinTermInstance","isEssentialImplicant","qmTerm","some","e","isQMTermEqual","isMinTerm","intTerm","includes","isDontCare"],"mappings":";;AAAA,SACIA,gBADJ,EAEIC,QAFJ,EAGIC,aAHJ,EAIIC,YAJJ,EAKIC,iBALJ,QAMO,uBANP;AAOA,OAAOC,OAAP,MAAoB,eAApB;AACA,OAAOC,OAAP,MAAoB,eAApB;AACA,OAAOC,UAAP,MAAuB,mCAAvB;AACA,OAAOC,MAAP,MAAmB,+BAAnB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,eAAe,MAAMC,cAAN,CAAqB;AAuBhCC,EAAAA,WAAW,CAACC,YAAD,EAAaC,UAAb,EAAuBC,WAAvB,EAAkCC,QAAQ,GAAG,KAA7C,EAAoD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,aAVlD,CAAC;AAUiD;AAAA;AAAA;AAAA,aATnD;AASmD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,SAiC/DC,WAjC+D,GAiCjD,MAAMd,QAAQ,6BAAC,IAAD,wBAjCmC;;AAAA,SAkC/De,YAlC+D,GAkChD,MAAMf,QAAQ,6BAAC,IAAD,0BAlCkC;;AAAA,SAmC/DgB,aAnC+D,GAmC/C,MAAMhB,QAAQ,6BAAC,IAAD,4BAnCiC;;AAAA,SAoC/DiB,sBApC+D,GAoCtC,MAAMjB,QAAQ,6BAAC,IAAD,0BApCwB;;AAAA,SAqC/DkB,WArC+D,GAqCjD,kCAAM,IAAN,uBArCiD;;AAAA,SAuC/DC,QAvC+D,GAuCpD,MAAO,0DAAiBnB,QAAQ,6BAAC,IAAD,kBAAzB,GAAyC,EAvCI;;AAAA,SAwC/DoB,QAxC+D,GAwCpD,MAAO,0DAAiBpB,QAAQ,6BAAC,IAAD,kBAAzB,GAAyC,EAxCI;;AAAA,SA0C/DqB,aA1C+D,GA0C/C,MAAMrB,QAAQ,6BAAC,IAAD,4BA1CiC;;AAAA,SA4C/DsB,kBA5C+D,GA4C1C,MAAM;AACvB,UAAIC,MAAM,GAAG,EAAb;;AACA,WAAK,MAAMC,SAAX,gCAAwB,IAAxB,2BAAyC;AACrC,YAAIC,GAAG,GAAG,GAAV;AACA,YAAId,QAAQ,GAAGP,OAAO,CAACsB,eAAR,CAAwBF,SAAxB,CAAf;;AACA,aAAK,MAAMG,IAAX,IAAmBhB,QAAnB,EAA6Bc,GAAG,IAAIG,QAAQ,CAACD,IAAD,CAAR,GAAiB,GAAxB;;AAC7BF,QAAAA,GAAG,GAAGA,GAAG,CAACI,SAAJ,CAAc,CAAd,EAAiBJ,GAAG,CAACK,MAAJ,GAAa,CAA9B,IAAmC,IAAzC;AACAL,QAAAA,GAAG,IAAIrB,OAAO,CAAC2B,QAAR,CAAiBP,SAAjB,8BAA4B,IAA5B,wBAAP;AACAD,QAAAA,MAAM,CAACS,IAAP,CAAYP,GAAZ;AACH;;AACD,aAAOF,MAAP;AACH,KAvD8D;;AAAA,SAyD/DU,aAzD+D,GAyD/C,MAAM;AAClB,UAAIC,OAAO,GAAG,EAAd;;AACA,WAAK,MAAMC,OAAX,gCAAsB,IAAtB,6BAAwC;AACpC,wCAAI,IAAJ,2BACID,OAAO,CAACF,IAAR,CAAa3B,OAAO,CAAC+B,kBAAR,CAA2BD,OAA3B,8BAAoC,IAApC,0BAAb,EADJ,KAEKD,OAAO,CAACF,IAAR,CAAa3B,OAAO,CAACgC,eAAR,CAAwBF,OAAxB,8BAAiC,IAAjC,wBAAb;AACR;;AACD,aAAOD,OAAP;AACH,KAjE8D;;AAAA,SAmE/DI,aAnE+D,GAmE9C5B,UAAD,IAAgB;AAC5B,UAAI6B,IAAI,GAAGjC,UAAU,CAACkC,UAAX,CAAsB9B,UAAtB,8BAAkCF,cAAlC,gCAAX;AACA,UAAIiC,SAAS,GAAGlC,MAAM,CAACmC,gBAAP,CAAwBH,IAAxB,8BAA8B/B,cAA9B,gCAAhB;AACA,UAAImC,SAAS,GAAGpC,MAAM,CAACqC,cAAP,CACZlC,UADY,EAEZ+B,SAFY,8BAGZjC,cAHY,gCAAhB;;AAMA,UAAImC,SAAS,KAAK,IAAlB,EAAwB;AACpB,0DAAaJ,IAAb;AACA,oEAAkBE,SAAlB;AACA,oEAAkBE,SAAlB;AAEA,oEAAkBzC,YAAY,CAACQ,UAAD,CAA9B;AACA,kEAAiB,0DAAgBmC,WAAhB,EAAjB;AACA,kEAAiB1C,iBAAiB,CAACO,UAAD,EAAaiC,SAAb,8BAAwB,IAAxB,0BAAlC;AACH,OARD,MAQO;AACH,YAAI,CAACG,MAAD,EAASnC,QAAT,EAAmBC,SAAnB,IAAgCR,OAAO,CAAC2C,WAAR,CAAoBrC,UAApB,CAApC;;AACA,YAAI,CAACoC,MAAL,EAAa;AACT,sEAAkB,CAAC,CAAnB;AACA,iBAAO,KAAP;AACH;;AAED,YAAI,CAACE,SAAD,EAAYC,SAAZ,IAAyBhD,aAAa,CAACU,QAAD,EAAWC,SAAX,CAA1C;;AACA,YAAI,CAACoC,SAAL,EAAgB;AACZ,sEAAkBC,SAAlB;AACA,iBAAO,KAAP;AACH;;AAED,kEAAiB7C,OAAO,CAAC8C,gBAAR,CAAyBvC,QAAzB,EAAmCC,SAAnC,CAAjB;AACA,kEAAiBD,QAAjB;AACA,oEAAkBC,SAAlB;AACH;;AAED,sCAAI,IAAJ,yBAAoB;AAChB,4DAAc,EAAd;AACA,4DAAc,EAAd;AACH;;AAED;;AACA;;AAEA,aAAO,IAAP;AACH,KA/G8D;;AAAA,SAiH/DuC,WAjH+D,GAiHjD,CAACxC,QAAD,EAAWC,SAAX,KAAyB;AACnC,UAAI,CAACwC,OAAD,EAAUH,SAAV,IAAuBhD,aAAa,CAACU,QAAD,EAAWC,SAAX,CAAxC;;AACA,UAAI,CAACwC,OAAL,EAAc;AACV,oEAAkBH,SAAlB;AACA,eAAO,KAAP;AACH;;AAED,gEAAiBtC,QAAjB;AACA,kEAAkBC,SAAlB;AACA,gEAAiBR,OAAO,CAAC8C,gBAAR,CAAyBvC,QAAzB,EAAmCC,SAAnC,CAAjB;AAEA,wDAAa,IAAb;AACA,WAAKF,UAAL,GAAkB,IAAlB;AACA,kEAAkB,IAAlB;AACA,kEAAkB,IAAlB;AACA,kEAAkB,IAAlB;;AAEA,sCAAI,IAAJ,yBAAoB;AAChB,4DAAc,EAAd;AACA,4DAAc,EAAd;AACH;;AAED;;AACA;;AAEA,aAAO,IAAP;AACH,KA3I8D;;AAAA;AAAA;AAAA,aA6IrD,MAAM;AACZ,YAAI2C,qBAAqB,GAAGjD,OAAO,CAACkD,kBAAR,6BACxB,IADwB,qDAExB,IAFwB,uDAGxB,IAHwB,kBAA5B;AAMA,sEAAmBjD,OAAO,CAACW,aAAR,CACfqC,qBADe,8BAEf,IAFe,qDAGf,IAHe,kBAAnB;AAMA,oEAAkBjD,OAAO,CAACmD,iBAAR,CACdF,qBADc,8BAEd,IAFc,wBAAlB;AAIH;AA9J8D;AAAA;AAAA;AAAA,aAgK5C,MAAM;AACrB,YAAIG,MAAM,GAAG,CAAC,GAAD,CAAb;;AACA,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,EAApB,EAAwBA,CAAC,EAAzB,EAA6B;AACzB,cAAI,0DAAgBC,GAAhB,CAAoBD,CAApB,MAA2B,CAA/B,EAAkC;AAClCD,UAAAA,MAAM,CAACxB,IAAP,CAAY2B,MAAM,CAACC,YAAP,CAAoBH,CAAC,GAAG,EAAxB,CAAZ;AACH;;AACDD,QAAAA,MAAM,CAACxB,IAAP,CAAY,GAAZ;AAEH;AAxK8D;;AAAA,SA0K/DD,QA1K+D,GA0KpD,MAAM;AACb,sCAAI,IAAJ,6BAAsB,mCAAO,IAAP;AAEtB,UAAIN,GAAG,GAAG,IAAV;;AACA,WAAK,MAAME,IAAX,gCAAmB,IAAnB,yBAAmCF,GAAG,IAAIG,QAAQ,CAACD,IAAD,CAAR,GAAiB,GAAxB;;AACnCF,MAAAA,GAAG,GAAGA,GAAG,CAACoC,MAAJ,CAAW,CAAX,EAAcpC,GAAG,CAACK,MAAJ,GAAa,CAA3B,IAAgC,GAAtC;;AAEA,UAAI,0DAAgBA,MAApB,EAA4B;AACxBL,QAAAA,GAAG,IAAI,KAAP;;AACA,aAAK,MAAME,IAAX,gCAAmB,IAAnB,2BAAoCF,GAAG,IAAIG,QAAQ,CAACD,IAAD,CAAR,GAAiB,GAAxB;;AACpCF,QAAAA,GAAG,GAAGA,GAAG,CAACoC,MAAJ,CAAW,CAAX,EAAcpC,GAAG,CAACK,MAAJ,GAAa,CAA3B,IAAgC,GAAtC;AACH;;AAED,aAAOL,GAAP;AACH,KAxL8D;;AAC3D,QAAI,CAACf,YAAD,IAAe,CAACC,UAAhB,IAA4B,CAACC,WAAjC,EAA4C;AACxC,YAAM,iBAAN;AACH;;AAED,8DAAiBD,UAAjB;AACA,gEAAkBC,WAAlB;AACA,kEAAmBF,YAAnB;AACA,8DAAiB,IAAjB;;AAEA,QAAI0C,QAAJ;;AACA,QAAI1C,YAAJ,EAAgB0C,QAAO,GAAG,KAAKd,aAAL,CAAmB5B,YAAnB,CAAV,CAAhB,KACK0C,QAAO,GAAG,KAAKD,WAAL,CAAiBxC,UAAjB,EAA2BC,WAA3B,CAAV;;AAEL,QAAI,CAACwC,QAAL,EAAc;AACV,UAAI,6DAAmB,CAAC,CAAxB,EAA2B,MAAM,6BAAN,CAA3B,KACK,IAAI,6DAAmB,CAAvB,EACD,MACIxB,QAAQ,6BAAC,IAAD,0BAAR,GACA,6CAFJ,CADC,KAKA,MAAM,yBAAN;AACR;AACJ;;AAEwB,SAAlBkC,kBAAkB,CAACpD,UAAD,EAAaG,QAAQ,GAAG,KAAxB,EAA+B;AACpD,WAAO,IAAIL,cAAJ,CAAmBE,UAAnB,EAA+B,IAA/B,EAAqC,IAArC,EAA2CG,QAA3C,CAAP;AACH;;AAEqB,SAAfkD,eAAe,CAACpD,QAAD,EAAWC,SAAX,EAAsBC,QAAQ,GAAG,KAAjC,EAAwC;AAC1D,WAAO,IAAIL,cAAJ,CAAmB,IAAnB,EAAyBG,QAAzB,EAAmCC,SAAnC,EAA8CC,QAA9C,CAAP;AACH;;AA2JDmD,EAAAA,oBAAoB,CAACC,MAAD,EAAS;AACzB,WAAO,0DAAgBC,IAAhB,CAAsBC,CAAD,IAAO/D,OAAO,CAACgE,aAAR,CAAsBH,MAAtB,EAA8BE,CAA9B,CAA5B,CAAP;AACH;;AAEDE,EAAAA,SAAS,CAACC,OAAD,EAAU;AACf,WAAO,wDAAeC,QAAf,CAAwBD,OAAxB,CAAP;AACH;;AAEDE,EAAAA,UAAU,CAACF,OAAD,EAAU;AAChB,WAAO,0DAAgBC,QAAhB,CAAyBD,OAAzB,CAAP;AACH;;AA3N+B;sBAAf9D,c;;SAqBMT,gBAAgB","sourcesContent":["import {\r\n    buildBoolGrammar,\r\n    deepCopy,\r\n    validateTerms,\r\n    getVarBitSet,\r\n    calculateMinTerms,\r\n} from \"./BoolExpressionUtils\";\r\nimport QMFuncs from \"./QMFunctions\";\r\nimport PMFuncs from \"./PMFunctions\";\r\nimport Recognizer from \"../Earley Parser/EarleyRecognizer\";\r\nimport Parser from \"../Earley Parser/EarleyParser\";\r\n\r\nexport default class BoolExpression {\r\n    #varCount;\r\n    #minTerms;\r\n    #dontCares;\r\n    #primeImps;\r\n    #petrickSOP;\r\n\r\n    #sSet;\r\n    #invertedS;\r\n    #parseTree;\r\n    #varBitSet;\r\n    #expression;\r\n\r\n    #errorCode = -2;\r\n    #isLogged = false;\r\n\r\n    #qmLog;\r\n    #pmLog;\r\n\r\n    #truthTable;\r\n\r\n    static #BOOL_GRAMMAR = buildBoolGrammar();\r\n\r\n    constructor(expression, minTerms, dontCares, isLogged = false) {\r\n        if (!expression && !minTerms && !dontCares) {\r\n            throw \"null expression\";\r\n        }\r\n\r\n        this.#minTerms = minTerms;\r\n        this.#dontCares = dontCares;\r\n        this.#expression = expression;\r\n        this.#isLogged = true;\r\n\r\n        let success;\r\n        if (expression) success = this.setExpression(expression);\r\n        else success = this.setMinTerms(minTerms, dontCares);\r\n\r\n        if (!success) {\r\n            if (this.#errorCode == -1) throw \"cannot have 0 minimum terms\";\r\n            else if (this.#errorCode >= 0)\r\n                throw (\r\n                    parseInt(this.#errorCode) +\r\n                    \" cannot be both a min term and a don't care\"\r\n                );\r\n            else throw \"expression is not valid\";\r\n        }\r\n    }\r\n\r\n    static ExpressionInstance(expression, isLogged = false) {\r\n        return new BoolExpression(expression, null, null, isLogged);\r\n    }\r\n\r\n    static MinTermInstance(minTerms, dontCares, isLogged = false) {\r\n        return new BoolExpression(null, minTerms, dontCares, isLogged);\r\n    }\r\n\r\n    getMinTerms = () => deepCopy(this.#minTerms);\r\n    getDontCares = () => deepCopy(this.#dontCares);\r\n    getPetrickSOP = () => deepCopy(this.#petrickSOP);\r\n    getEssentialImplicants = () => deepCopy(this.#primeImps);\r\n    getVarCount = () => this.#varCount;\r\n\r\n    getQMLog = () => (this.#isLogged ? deepCopy(this.#qmLog) : []);\r\n    getPMLog = () => (this.#isLogged ? deepCopy(this.#pmLog) : []);\r\n\r\n    getTruthTable = () => deepCopy(this.#truthTable);\r\n\r\n    getPrimeImpStrings = () => {\r\n        let piStrs = [];\r\n        for (const implicant of this.#primeImps) {\r\n            let str = \"[\";\r\n            let minTerms = QMFuncs.extractMinTerms(implicant);\r\n            for (const term of minTerms) str += parseInt(term) + \"-\";\r\n            str = str.substring(0, str.length - 1) + \"] \";\r\n            str += QMFuncs.toString(implicant, this.#varCount);\r\n            piStrs.push(str);\r\n        }\r\n        return piStrs;\r\n    };\r\n\r\n    getSOPStrings = () => {\r\n        let sopStrs = [];\r\n        for (const product of this.#petrickSOP) {\r\n            if (this.#varBitSet)\r\n                sopStrs.push(PMFuncs.mapProductToString(product, this.#varBitSet));\r\n            else sopStrs.push(PMFuncs.productToString(product, this.#varCount));\r\n        }\r\n        return sopStrs;\r\n    };\r\n\r\n    setExpression = (expression) => {\r\n        let sSet = Recognizer.buildItems(expression, BoolExpression.#BOOL_GRAMMAR);\r\n        let invertedS = Parser.invertEarleySets(sSet, BoolExpression.#BOOL_GRAMMAR);\r\n        let parseTree = Parser.buildParseTree(\r\n            expression,\r\n            invertedS,\r\n            BoolExpression.#BOOL_GRAMMAR\r\n        );\r\n\r\n        if (parseTree !== null) {\r\n            this.#sSet = sSet;\r\n            this.#invertedS = invertedS;\r\n            this.#parseTree = parseTree;\r\n\r\n            this.#varBitSet = getVarBitSet(expression);\r\n            this.#varCount = this.#varBitSet.cardinality();\r\n            this.#minTerms = calculateMinTerms(expression, parseTree, this.#varBitSet);\r\n        } else {\r\n            let [parsed, minTerms, dontCares] = QMFuncs.parseString(expression);\r\n            if (!parsed) {\r\n                this.#errorCode = -2;\r\n                return false;\r\n            }\r\n\r\n            let [validated, errorCode] = validateTerms(minTerms, dontCares);\r\n            if (!validated) {\r\n                this.#errorCode = errorCode;\r\n                return false;\r\n            }\r\n\r\n            this.#varCount = QMFuncs.getVariableCount(minTerms, dontCares);\r\n            this.#minTerms = minTerms;\r\n            this.#dontCares = dontCares;\r\n        }\r\n\r\n        if (this.#isLogged) {\r\n            this.#qmLog = [];\r\n            this.#pmLog = [];\r\n        }\r\n\r\n        this.#reduce();\r\n        this.#buildTruthTable();\r\n\r\n        return true;\r\n    };\r\n\r\n    setMinTerms = (minTerms, dontCares) => {\r\n        let [success, errorCode] = validateTerms(minTerms, dontCares);\r\n        if (!success) {\r\n            this.#errorCode = errorCode;\r\n            return false;\r\n        }\r\n\r\n        this.#minTerms = minTerms;\r\n        this.#dontCares = dontCares;\r\n        this.#varCount = QMFuncs.getVariableCount(minTerms, dontCares);\r\n\r\n        this.#sSet = null;\r\n        this.expression = null;\r\n        this.#invertedS = null;\r\n        this.#parseTree = null;\r\n        this.#varBitSet = null;\r\n\r\n        if (this.#isLogged) {\r\n            this.#qmLog = [];\r\n            this.#pmLog = [];\r\n        }\r\n\r\n        this.#reduce();\r\n        this.#buildTruthTable();\r\n\r\n        return true;\r\n    };\r\n\r\n    #reduce = () => {\r\n        let nonEssentialPrimeImps = QMFuncs.getPrimeImplicants(\r\n            this.#minTerms,\r\n            this.#dontCares,\r\n            this.#qmLog\r\n        );\r\n\r\n        this.#petrickSOP = PMFuncs.getPetrickSOP(\r\n            nonEssentialPrimeImps,\r\n            this.#minTerms,\r\n            this.#pmLog\r\n        );\r\n\r\n        this.#primeImps = QMFuncs.getEssentialTerms(\r\n            nonEssentialPrimeImps,\r\n            this.#minTerms\r\n        );\r\n    };\r\n\r\n    #buildTruthTable = () => {\r\n        let varRow = [\"#\"];\r\n        for (let i = 0; i < 26; i++) {\r\n            if (this.#varBitSet.get(i) === 0) continue;\r\n            varRow.push(String.fromCharCode(i + 65));\r\n        }\r\n        varRow.push(\"f\");\r\n        \r\n    };\r\n\r\n    toString = () => {\r\n        if (this.#expression) return this.#expression;\r\n\r\n        let str = \"m(\";\r\n        for (const term of this.#minTerms) str += parseInt(term) + \" \";\r\n        str = str.substr(0, str.length - 1) + \")\";\r\n\r\n        if (this.#dontCares.length) {\r\n            str += \"+d(\";\r\n            for (const term of this.#dontCares) str += parseInt(term) + \" \";\r\n            str = str.substr(0, str.length - 1) + \")\";\r\n        }\r\n\r\n        return str;\r\n    };\r\n\r\n    isEssentialImplicant(qmTerm) {\r\n        return this.#primeImps.some((e) => QMFuncs.isQMTermEqual(qmTerm, e));\r\n    }\r\n\r\n    isMinTerm(intTerm) {\r\n        return this.#minTerms.includes(intTerm);\r\n    }\r\n\r\n    isDontCare(intTerm) {\r\n        return this.#dontCares.includes(intTerm);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}