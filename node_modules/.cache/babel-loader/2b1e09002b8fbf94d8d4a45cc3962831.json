{"ast":null,"code":"import { BOOL_GRAMMAR, BOOL_CALC_ACTIONS } from \"./BoolExpressionGrammar\";\nimport Recognizer from \"../Earley Parser/EarleyRecognizer\";\nimport Parser, { ParseNode } from \"../Earley Parser/EarleyParser\";\nimport BitSet from \"bitset.js\";\nimport { bnfGrammar, bnfActions, interpretBNF } from \"../Earley Parser/BNFInterpreter\";\nexport default function boolMain(expStr) {\n  /*try {\r\n      let exp = BoolExpression.ExpressionInstance(expStr, true);\r\n        console.log(\"Expression: \", exp.toString());\r\n      console.log(\"Min Terms: \", exp.getMinTerms());\r\n      console.log(\"Var Count: \", exp.getVarCount());\r\n      console.log(\"Prime Implicants: \", exp.getPrimeImplicants());\r\n      console.log(\"Petrick SOP: \", exp.getPetrickSOP());\r\n      // Print Prime Implicants\r\n      for (const implicant of exp.getPrimeImpStrings()) {\r\n          console.log(implicant);\r\n      }\r\n        let petrickSOP = exp.getSOPStrings();\r\n      for (let i = 0; i < petrickSOP.length; i++) {\r\n          console.log(\"Solution \", i + 1, \": \", petrickSOP[i]);\r\n      }\r\n        let test = exp.getQMLog();\r\n      console.log(\"QM Log: \", test);\r\n      console.log(\"PM Log: \", exp.getPMLog());\r\n  } catch (error) {\r\n      console.log(error);\r\n  }*/\n}\nexport function buildBoolGrammar() {\n  try {\n    let grammar = BOOL_GRAMMAR.replaceAll(\"\\\\n\", \"\\n\");\n    let s = Recognizer.buildItems(grammar, bnfGrammar);\n    let invertedS = Parser.invertEarleySets(s, bnfGrammar);\n    let parseTree = Parser.buildParseTree(grammar, invertedS, bnfGrammar);\n\n    if (parseTree === null) {\n      throw new Error(\"invalid grammar\");\n    }\n\n    let simplifiedTree = Parser.applySemanticAction(token => new ParseNode(-1, token), parseTree, bnfActions);\n    return interpretBNF(simplifiedTree);\n  } catch (error) {\n    console.log(error);\n    return null;\n  }\n}\nexport function calculateMinTerms(expStr, parseTree, varBitSet) {\n  let varCount = varBitSet.cardinality();\n  let minTerms = []; // array to be filled with minTerms\n\n  let rowCount = 2 ** varCount;\n\n  for (let i = rowCount - 1; i >= 0; i--) {\n    let normalizedVariables = BitSet(i);\n    let boolVal = calculateExpression(parseTree, varBitSet, normalizedVariables);\n    if (boolVal) minTerms.push(i);\n  }\n\n  return minTerms;\n}\n\nfunction calculateExpression(parseTree, varBitSet, normVars) {\n  let semanticActions = BOOL_CALC_ACTIONS.slice();\n  let varCount = varBitSet.cardinality();\n  let varPos = 0;\n\n  for (let i = 0; i < 26; i++) {\n    if (varBitSet.get(i) === 0) continue;\n    let bool = normVars.get(varCount - 1 - varPos++);\n\n    if (bool) {\n      semanticActions[i + semanticActions.length - 52] = () => true;\n\n      semanticActions[i + semanticActions.length - 26] = () => true;\n    } else {\n      semanticActions[i + semanticActions.length - 52] = () => false;\n\n      semanticActions[i + semanticActions.length - 26] = () => false;\n    }\n  }\n\n  return Parser.applySemanticAction(token => token, parseTree, semanticActions);\n}\n\nexport function validateTerms(minTerms, dontCares) {\n  if (minTerms.length === 0) return [false, -1];\n\n  for (const term of dontCares) if (minTerms.includes(term)) return [false, term];\n\n  return [true, -2];\n}\nexport function getVarBitSet(expStr) {\n  let variables = new BitSet();\n\n  for (let i = 0; i < expStr.length; i++) {\n    if (/[A-Z]/.test(expStr[i])) {\n      variables.set(expStr.charCodeAt(i) - 65, 1);\n    }\n  }\n\n  return variables;\n}\nexport function deepCopy(src) {\n  let target = Array.isArray(src) ? [] : {};\n\n  for (let key in src) {\n    let v = src[key];\n\n    if (v) {\n      if (typeof v === \"object\") {\n        target[key] = deepCopy(v);\n      } else {\n        target[key] = v;\n      }\n    } else {\n      target[key] = v;\n    }\n  }\n\n  return target;\n}","map":{"version":3,"sources":["C:/Users/Andrew/Documents/JavaScript Projects/bool-simp/src/scripts/BooleanSimplifier/BoolExpressionUtils.js"],"names":["BOOL_GRAMMAR","BOOL_CALC_ACTIONS","Recognizer","Parser","ParseNode","BitSet","bnfGrammar","bnfActions","interpretBNF","boolMain","expStr","buildBoolGrammar","grammar","replaceAll","s","buildItems","invertedS","invertEarleySets","parseTree","buildParseTree","Error","simplifiedTree","applySemanticAction","token","error","console","log","calculateMinTerms","varBitSet","varCount","cardinality","minTerms","rowCount","i","normalizedVariables","boolVal","calculateExpression","push","normVars","semanticActions","slice","varPos","get","bool","length","validateTerms","dontCares","term","includes","getVarBitSet","variables","test","set","charCodeAt","deepCopy","src","target","Array","isArray","key","v"],"mappings":"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","sourcesContent":["import { BOOL_GRAMMAR, BOOL_CALC_ACTIONS } from \"./BoolExpressionGrammar\";\r\nimport Recognizer from \"../Earley Parser/EarleyRecognizer\";\r\nimport Parser, { ParseNode } from \"../Earley Parser/EarleyParser\";\r\nimport BitSet from \"bitset.js\";\r\nimport { bnfGrammar, bnfActions, interpretBNF } from \"../Earley Parser/BNFInterpreter\";\r\n\r\nexport default function boolMain(expStr) {\r\n    /*try {\r\n        let exp = BoolExpression.ExpressionInstance(expStr, true);\r\n\r\n        console.log(\"Expression: \", exp.toString());\r\n        console.log(\"Min Terms: \", exp.getMinTerms());\r\n        console.log(\"Var Count: \", exp.getVarCount());\r\n        console.log(\"Prime Implicants: \", exp.getPrimeImplicants());\r\n        console.log(\"Petrick SOP: \", exp.getPetrickSOP());\r\n        // Print Prime Implicants\r\n        for (const implicant of exp.getPrimeImpStrings()) {\r\n            console.log(implicant);\r\n        }\r\n\r\n        let petrickSOP = exp.getSOPStrings();\r\n        for (let i = 0; i < petrickSOP.length; i++) {\r\n            console.log(\"Solution \", i + 1, \": \", petrickSOP[i]);\r\n        }\r\n\r\n        let test = exp.getQMLog();\r\n        console.log(\"QM Log: \", test);\r\n        console.log(\"PM Log: \", exp.getPMLog());\r\n    } catch (error) {\r\n        console.log(error);\r\n    }*/\r\n}\r\n\r\nexport function buildBoolGrammar() {\r\n    try {\r\n        let grammar = BOOL_GRAMMAR.replaceAll(\"\\\\n\", \"\\n\");\r\n        let s = Recognizer.buildItems(grammar, bnfGrammar);\r\n        let invertedS = Parser.invertEarleySets(s, bnfGrammar);\r\n        let parseTree = Parser.buildParseTree(grammar, invertedS, bnfGrammar);\r\n\r\n        if (parseTree === null) {\r\n            throw new Error(\"invalid grammar\");\r\n        }\r\n\r\n        let simplifiedTree = Parser.applySemanticAction(\r\n            (token) => new ParseNode(-1, token),\r\n            parseTree,\r\n            bnfActions\r\n        );\r\n\r\n        return interpretBNF(simplifiedTree);\r\n    } catch (error) {\r\n        console.log(error);\r\n        return null;\r\n    }\r\n}\r\n\r\nexport function calculateMinTerms(expStr, parseTree, varBitSet) {\r\n    let varCount = varBitSet.cardinality();\r\n    let minTerms = []; // array to be filled with minTerms\r\n    let rowCount = 2 ** varCount;\r\n\r\n    for (let i = rowCount - 1; i >= 0; i--) {\r\n        let normalizedVariables = BitSet(i);\r\n        let boolVal = calculateExpression(parseTree, varBitSet, normalizedVariables);\r\n        if (boolVal) minTerms.push(i);\r\n    }\r\n    return minTerms;\r\n}\r\n\r\nfunction calculateExpression(parseTree, varBitSet, normVars) {\r\n    let semanticActions = BOOL_CALC_ACTIONS.slice();\r\n    let varCount = varBitSet.cardinality();\r\n\r\n    let varPos = 0;\r\n    for (let i = 0; i < 26; i++) {\r\n        if (varBitSet.get(i) === 0) continue;\r\n        let bool = normVars.get(varCount - 1 - varPos++);\r\n        if (bool) {\r\n            semanticActions[i + semanticActions.length - 52] = () => true;\r\n            semanticActions[i + semanticActions.length - 26] = () => true;\r\n        } else {\r\n            semanticActions[i + semanticActions.length - 52] = () => false;\r\n            semanticActions[i + semanticActions.length - 26] = () => false;\r\n        }\r\n    }\r\n\r\n    return Parser.applySemanticAction((token) => token, parseTree, semanticActions);\r\n}\r\n\r\nexport function validateTerms(minTerms, dontCares) {\r\n    if (minTerms.length === 0) return [false, -1];\r\n    for (const term of dontCares) if (minTerms.includes(term)) return [false, term];\r\n    return [true, -2];\r\n}\r\n\r\nexport function getVarBitSet(expStr) {\r\n    let variables = new BitSet();\r\n    for (let i = 0; i < expStr.length; i++) {\r\n        if (/[A-Z]/.test(expStr[i])) {\r\n            variables.set(expStr.charCodeAt(i) - 65, 1);\r\n        }\r\n    }\r\n    return variables;\r\n}\r\n\r\nexport function deepCopy(src) {\r\n    let target = Array.isArray(src) ? [] : {};\r\n    for (let key in src) {\r\n        let v = src[key];\r\n        if (v) {\r\n            if (typeof v === \"object\") {\r\n                target[key] = deepCopy(v);\r\n            } else {\r\n                target[key] = v;\r\n            }\r\n        } else {\r\n            target[key] = v;\r\n        }\r\n    }\r\n\r\n    return target;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}