{"ast":null,"code":"import { Grammar, Rule } from \"./EarleyRecognizer\";\nimport { Terminal, NonTerminal } from \"./Symbol\";\nimport { ParseNode } from \"./EarleyParser\";\nexport const bnfGrammar = new Grammar(\"syntax\", [new Rule(\"syntax\", [new NonTerminal(\"rule\")]), new Rule(\"syntax\", [new NonTerminal(\"syntax\"), new NonTerminal(\"rule\")]), new Rule(\"rule\", [new NonTerminal(\"opt-whitespace\"), new Terminal(\"<\"), new NonTerminal(\"rule-name\"), new Terminal(\">\"), new NonTerminal(\"opt-whitespace\"), new Terminal(\":\"), new Terminal(\":\"), new Terminal(\"=\"), new NonTerminal(\"opt-whitespace\"), new NonTerminal(\"expression\"), new NonTerminal(\"line-end\")]), new Rule(\"opt-whitespace\", []), new Rule(\"opt-whitespace\", [new NonTerminal(\"opt-whitespace\"), new Terminal(\" \")]), new Rule(\"expression\", [new NonTerminal(\"list\")]), new Rule(\"expression\", [new NonTerminal(\"expression\"), new NonTerminal(\"opt-whitespace\"), new Terminal(\"|\"), new NonTerminal(\"opt-whitespace\"), new NonTerminal(\"list\")]), new Rule(\"line-end\", [new NonTerminal(\"opt-whitespace\"), new NonTerminal(\"EOL\")]), new Rule(\"line-end\", [new NonTerminal(\"line-end\"), new NonTerminal(\"line-end\")]), new Rule(\"EOL\", [new Terminal([\";\", \"\\n\", \"\\r\"])]), new Rule(\"list\", [new NonTerminal(\"term\")]), new Rule(\"list\", [new NonTerminal(\"list\"), new NonTerminal(\"opt-whitespace\"), new NonTerminal(\"term\")]), new Rule(\"term\", [new NonTerminal(\"terminal\")]), new Rule(\"term\", [new NonTerminal(\"non-terminal\")]), new Rule(\"non-terminal\", [new Terminal(\"<\"), new NonTerminal(\"rule-name\"), new Terminal(\">\")]), new Rule(\"terminal\", [new Terminal('\"'), new NonTerminal(\"text1\"), new Terminal('\"')]), new Rule(\"terminal\", [new Terminal(\"'\"), new NonTerminal(\"text2\"), new Terminal(\"'\")]), new Rule(\"text1\", []), // NULL\nnew Rule(\"text1\", [new NonTerminal(\"text1\"), new NonTerminal(\"character1\")]), new Rule(\"text2\", []), // NULL\nnew Rule(\"text2\", [new NonTerminal(\"text2\"), new NonTerminal(\"character2\")]), new Rule(\"character\", [new NonTerminal(\"letter\")]), new Rule(\"character\", [new NonTerminal(\"digit\")]), new Rule(\"character\", [new NonTerminal(\"symbol\")]), new Rule(\"digit\", [new Terminal([\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"])]), new Rule(\"character1\", [new NonTerminal(\"character\")]), new Rule(\"character1\", [new Terminal(\"'\")]), new Rule(\"character2\", [new NonTerminal(\"character\")]), new Rule(\"character2\", [new Terminal('\"')]), new Rule(\"rule-name\", [new NonTerminal(\"letter\")]), new Rule(\"rule-name\", [new NonTerminal(\"rule-name\"), new NonTerminal(\"rule-char\")]), new Rule(\"rule-char\", [new NonTerminal(\"letter\")]), new Rule(\"rule-char\", [new NonTerminal(\"digit\")]), new Rule(\"rule-char\", [new Terminal(\"-\")]), new Rule(\"letter\", [new Terminal([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"])]), new Rule(\"symbol\", [new Terminal([\"|\", \" \", \"!\", \"#\", \"$\", \"%\", \"&\", \"(\", \")\", \"*\", \"+\", \",\", \"-\", \".\", \"/\", \":\", \";\", \">\", \"=\", \"<\", \"?\", \"@\", \"[\", \"\\\\\", \"]\", \"^\", \"_\", \"`\", \"{\", \"}\", \"~\", \"\\n\", \"\\r\"])])]);\nexport const bnfActions = [rule => new ParseNode(0, \"syntax\", [rule]), (syntax, rule) => {\n  syntax.children.push(rule);\n  return syntax;\n}, (space1, lessThan, ruleName, greaterThan, space2, colon1, colon2, equal, space3, expression, lineEnd) => {\n  return new ParseNode(2, \"rule\", [ruleName, expression]);\n}, //new ParseNode(2, \"rule\", args),\n() => new ParseNode(3, \"opt-whitespace\"), (spaces, space) => {\n  if (spaces.rule === 3) return space;\n  spaces.label += space.label;\n  return spaces;\n}, //new ParseNode(4, \"opt-whitespace\", args),\nlist => new ParseNode(5, \"expression\", [list]), (expression, space1, orTerminal, space2, list) => {\n  //if (expression.rule === 5) {\n  expression.children.push(list);\n  return expression; //}\n  //return new ParseNode(6, \"expression\", [expression, list]);\n}, //new ParseNode(6, \"expression\", args),\n(optWhitespace, eol) => new ParseNode(7, \"line-end\", [eol]), (lineEnd1, lineEnd2) => new ParseNode(8, \"line-end\", lineEnd1.children.concat(lineEnd2.children)), eol => eol, term => new ParseNode(11, \"list\", [term]), (list, optWhitespace, term) => {\n  list.children.push(term);\n  list.rule = 12;\n  return list;\n}, terminal => terminal, //new ParseNode(12, \"term\", args),\nnonTerminal => nonTerminal, //new ParseNode(13, \"term\", args),\n(lessThan, ruleName, greaterThan) => new ParseNode(14, \"non-terminal\", [ruleName]), (doubleQuote1, text1, doubleQuote2) => new ParseNode(15, \"terminal\", [text1]), (singleQuote1, text2, singleQuote2) => new ParseNode(16, \"terminal\", [text2]), () => new ParseNode(17, \"null\"), (text1, character1) => {\n  if (text1.rule === 17) return character1;\n  text1.label += character1.label;\n  return text1;\n}, //new ParseNode(18, \"text1\", args),\n() => new ParseNode(19, \"null\"), (text2, character2) => {\n  if (text2.rule === 19) return character2;\n  text2.label += character2.label;\n  return text2;\n}, //new ParseNode(20, \"text2\", args),\nletter => letter, //new ParseNode(22, \"character\", args),\ndigit => digit, //new ParseNode(22, \"character\", args),\nsymbol => symbol, //new ParseNode(23, \"character\", args),\ndigit => digit, //new ParseNode(24, \"digit\", args),\ncharacter => character, //new ParseNode(25, \"character1\", args),\nsingleQuote => singleQuote, //new ParseNode(26, \"character1\", args),\ncharacter => character, //new ParseNode(27, \"character2\", args),\ndoubleQuote => doubleQuote, // new ParseNode(28, \"character2\", args),\nletter => letter, //new ParseNode(29, \"rule-name\", args),\n(ruleName, ruleChar) => {\n  ruleName.label += ruleChar.label;\n  return ruleName;\n}, //new ParseNode(30, \"rule-name\", args),\nletter => letter, //new ParseNode(31, \"rule-char\", args),\ndigit => digit, //new ParseNode(32, \"rule-char\", args),\ndash => dash, //new ParseNode(33, \"rule-char\", args),\nletter => letter, //new ParseNode(34, \"letter\", args),\nsymbol => symbol //new ParseNode(35, \"symbol\", args),\n];\nexport function interpretBNF(simplifiedParseTree) {\n  if (simplifiedParseTree === null || simplifiedParseTree === undefined) throw new Error(\"invalid parse tree\");\n  if (simplifiedParseTree.label !== \"syntax\") throw new Error(\"invalid parse tree\");\n  let newBNF = new Grammar(undefined, []);\n\n  for (const rule of simplifiedParseTree.children) {\n    if (rule.label !== \"rule\") throw new Error(\"invalid syntax\");\n    if (rule.children.length !== 2) throw new Error(\"invalid rule\");\n    if (rule.children[0].rule !== -1) throw new Error(\"invalid rule\");\n    if (rule.children[1].label !== \"expression\") throw new Error(\"invalid rule\");\n    let ruleName = rule.children[0].label;\n    if (newBNF.startRule === undefined) newBNF.startRule = ruleName;\n    let rules = interpretExpression(ruleName, rule.children[1]);\n    newBNF.rules = newBNF.rules.concat(rules);\n  }\n\n  return newBNF;\n} // returns array of Rules\n\nfunction interpretExpression(ruleName, expressionTree) {\n  const NULL1 = 17;\n  const NULL2 = 19;\n  let rules = [];\n  let hasNull = false;\n\n  for (const list of expressionTree.children) {\n    if (list.label !== \"list\") throw new Error(\"invalid expression\");\n    let ruleDef = [];\n\n    for (const symbol of list.children) {\n      if (symbol.children.length !== 1) throw new Error(\"invalid list\");\n      let symChild = symbol.children[0];\n\n      if (symbol.label === \"non-terminal\") {\n        if (symChild.rule !== -1) throw new Error(\"invalid non-terminal\");\n        ruleDef.push(new NonTerminal(symChild.label));\n      } else if (symbol.label === \"terminal\") {\n        if (symChild.rule === NULL1 || symChild.rule === NULL2) {\n          if (list.children.length > 1) {\n            if (hasNull === false) {\n              rules.push(new Rule(ruleName + \"-null\", []));\n              hasNull = true;\n            }\n\n            ruleDef.push(NonTerminal(ruleName + \"-null\"));\n          }\n        } else if (symChild.rule === -1) {\n          for (const c of symChild.label) {\n            ruleDef.push(new Terminal(c));\n          }\n        } else throw new Error(\"invalid terminal\");\n      } else throw new Error(\"invalid list\");\n    }\n\n    rules.push(new Rule(ruleName, ruleDef));\n  }\n\n  return rules;\n}","map":{"version":3,"sources":["C:/Users/Andrew/Documents/JavaScript Projects/bool-simp/src/scripts/Earley Parser/BNFInterpreter.js"],"names":["Grammar","Rule","Terminal","NonTerminal","ParseNode","bnfGrammar","bnfActions","rule","syntax","children","push","space1","lessThan","ruleName","greaterThan","space2","colon1","colon2","equal","space3","expression","lineEnd","spaces","space","label","list","orTerminal","optWhitespace","eol","lineEnd1","lineEnd2","concat","term","terminal","nonTerminal","doubleQuote1","text1","doubleQuote2","singleQuote1","text2","singleQuote2","character1","character2","letter","digit","symbol","character","singleQuote","doubleQuote","ruleChar","dash","interpretBNF","simplifiedParseTree","undefined","Error","newBNF","length","startRule","rules","interpretExpression","expressionTree","NULL1","NULL2","hasNull","ruleDef","symChild","c"],"mappings":"AAAA,SAASA,OAAT,EAAkBC,IAAlB,QAA8B,oBAA9B;AACA,SAASC,QAAT,EAAmBC,WAAnB,QAAsC,UAAtC;AACA,SAASC,SAAT,QAA0B,gBAA1B;AAEA,OAAO,MAAMC,UAAU,GAAG,IAAIL,OAAJ,CAAY,QAAZ,EAAsB,CAC5C,IAAIC,IAAJ,CAAS,QAAT,EAAmB,CAAC,IAAIE,WAAJ,CAAgB,MAAhB,CAAD,CAAnB,CAD4C,EAE5C,IAAIF,IAAJ,CAAS,QAAT,EAAmB,CAAC,IAAIE,WAAJ,CAAgB,QAAhB,CAAD,EAA4B,IAAIA,WAAJ,CAAgB,MAAhB,CAA5B,CAAnB,CAF4C,EAI5C,IAAIF,IAAJ,CAAS,MAAT,EAAiB,CACb,IAAIE,WAAJ,CAAgB,gBAAhB,CADa,EAEb,IAAID,QAAJ,CAAa,GAAb,CAFa,EAGb,IAAIC,WAAJ,CAAgB,WAAhB,CAHa,EAIb,IAAID,QAAJ,CAAa,GAAb,CAJa,EAKb,IAAIC,WAAJ,CAAgB,gBAAhB,CALa,EAMb,IAAID,QAAJ,CAAa,GAAb,CANa,EAOb,IAAIA,QAAJ,CAAa,GAAb,CAPa,EAQb,IAAIA,QAAJ,CAAa,GAAb,CARa,EASb,IAAIC,WAAJ,CAAgB,gBAAhB,CATa,EAUb,IAAIA,WAAJ,CAAgB,YAAhB,CAVa,EAWb,IAAIA,WAAJ,CAAgB,UAAhB,CAXa,CAAjB,CAJ4C,EAkB5C,IAAIF,IAAJ,CAAS,gBAAT,EAA2B,EAA3B,CAlB4C,EAmB5C,IAAIA,IAAJ,CAAS,gBAAT,EAA2B,CAAC,IAAIE,WAAJ,CAAgB,gBAAhB,CAAD,EAAoC,IAAID,QAAJ,CAAa,GAAb,CAApC,CAA3B,CAnB4C,EAqB5C,IAAID,IAAJ,CAAS,YAAT,EAAuB,CAAC,IAAIE,WAAJ,CAAgB,MAAhB,CAAD,CAAvB,CArB4C,EAsB5C,IAAIF,IAAJ,CAAS,YAAT,EAAuB,CACnB,IAAIE,WAAJ,CAAgB,YAAhB,CADmB,EAEnB,IAAIA,WAAJ,CAAgB,gBAAhB,CAFmB,EAGnB,IAAID,QAAJ,CAAa,GAAb,CAHmB,EAInB,IAAIC,WAAJ,CAAgB,gBAAhB,CAJmB,EAKnB,IAAIA,WAAJ,CAAgB,MAAhB,CALmB,CAAvB,CAtB4C,EA8B5C,IAAIF,IAAJ,CAAS,UAAT,EAAqB,CAAC,IAAIE,WAAJ,CAAgB,gBAAhB,CAAD,EAAoC,IAAIA,WAAJ,CAAgB,KAAhB,CAApC,CAArB,CA9B4C,EA+B5C,IAAIF,IAAJ,CAAS,UAAT,EAAqB,CAAC,IAAIE,WAAJ,CAAgB,UAAhB,CAAD,EAA8B,IAAIA,WAAJ,CAAgB,UAAhB,CAA9B,CAArB,CA/B4C,EAiC5C,IAAIF,IAAJ,CAAS,KAAT,EAAgB,CAAC,IAAIC,QAAJ,CAAa,CAAC,GAAD,EAAM,IAAN,EAAY,IAAZ,CAAb,CAAD,CAAhB,CAjC4C,EAmC5C,IAAID,IAAJ,CAAS,MAAT,EAAiB,CAAC,IAAIE,WAAJ,CAAgB,MAAhB,CAAD,CAAjB,CAnC4C,EAoC5C,IAAIF,IAAJ,CAAS,MAAT,EAAiB,CACb,IAAIE,WAAJ,CAAgB,MAAhB,CADa,EAEb,IAAIA,WAAJ,CAAgB,gBAAhB,CAFa,EAGb,IAAIA,WAAJ,CAAgB,MAAhB,CAHa,CAAjB,CApC4C,EA0C5C,IAAIF,IAAJ,CAAS,MAAT,EAAiB,CAAC,IAAIE,WAAJ,CAAgB,UAAhB,CAAD,CAAjB,CA1C4C,EA2C5C,IAAIF,IAAJ,CAAS,MAAT,EAAiB,CAAC,IAAIE,WAAJ,CAAgB,cAAhB,CAAD,CAAjB,CA3C4C,EA6C5C,IAAIF,IAAJ,CAAS,cAAT,EAAyB,CACrB,IAAIC,QAAJ,CAAa,GAAb,CADqB,EAErB,IAAIC,WAAJ,CAAgB,WAAhB,CAFqB,EAGrB,IAAID,QAAJ,CAAa,GAAb,CAHqB,CAAzB,CA7C4C,EAmD5C,IAAID,IAAJ,CAAS,UAAT,EAAqB,CACjB,IAAIC,QAAJ,CAAa,GAAb,CADiB,EAEjB,IAAIC,WAAJ,CAAgB,OAAhB,CAFiB,EAGjB,IAAID,QAAJ,CAAa,GAAb,CAHiB,CAArB,CAnD4C,EAwD5C,IAAID,IAAJ,CAAS,UAAT,EAAqB,CACjB,IAAIC,QAAJ,CAAa,GAAb,CADiB,EAEjB,IAAIC,WAAJ,CAAgB,OAAhB,CAFiB,EAGjB,IAAID,QAAJ,CAAa,GAAb,CAHiB,CAArB,CAxD4C,EA8D5C,IAAID,IAAJ,CAAS,OAAT,EAAkB,EAAlB,CA9D4C,EA8DrB;AACvB,IAAIA,IAAJ,CAAS,OAAT,EAAkB,CAAC,IAAIE,WAAJ,CAAgB,OAAhB,CAAD,EAA2B,IAAIA,WAAJ,CAAgB,YAAhB,CAA3B,CAAlB,CA/D4C,EAiE5C,IAAIF,IAAJ,CAAS,OAAT,EAAkB,EAAlB,CAjE4C,EAiErB;AACvB,IAAIA,IAAJ,CAAS,OAAT,EAAkB,CAAC,IAAIE,WAAJ,CAAgB,OAAhB,CAAD,EAA2B,IAAIA,WAAJ,CAAgB,YAAhB,CAA3B,CAAlB,CAlE4C,EAoE5C,IAAIF,IAAJ,CAAS,WAAT,EAAsB,CAAC,IAAIE,WAAJ,CAAgB,QAAhB,CAAD,CAAtB,CApE4C,EAqE5C,IAAIF,IAAJ,CAAS,WAAT,EAAsB,CAAC,IAAIE,WAAJ,CAAgB,OAAhB,CAAD,CAAtB,CArE4C,EAsE5C,IAAIF,IAAJ,CAAS,WAAT,EAAsB,CAAC,IAAIE,WAAJ,CAAgB,QAAhB,CAAD,CAAtB,CAtE4C,EAwE5C,IAAIF,IAAJ,CAAS,OAAT,EAAkB,CAAC,IAAIC,QAAJ,CAAa,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,GAAhB,EAAqB,GAArB,EAA0B,GAA1B,EAA+B,GAA/B,EAAoC,GAApC,EAAyC,GAAzC,EAA8C,GAA9C,CAAb,CAAD,CAAlB,CAxE4C,EA0E5C,IAAID,IAAJ,CAAS,YAAT,EAAuB,CAAC,IAAIE,WAAJ,CAAgB,WAAhB,CAAD,CAAvB,CA1E4C,EA2E5C,IAAIF,IAAJ,CAAS,YAAT,EAAuB,CAAC,IAAIC,QAAJ,CAAa,GAAb,CAAD,CAAvB,CA3E4C,EA6E5C,IAAID,IAAJ,CAAS,YAAT,EAAuB,CAAC,IAAIE,WAAJ,CAAgB,WAAhB,CAAD,CAAvB,CA7E4C,EA8E5C,IAAIF,IAAJ,CAAS,YAAT,EAAuB,CAAC,IAAIC,QAAJ,CAAa,GAAb,CAAD,CAAvB,CA9E4C,EAgF5C,IAAID,IAAJ,CAAS,WAAT,EAAsB,CAAC,IAAIE,WAAJ,CAAgB,QAAhB,CAAD,CAAtB,CAhF4C,EAiF5C,IAAIF,IAAJ,CAAS,WAAT,EAAsB,CAAC,IAAIE,WAAJ,CAAgB,WAAhB,CAAD,EAA+B,IAAIA,WAAJ,CAAgB,WAAhB,CAA/B,CAAtB,CAjF4C,EAmF5C,IAAIF,IAAJ,CAAS,WAAT,EAAsB,CAAC,IAAIE,WAAJ,CAAgB,QAAhB,CAAD,CAAtB,CAnF4C,EAoF5C,IAAIF,IAAJ,CAAS,WAAT,EAAsB,CAAC,IAAIE,WAAJ,CAAgB,OAAhB,CAAD,CAAtB,CApF4C,EAqF5C,IAAIF,IAAJ,CAAS,WAAT,EAAsB,CAAC,IAAIC,QAAJ,CAAa,GAAb,CAAD,CAAtB,CArF4C,EAuF5C,IAAID,IAAJ,CAAS,QAAT,EAAmB,CACf,IAAIC,QAAJ,CAAa,CACT,GADS,EAET,GAFS,EAGT,GAHS,EAIT,GAJS,EAKT,GALS,EAMT,GANS,EAOT,GAPS,EAQT,GARS,EAST,GATS,EAUT,GAVS,EAWT,GAXS,EAYT,GAZS,EAaT,GAbS,EAcT,GAdS,EAeT,GAfS,EAgBT,GAhBS,EAiBT,GAjBS,EAkBT,GAlBS,EAmBT,GAnBS,EAoBT,GApBS,EAqBT,GArBS,EAsBT,GAtBS,EAuBT,GAvBS,EAwBT,GAxBS,EAyBT,GAzBS,EA0BT,GA1BS,EA2BT,GA3BS,EA4BT,GA5BS,EA6BT,GA7BS,EA8BT,GA9BS,EA+BT,GA/BS,EAgCT,GAhCS,EAiCT,GAjCS,EAkCT,GAlCS,EAmCT,GAnCS,EAoCT,GApCS,EAqCT,GArCS,EAsCT,GAtCS,EAuCT,GAvCS,EAwCT,GAxCS,EAyCT,GAzCS,EA0CT,GA1CS,EA2CT,GA3CS,EA4CT,GA5CS,EA6CT,GA7CS,EA8CT,GA9CS,EA+CT,GA/CS,EAgDT,GAhDS,EAiDT,GAjDS,EAkDT,GAlDS,EAmDT,GAnDS,EAoDT,GApDS,CAAb,CADe,CAAnB,CAvF4C,EAgJ5C,IAAID,IAAJ,CAAS,QAAT,EAAmB,CACf,IAAIC,QAAJ,CAAa,CACT,GADS,EAET,GAFS,EAGT,GAHS,EAIT,GAJS,EAKT,GALS,EAMT,GANS,EAOT,GAPS,EAQT,GARS,EAST,GATS,EAUT,GAVS,EAWT,GAXS,EAYT,GAZS,EAaT,GAbS,EAcT,GAdS,EAeT,GAfS,EAgBT,GAhBS,EAiBT,GAjBS,EAkBT,GAlBS,EAmBT,GAnBS,EAoBT,GApBS,EAqBT,GArBS,EAsBT,GAtBS,EAuBT,GAvBS,EAwBT,IAxBS,EAyBT,GAzBS,EA0BT,GA1BS,EA2BT,GA3BS,EA4BT,GA5BS,EA6BT,GA7BS,EA8BT,GA9BS,EA+BT,GA/BS,EAgCT,IAhCS,EAiCT,IAjCS,CAAb,CADe,CAAnB,CAhJ4C,CAAtB,CAAnB;AAuLP,OAAO,MAAMI,UAAU,GAAG,CACrBC,IAAD,IAAU,IAAIH,SAAJ,CAAc,CAAd,EAAiB,QAAjB,EAA2B,CAACG,IAAD,CAA3B,CADY,EAEtB,CAACC,MAAD,EAASD,IAAT,KAAkB;AACdC,EAAAA,MAAM,CAACC,QAAP,CAAgBC,IAAhB,CAAqBH,IAArB;AACA,SAAOC,MAAP;AACH,CALqB,EAOtB,CACIG,MADJ,EAEIC,QAFJ,EAGIC,QAHJ,EAIIC,WAJJ,EAKIC,MALJ,EAMIC,MANJ,EAOIC,MAPJ,EAQIC,KARJ,EASIC,MATJ,EAUIC,UAVJ,EAWIC,OAXJ,KAYK;AACD,SAAO,IAAIjB,SAAJ,CAAc,CAAd,EAAiB,MAAjB,EAAyB,CAACS,QAAD,EAAWO,UAAX,CAAzB,CAAP;AACH,CArBqB,EAqBnB;AAEH,MAAM,IAAIhB,SAAJ,CAAc,CAAd,EAAiB,gBAAjB,CAvBgB,EAwBtB,CAACkB,MAAD,EAASC,KAAT,KAAmB;AACf,MAAID,MAAM,CAACf,IAAP,KAAgB,CAApB,EAAuB,OAAOgB,KAAP;AACvBD,EAAAA,MAAM,CAACE,KAAP,IAAgBD,KAAK,CAACC,KAAtB;AACA,SAAOF,MAAP;AACH,CA5BqB,EA4BnB;AAEFG,IAAD,IAAU,IAAIrB,SAAJ,CAAc,CAAd,EAAiB,YAAjB,EAA+B,CAACqB,IAAD,CAA/B,CA9BY,EA+BtB,CAACL,UAAD,EAAaT,MAAb,EAAqBe,UAArB,EAAiCX,MAAjC,EAAyCU,IAAzC,KAAkD;AAC9C;AACAL,EAAAA,UAAU,CAACX,QAAX,CAAoBC,IAApB,CAAyBe,IAAzB;AACA,SAAOL,UAAP,CAH8C,CAI9C;AACA;AACH,CArCqB,EAqCnB;AAEH,CAACO,aAAD,EAAgBC,GAAhB,KAAwB,IAAIxB,SAAJ,CAAc,CAAd,EAAiB,UAAjB,EAA6B,CAACwB,GAAD,CAA7B,CAvCF,EAwCtB,CAACC,QAAD,EAAWC,QAAX,KACI,IAAI1B,SAAJ,CAAc,CAAd,EAAiB,UAAjB,EAA6ByB,QAAQ,CAACpB,QAAT,CAAkBsB,MAAlB,CAAyBD,QAAQ,CAACrB,QAAlC,CAA7B,CAzCkB,EA2CrBmB,GAAD,IAASA,GA3Ca,EA6CrBI,IAAD,IAAU,IAAI5B,SAAJ,CAAc,EAAd,EAAkB,MAAlB,EAA0B,CAAC4B,IAAD,CAA1B,CA7CY,EA8CtB,CAACP,IAAD,EAAOE,aAAP,EAAsBK,IAAtB,KAA+B;AAC3BP,EAAAA,IAAI,CAAChB,QAAL,CAAcC,IAAd,CAAmBsB,IAAnB;AACAP,EAAAA,IAAI,CAAClB,IAAL,GAAY,EAAZ;AACA,SAAOkB,IAAP;AACH,CAlDqB,EAoDrBQ,QAAD,IAAcA,QApDQ,EAoDE;AACvBC,WAAD,IAAiBA,WArDK,EAqDQ;AAE9B,CAACtB,QAAD,EAAWC,QAAX,EAAqBC,WAArB,KAAqC,IAAIV,SAAJ,CAAc,EAAd,EAAkB,cAAlB,EAAkC,CAACS,QAAD,CAAlC,CAvDf,EAyDtB,CAACsB,YAAD,EAAeC,KAAf,EAAsBC,YAAtB,KAAuC,IAAIjC,SAAJ,CAAc,EAAd,EAAkB,UAAlB,EAA8B,CAACgC,KAAD,CAA9B,CAzDjB,EA0DtB,CAACE,YAAD,EAAeC,KAAf,EAAsBC,YAAtB,KAAuC,IAAIpC,SAAJ,CAAc,EAAd,EAAkB,UAAlB,EAA8B,CAACmC,KAAD,CAA9B,CA1DjB,EA4DtB,MAAM,IAAInC,SAAJ,CAAc,EAAd,EAAkB,MAAlB,CA5DgB,EA6DtB,CAACgC,KAAD,EAAQK,UAAR,KAAuB;AACnB,MAAIL,KAAK,CAAC7B,IAAN,KAAe,EAAnB,EAAuB,OAAOkC,UAAP;AACvBL,EAAAA,KAAK,CAACZ,KAAN,IAAeiB,UAAU,CAACjB,KAA1B;AACA,SAAOY,KAAP;AACH,CAjEqB,EAiEnB;AAEH,MAAM,IAAIhC,SAAJ,CAAc,EAAd,EAAkB,MAAlB,CAnEgB,EAoEtB,CAACmC,KAAD,EAAQG,UAAR,KAAuB;AACnB,MAAIH,KAAK,CAAChC,IAAN,KAAe,EAAnB,EAAuB,OAAOmC,UAAP;AACvBH,EAAAA,KAAK,CAACf,KAAN,IAAekB,UAAU,CAAClB,KAA1B;AACA,SAAOe,KAAP;AACH,CAxEqB,EAwEnB;AAEFI,MAAD,IAAYA,MA1EU,EA0EF;AACnBC,KAAD,IAAWA,KA3EW,EA2EJ;AACjBC,MAAD,IAAYA,MA5EU,EA4EF;AAEnBD,KAAD,IAAWA,KA9EW,EA8EJ;AAEjBE,SAAD,IAAeA,SAhFO,EAgFI;AACzBC,WAAD,IAAiBA,WAjFK,EAiFQ;AAE7BD,SAAD,IAAeA,SAnFO,EAmFI;AACzBE,WAAD,IAAiBA,WApFK,EAoFQ;AAE7BL,MAAD,IAAYA,MAtFU,EAsFF;AACpB,CAAC9B,QAAD,EAAWoC,QAAX,KAAwB;AACpBpC,EAAAA,QAAQ,CAACW,KAAT,IAAkByB,QAAQ,CAACzB,KAA3B;AACA,SAAOX,QAAP;AACH,CA1FqB,EA0FnB;AAEF8B,MAAD,IAAYA,MA5FU,EA4FF;AACnBC,KAAD,IAAWA,KA7FW,EA6FJ;AACjBM,IAAD,IAAUA,IA9FY,EA8FN;AAEfP,MAAD,IAAYA,MAhGU,EAgGF;AACnBE,MAAD,IAAYA,MAjGU,CAiGF;AAjGE,CAAnB;AAoGP,OAAO,SAASM,YAAT,CAAsBC,mBAAtB,EAA2C;AAC9C,MAAIA,mBAAmB,KAAK,IAAxB,IAAgCA,mBAAmB,KAAKC,SAA5D,EACI,MAAM,IAAIC,KAAJ,CAAU,oBAAV,CAAN;AACJ,MAAIF,mBAAmB,CAAC5B,KAApB,KAA8B,QAAlC,EAA4C,MAAM,IAAI8B,KAAJ,CAAU,oBAAV,CAAN;AAE5C,MAAIC,MAAM,GAAG,IAAIvD,OAAJ,CAAYqD,SAAZ,EAAuB,EAAvB,CAAb;;AACA,OAAK,MAAM9C,IAAX,IAAmB6C,mBAAmB,CAAC3C,QAAvC,EAAiD;AAC7C,QAAIF,IAAI,CAACiB,KAAL,KAAe,MAAnB,EAA2B,MAAM,IAAI8B,KAAJ,CAAU,gBAAV,CAAN;AAC3B,QAAI/C,IAAI,CAACE,QAAL,CAAc+C,MAAd,KAAyB,CAA7B,EAAgC,MAAM,IAAIF,KAAJ,CAAU,cAAV,CAAN;AAChC,QAAI/C,IAAI,CAACE,QAAL,CAAc,CAAd,EAAiBF,IAAjB,KAA0B,CAAC,CAA/B,EAAkC,MAAM,IAAI+C,KAAJ,CAAU,cAAV,CAAN;AAClC,QAAI/C,IAAI,CAACE,QAAL,CAAc,CAAd,EAAiBe,KAAjB,KAA2B,YAA/B,EAA6C,MAAM,IAAI8B,KAAJ,CAAU,cAAV,CAAN;AAE7C,QAAIzC,QAAQ,GAAGN,IAAI,CAACE,QAAL,CAAc,CAAd,EAAiBe,KAAhC;AACA,QAAI+B,MAAM,CAACE,SAAP,KAAqBJ,SAAzB,EAAoCE,MAAM,CAACE,SAAP,GAAmB5C,QAAnB;AAEpC,QAAI6C,KAAK,GAAGC,mBAAmB,CAAC9C,QAAD,EAAWN,IAAI,CAACE,QAAL,CAAc,CAAd,CAAX,CAA/B;AACA8C,IAAAA,MAAM,CAACG,KAAP,GAAeH,MAAM,CAACG,KAAP,CAAa3B,MAAb,CAAoB2B,KAApB,CAAf;AACH;;AACD,SAAOH,MAAP;AACH,C,CAED;;AACA,SAASI,mBAAT,CAA6B9C,QAA7B,EAAuC+C,cAAvC,EAAuD;AACnD,QAAMC,KAAK,GAAG,EAAd;AACA,QAAMC,KAAK,GAAG,EAAd;AAEA,MAAIJ,KAAK,GAAG,EAAZ;AACA,MAAIK,OAAO,GAAG,KAAd;;AACA,OAAK,MAAMtC,IAAX,IAAmBmC,cAAc,CAACnD,QAAlC,EAA4C;AACxC,QAAIgB,IAAI,CAACD,KAAL,KAAe,MAAnB,EAA2B,MAAM,IAAI8B,KAAJ,CAAU,oBAAV,CAAN;AAE3B,QAAIU,OAAO,GAAG,EAAd;;AAEA,SAAK,MAAMnB,MAAX,IAAqBpB,IAAI,CAAChB,QAA1B,EAAoC;AAChC,UAAIoC,MAAM,CAACpC,QAAP,CAAgB+C,MAAhB,KAA2B,CAA/B,EAAkC,MAAM,IAAIF,KAAJ,CAAU,cAAV,CAAN;AAClC,UAAIW,QAAQ,GAAGpB,MAAM,CAACpC,QAAP,CAAgB,CAAhB,CAAf;;AAEA,UAAIoC,MAAM,CAACrB,KAAP,KAAiB,cAArB,EAAqC;AACjC,YAAIyC,QAAQ,CAAC1D,IAAT,KAAkB,CAAC,CAAvB,EAA0B,MAAM,IAAI+C,KAAJ,CAAU,sBAAV,CAAN;AAC1BU,QAAAA,OAAO,CAACtD,IAAR,CAAa,IAAIP,WAAJ,CAAgB8D,QAAQ,CAACzC,KAAzB,CAAb;AACH,OAHD,MAGO,IAAIqB,MAAM,CAACrB,KAAP,KAAiB,UAArB,EAAiC;AACpC,YAAIyC,QAAQ,CAAC1D,IAAT,KAAkBsD,KAAlB,IAA2BI,QAAQ,CAAC1D,IAAT,KAAkBuD,KAAjD,EAAwD;AACpD,cAAIrC,IAAI,CAAChB,QAAL,CAAc+C,MAAd,GAAuB,CAA3B,EAA8B;AAC1B,gBAAIO,OAAO,KAAK,KAAhB,EAAuB;AACnBL,cAAAA,KAAK,CAAChD,IAAN,CAAW,IAAIT,IAAJ,CAASY,QAAQ,GAAG,OAApB,EAA6B,EAA7B,CAAX;AACAkD,cAAAA,OAAO,GAAG,IAAV;AACH;;AACDC,YAAAA,OAAO,CAACtD,IAAR,CAAaP,WAAW,CAACU,QAAQ,GAAG,OAAZ,CAAxB;AACH;AACJ,SARD,MAQO,IAAIoD,QAAQ,CAAC1D,IAAT,KAAkB,CAAC,CAAvB,EAA0B;AAC7B,eAAK,MAAM2D,CAAX,IAAgBD,QAAQ,CAACzC,KAAzB,EAAgC;AAC5BwC,YAAAA,OAAO,CAACtD,IAAR,CAAa,IAAIR,QAAJ,CAAagE,CAAb,CAAb;AACH;AACJ,SAJM,MAIA,MAAM,IAAIZ,KAAJ,CAAU,kBAAV,CAAN;AACV,OAdM,MAcA,MAAM,IAAIA,KAAJ,CAAU,cAAV,CAAN;AACV;;AAEDI,IAAAA,KAAK,CAAChD,IAAN,CAAW,IAAIT,IAAJ,CAASY,QAAT,EAAmBmD,OAAnB,CAAX;AACH;;AACD,SAAON,KAAP;AACH","sourcesContent":["import { Grammar, Rule } from \"./EarleyRecognizer\";\r\nimport { Terminal, NonTerminal } from \"./Symbol\";\r\nimport { ParseNode } from \"./EarleyParser\";\r\n\r\nexport const bnfGrammar = new Grammar(\"syntax\", [\r\n    new Rule(\"syntax\", [new NonTerminal(\"rule\")]),\r\n    new Rule(\"syntax\", [new NonTerminal(\"syntax\"), new NonTerminal(\"rule\")]),\r\n\r\n    new Rule(\"rule\", [\r\n        new NonTerminal(\"opt-whitespace\"),\r\n        new Terminal(\"<\"),\r\n        new NonTerminal(\"rule-name\"),\r\n        new Terminal(\">\"),\r\n        new NonTerminal(\"opt-whitespace\"),\r\n        new Terminal(\":\"),\r\n        new Terminal(\":\"),\r\n        new Terminal(\"=\"),\r\n        new NonTerminal(\"opt-whitespace\"),\r\n        new NonTerminal(\"expression\"),\r\n        new NonTerminal(\"line-end\"),\r\n    ]),\r\n\r\n    new Rule(\"opt-whitespace\", []),\r\n    new Rule(\"opt-whitespace\", [new NonTerminal(\"opt-whitespace\"), new Terminal(\" \")]),\r\n\r\n    new Rule(\"expression\", [new NonTerminal(\"list\")]),\r\n    new Rule(\"expression\", [\r\n        new NonTerminal(\"expression\"),\r\n        new NonTerminal(\"opt-whitespace\"),\r\n        new Terminal(\"|\"),\r\n        new NonTerminal(\"opt-whitespace\"),\r\n        new NonTerminal(\"list\"),\r\n    ]),\r\n\r\n    new Rule(\"line-end\", [new NonTerminal(\"opt-whitespace\"), new NonTerminal(\"EOL\")]),\r\n    new Rule(\"line-end\", [new NonTerminal(\"line-end\"), new NonTerminal(\"line-end\")]),\r\n\r\n    new Rule(\"EOL\", [new Terminal([\";\", \"\\n\", \"\\r\"])]),\r\n\r\n    new Rule(\"list\", [new NonTerminal(\"term\")]),\r\n    new Rule(\"list\", [\r\n        new NonTerminal(\"list\"),\r\n        new NonTerminal(\"opt-whitespace\"),\r\n        new NonTerminal(\"term\"),\r\n    ]),\r\n\r\n    new Rule(\"term\", [new NonTerminal(\"terminal\")]),\r\n    new Rule(\"term\", [new NonTerminal(\"non-terminal\")]),\r\n\r\n    new Rule(\"non-terminal\", [\r\n        new Terminal(\"<\"),\r\n        new NonTerminal(\"rule-name\"),\r\n        new Terminal(\">\"),\r\n    ]),\r\n\r\n    new Rule(\"terminal\", [\r\n        new Terminal('\"'),\r\n        new NonTerminal(\"text1\"),\r\n        new Terminal('\"'),\r\n    ]),\r\n    new Rule(\"terminal\", [\r\n        new Terminal(\"'\"),\r\n        new NonTerminal(\"text2\"),\r\n        new Terminal(\"'\"),\r\n    ]),\r\n\r\n    new Rule(\"text1\", []), // NULL\r\n    new Rule(\"text1\", [new NonTerminal(\"text1\"), new NonTerminal(\"character1\")]),\r\n\r\n    new Rule(\"text2\", []), // NULL\r\n    new Rule(\"text2\", [new NonTerminal(\"text2\"), new NonTerminal(\"character2\")]),\r\n\r\n    new Rule(\"character\", [new NonTerminal(\"letter\")]),\r\n    new Rule(\"character\", [new NonTerminal(\"digit\")]),\r\n    new Rule(\"character\", [new NonTerminal(\"symbol\")]),\r\n\r\n    new Rule(\"digit\", [new Terminal([\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"])]),\r\n\r\n    new Rule(\"character1\", [new NonTerminal(\"character\")]),\r\n    new Rule(\"character1\", [new Terminal(\"'\")]),\r\n\r\n    new Rule(\"character2\", [new NonTerminal(\"character\")]),\r\n    new Rule(\"character2\", [new Terminal('\"')]),\r\n\r\n    new Rule(\"rule-name\", [new NonTerminal(\"letter\")]),\r\n    new Rule(\"rule-name\", [new NonTerminal(\"rule-name\"), new NonTerminal(\"rule-char\")]),\r\n\r\n    new Rule(\"rule-char\", [new NonTerminal(\"letter\")]),\r\n    new Rule(\"rule-char\", [new NonTerminal(\"digit\")]),\r\n    new Rule(\"rule-char\", [new Terminal(\"-\")]),\r\n\r\n    new Rule(\"letter\", [\r\n        new Terminal([\r\n            \"a\",\r\n            \"b\",\r\n            \"c\",\r\n            \"d\",\r\n            \"e\",\r\n            \"f\",\r\n            \"g\",\r\n            \"h\",\r\n            \"i\",\r\n            \"j\",\r\n            \"k\",\r\n            \"l\",\r\n            \"m\",\r\n            \"n\",\r\n            \"o\",\r\n            \"p\",\r\n            \"q\",\r\n            \"r\",\r\n            \"s\",\r\n            \"t\",\r\n            \"u\",\r\n            \"v\",\r\n            \"w\",\r\n            \"x\",\r\n            \"y\",\r\n            \"z\",\r\n            \"A\",\r\n            \"B\",\r\n            \"C\",\r\n            \"D\",\r\n            \"E\",\r\n            \"F\",\r\n            \"G\",\r\n            \"H\",\r\n            \"I\",\r\n            \"J\",\r\n            \"K\",\r\n            \"L\",\r\n            \"M\",\r\n            \"N\",\r\n            \"O\",\r\n            \"P\",\r\n            \"Q\",\r\n            \"R\",\r\n            \"S\",\r\n            \"T\",\r\n            \"U\",\r\n            \"V\",\r\n            \"W\",\r\n            \"X\",\r\n            \"Y\",\r\n            \"Z\",\r\n        ]),\r\n    ]),\r\n\r\n    new Rule(\"symbol\", [\r\n        new Terminal([\r\n            \"|\",\r\n            \" \",\r\n            \"!\",\r\n            \"#\",\r\n            \"$\",\r\n            \"%\",\r\n            \"&\",\r\n            \"(\",\r\n            \")\",\r\n            \"*\",\r\n            \"+\",\r\n            \",\",\r\n            \"-\",\r\n            \".\",\r\n            \"/\",\r\n            \":\",\r\n            \";\",\r\n            \">\",\r\n            \"=\",\r\n            \"<\",\r\n            \"?\",\r\n            \"@\",\r\n            \"[\",\r\n            \"\\\\\",\r\n            \"]\",\r\n            \"^\",\r\n            \"_\",\r\n            \"`\",\r\n            \"{\",\r\n            \"}\",\r\n            \"~\",\r\n            \"\\n\",\r\n            \"\\r\",\r\n        ]),\r\n    ]),\r\n]);\r\n\r\nexport const bnfActions = [\r\n    (rule) => new ParseNode(0, \"syntax\", [rule]),\r\n    (syntax, rule) => {\r\n        syntax.children.push(rule);\r\n        return syntax;\r\n    },\r\n\r\n    (\r\n        space1,\r\n        lessThan,\r\n        ruleName,\r\n        greaterThan,\r\n        space2,\r\n        colon1,\r\n        colon2,\r\n        equal,\r\n        space3,\r\n        expression,\r\n        lineEnd\r\n    ) => {\r\n        return new ParseNode(2, \"rule\", [ruleName, expression]);\r\n    }, //new ParseNode(2, \"rule\", args),\r\n\r\n    () => new ParseNode(3, \"opt-whitespace\"),\r\n    (spaces, space) => {\r\n        if (spaces.rule === 3) return space;\r\n        spaces.label += space.label;\r\n        return spaces;\r\n    }, //new ParseNode(4, \"opt-whitespace\", args),\r\n\r\n    (list) => new ParseNode(5, \"expression\", [list]),\r\n    (expression, space1, orTerminal, space2, list) => {\r\n        //if (expression.rule === 5) {\r\n        expression.children.push(list);\r\n        return expression;\r\n        //}\r\n        //return new ParseNode(6, \"expression\", [expression, list]);\r\n    }, //new ParseNode(6, \"expression\", args),\r\n\r\n    (optWhitespace, eol) => new ParseNode(7, \"line-end\", [eol]),\r\n    (lineEnd1, lineEnd2) =>\r\n        new ParseNode(8, \"line-end\", lineEnd1.children.concat(lineEnd2.children)),\r\n\r\n    (eol) => eol,\r\n\r\n    (term) => new ParseNode(11, \"list\", [term]),\r\n    (list, optWhitespace, term) => {\r\n        list.children.push(term);\r\n        list.rule = 12;\r\n        return list;\r\n    },\r\n\r\n    (terminal) => terminal, //new ParseNode(12, \"term\", args),\r\n    (nonTerminal) => nonTerminal, //new ParseNode(13, \"term\", args),\r\n\r\n    (lessThan, ruleName, greaterThan) => new ParseNode(14, \"non-terminal\", [ruleName]),\r\n\r\n    (doubleQuote1, text1, doubleQuote2) => new ParseNode(15, \"terminal\", [text1]),\r\n    (singleQuote1, text2, singleQuote2) => new ParseNode(16, \"terminal\", [text2]),\r\n\r\n    () => new ParseNode(17, \"null\"),\r\n    (text1, character1) => {\r\n        if (text1.rule === 17) return character1;\r\n        text1.label += character1.label;\r\n        return text1;\r\n    }, //new ParseNode(18, \"text1\", args),\r\n\r\n    () => new ParseNode(19, \"null\"),\r\n    (text2, character2) => {\r\n        if (text2.rule === 19) return character2;\r\n        text2.label += character2.label;\r\n        return text2;\r\n    }, //new ParseNode(20, \"text2\", args),\r\n\r\n    (letter) => letter, //new ParseNode(22, \"character\", args),\r\n    (digit) => digit, //new ParseNode(22, \"character\", args),\r\n    (symbol) => symbol, //new ParseNode(23, \"character\", args),\r\n\r\n    (digit) => digit, //new ParseNode(24, \"digit\", args),\r\n\r\n    (character) => character, //new ParseNode(25, \"character1\", args),\r\n    (singleQuote) => singleQuote, //new ParseNode(26, \"character1\", args),\r\n\r\n    (character) => character, //new ParseNode(27, \"character2\", args),\r\n    (doubleQuote) => doubleQuote, // new ParseNode(28, \"character2\", args),\r\n\r\n    (letter) => letter, //new ParseNode(29, \"rule-name\", args),\r\n    (ruleName, ruleChar) => {\r\n        ruleName.label += ruleChar.label;\r\n        return ruleName;\r\n    }, //new ParseNode(30, \"rule-name\", args),\r\n\r\n    (letter) => letter, //new ParseNode(31, \"rule-char\", args),\r\n    (digit) => digit, //new ParseNode(32, \"rule-char\", args),\r\n    (dash) => dash, //new ParseNode(33, \"rule-char\", args),\r\n\r\n    (letter) => letter, //new ParseNode(34, \"letter\", args),\r\n    (symbol) => symbol, //new ParseNode(35, \"symbol\", args),\r\n];\r\n\r\nexport function interpretBNF(simplifiedParseTree) {\r\n    if (simplifiedParseTree === null || simplifiedParseTree === undefined)\r\n        throw new Error(\"invalid parse tree\");\r\n    if (simplifiedParseTree.label !== \"syntax\") throw new Error(\"invalid parse tree\");\r\n\r\n    let newBNF = new Grammar(undefined, []);\r\n    for (const rule of simplifiedParseTree.children) {\r\n        if (rule.label !== \"rule\") throw new Error(\"invalid syntax\");\r\n        if (rule.children.length !== 2) throw new Error(\"invalid rule\");\r\n        if (rule.children[0].rule !== -1) throw new Error(\"invalid rule\");\r\n        if (rule.children[1].label !== \"expression\") throw new Error(\"invalid rule\");\r\n\r\n        let ruleName = rule.children[0].label;\r\n        if (newBNF.startRule === undefined) newBNF.startRule = ruleName;\r\n\r\n        let rules = interpretExpression(ruleName, rule.children[1]);\r\n        newBNF.rules = newBNF.rules.concat(rules);\r\n    }\r\n    return newBNF;\r\n}\r\n\r\n// returns array of Rules\r\nfunction interpretExpression(ruleName, expressionTree) {\r\n    const NULL1 = 17;\r\n    const NULL2 = 19;\r\n\r\n    let rules = [];\r\n    let hasNull = false;\r\n    for (const list of expressionTree.children) {\r\n        if (list.label !== \"list\") throw new Error(\"invalid expression\");\r\n\r\n        let ruleDef = [];\r\n\r\n        for (const symbol of list.children) {\r\n            if (symbol.children.length !== 1) throw new Error(\"invalid list\");\r\n            let symChild = symbol.children[0];\r\n\r\n            if (symbol.label === \"non-terminal\") {\r\n                if (symChild.rule !== -1) throw new Error(\"invalid non-terminal\");\r\n                ruleDef.push(new NonTerminal(symChild.label));\r\n            } else if (symbol.label === \"terminal\") {\r\n                if (symChild.rule === NULL1 || symChild.rule === NULL2) {\r\n                    if (list.children.length > 1) {\r\n                        if (hasNull === false) {\r\n                            rules.push(new Rule(ruleName + \"-null\", []));\r\n                            hasNull = true;\r\n                        }\r\n                        ruleDef.push(NonTerminal(ruleName + \"-null\"));\r\n                    }\r\n                } else if (symChild.rule === -1) {\r\n                    for (const c of symChild.label) {\r\n                        ruleDef.push(new Terminal(c));\r\n                    }\r\n                } else throw new Error(\"invalid terminal\");\r\n            } else throw new Error(\"invalid list\");\r\n        }\r\n\r\n        rules.push(new Rule(ruleName, ruleDef));\r\n    }\r\n    return rules;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}