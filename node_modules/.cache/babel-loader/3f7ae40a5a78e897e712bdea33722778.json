{"ast":null,"code":"import _createForOfIteratorHelper from\"C:/Users/Andrew/Documents/JavaScript Projects/bool-simp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _classCallCheck from\"C:/Users/Andrew/Documents/JavaScript Projects/bool-simp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import StructFactory from\"../StructFactory\";import{Terminal,NonTerminal}from\"./Symbol\";var Edge=StructFactory(\"startNode endNode data\");export var ParseNode=function ParseNode(rule,label,children){_classCallCheck(this,ParseNode);this.rule=-1;this.label=\"\";this.children=[];this.rule=rule;this.label=label;if(children===undefined||children===null)this.children=[];else this.children=children;};var EarleyParser={sortEarleySets:function sortEarleySets(s){},invertEarleySets:function invertEarleySets(s,grammar){var filterIncomplete=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;var inverted=[];this.padEarleySets(s.length,inverted);for(var i=0;i<s.length;i++){for(var j=0;j<s[i].length;j++){var item=s[i][j];var rule=grammar.rules[item.rule];if(filterIncomplete&&rule.definition.length>item.next)continue;var newSet=item.start;item.start=i;inverted[newSet].push(item);}}return inverted;},padEarleySets:function padEarleySets(amount,s){for(var i=0;i<amount;i++){s.push([]);}},buildParseTree:function buildParseTree(input,invertedS,grammar){var _this=this;var completeItems=this.getEdges(0,input.length,invertedS);if(completeItems.length===0)return null;var startingEdge=new Edge(0,input.length,completeItems[0].rule);var root=new ParseNode(startingEdge.data,grammar.rules[startingEdge.data].name);var aux=function aux(edge,node){var children=_this.decomposeEdge(input,invertedS,grammar,edge);var _iterator=_createForOfIteratorHelper(children),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var child=_step.value;if(child.data===-1){node.children.push(new ParseNode(-1,input.substring(child.startNode,child.startNode+1)));}else{var newNode=new ParseNode(child.data,grammar.rules[child.data].name);node.children.push(newNode);aux(child,newNode);}}}catch(err){_iterator.e(err);}finally{_iterator.f();}};aux(startingEdge,root);return root;},printParseTree:function printParseTree(node){var printRule=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var aux=function aux(node,indent,last){var line=indent+\"+- \"+node.label;if(printRule)line+=\" (\"+node.rule+\")\";console.log(line);indent+=last?\"   \":\"|  \";for(var i=0;i<node.children.length;i++){aux(node.children[i],indent,i===node.children.length-1);}};aux(node,\"\",true);},getParseTreeString:function getParseTreeString(node){var printRule=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var string=\"\";var aux=function aux(node,indent,last){var line=indent+\"+- \"+node.label;if(printRule)line+=\" (\"+node.rule+\")\";string+=line+\"\\n\";indent+=last?\"   \":\"|  \";for(var i=0;i<node.children.length;i++){aux(node.children[i],indent,i===node.children.length-1);}};aux(node,\"\",true);return string;},getEdges:function getEdges(startNode,endNode,graph){console.assert(graph.length>startNode);var edges=[];var _iterator2=_createForOfIteratorHelper(graph[startNode]),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var item=_step2.value;if(item.start===endNode)edges.push(item);}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}return edges;},decomposeEdge:function decomposeEdge(input,graph,grammar,edge){console.assert(edge.startNode<graph.length);console.assert(edge.endNode<graph.length);console.assert(edge.data>=0&&edge.data<grammar.rules.length);var rules=grammar.rules[edge.data].definition;var start=edge.startNode;var finish=edge.endNode;var bottom=rules.length;var isLeaf=function isLeaf(node,depth){return node===finish&&depth===bottom;};var getChild=function getChild(edge,depth){return edge.endNode;};var getEdges=function getEdges(node,depth){if(depth>=rules.length)return[];var edges=[];var symbol=rules[depth];if(symbol instanceof Terminal){if(symbol.match(input.substring(node,node+1)))edges.push(new Edge(node,node+1,-1));}else if(symbol instanceof NonTerminal){var _iterator3=_createForOfIteratorHelper(graph[node]),_step3;try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var item=_step3.value;if(symbol.match(grammar.rules[item.rule].name))edges.push(new Edge(node,item.start,item.rule));}}catch(err){_iterator3.e(err);}finally{_iterator3.f();}}return edges;};return this.depthFirstSearch(start,getEdges,isLeaf,getChild);},depthFirstSearch:function depthFirstSearch(root,funcGetEdges,funcIsLeaf,funcGetChild){var path=[];var aux=function aux(node,depth){if(funcIsLeaf(node,depth))return true;var edges=funcGetEdges(node,depth);var _iterator4=_createForOfIteratorHelper(edges),_step4;try{for(_iterator4.s();!(_step4=_iterator4.n()).done;){var edge=_step4.value;var child=funcGetChild(edge,depth);if(aux(child,depth+1)){path.unshift(edge);return true;}}}catch(err){_iterator4.e(err);}finally{_iterator4.f();}return false;};aux(root,0);return path;},applySemanticAction:function applySemanticAction(tokenHandler,root,actions){var aux=function aux(node){// if node is a leaf node\nif(node.rule===-1){return tokenHandler(node.label);}else{var processedChildren=[];var _iterator5=_createForOfIteratorHelper(node.children),_step5;try{for(_iterator5.s();!(_step5=_iterator5.n()).done;){var child=_step5.value;processedChildren.push(aux(child));}}catch(err){_iterator5.e(err);}finally{_iterator5.f();}return actions[node.rule].apply(actions,processedChildren);}};return aux(root);}};export default EarleyParser;","map":{"version":3,"sources":["C:/Users/Andrew/Documents/JavaScript Projects/bool-simp/src/scripts/Earley Parser/EarleyParser.js"],"names":["StructFactory","Terminal","NonTerminal","Edge","ParseNode","rule","label","children","undefined","EarleyParser","sortEarleySets","s","invertEarleySets","grammar","filterIncomplete","inverted","padEarleySets","length","i","j","item","rules","definition","next","newSet","start","push","amount","buildParseTree","input","invertedS","completeItems","getEdges","startingEdge","root","data","name","aux","edge","node","decomposeEdge","child","substring","startNode","newNode","printParseTree","printRule","indent","last","line","console","log","getParseTreeString","string","endNode","graph","assert","edges","finish","bottom","isLeaf","depth","getChild","symbol","match","depthFirstSearch","funcGetEdges","funcIsLeaf","funcGetChild","path","unshift","applySemanticAction","tokenHandler","actions","processedChildren"],"mappings":"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","sourcesContent":["import StructFactory from \"../StructFactory\";\r\nimport { Terminal, NonTerminal } from \"./Symbol\";\r\n\r\nconst Edge = StructFactory(\"startNode endNode data\");\r\n\r\nexport class ParseNode {\r\n    rule = -1;\r\n    label = \"\";\r\n    children = [];\r\n\r\n    constructor(rule, label, children) {\r\n        this.rule = rule;\r\n        this.label = label;\r\n\r\n        if (children === undefined || children === null) this.children = [];\r\n        else this.children = children;\r\n    }\r\n}\r\n\r\nconst EarleyParser = {\r\n    sortEarleySets(s) {},\r\n\r\n    invertEarleySets(s, grammar, filterIncomplete = true) {\r\n        let inverted = [];\r\n        this.padEarleySets(s.length, inverted);\r\n\r\n        for (let i = 0; i < s.length; i++) {\r\n            for (let j = 0; j < s[i].length; j++) {\r\n                let item = s[i][j];\r\n                let rule = grammar.rules[item.rule];\r\n\r\n                if (filterIncomplete && rule.definition.length > item.next) continue;\r\n\r\n                let newSet = item.start;\r\n                item.start = i;\r\n                inverted[newSet].push(item);\r\n            }\r\n        }\r\n\r\n        return inverted;\r\n    },\r\n\r\n    padEarleySets(amount, s) {\r\n        for (let i = 0; i < amount; i++) {\r\n            s.push([]);\r\n        }\r\n    },\r\n\r\n    buildParseTree(input, invertedS, grammar) {\r\n        let completeItems = this.getEdges(0, input.length, invertedS);\r\n        if (completeItems.length === 0) return null;\r\n\r\n        let startingEdge = new Edge(0, input.length, completeItems[0].rule);\r\n        let root = new ParseNode(\r\n            startingEdge.data,\r\n            grammar.rules[startingEdge.data].name\r\n        );\r\n\r\n        let aux = (edge, node) => {\r\n            let children = this.decomposeEdge(input, invertedS, grammar, edge);\r\n            for (const child of children) {\r\n                if (child.data === -1) {\r\n                    node.children.push(\r\n                        new ParseNode(\r\n                            -1,\r\n                            input.substring(child.startNode, child.startNode + 1)\r\n                        )\r\n                    );\r\n                } else {\r\n                    let newNode = new ParseNode(\r\n                        child.data,\r\n                        grammar.rules[child.data].name\r\n                    );\r\n                    node.children.push(newNode);\r\n                    aux(child, newNode);\r\n                }\r\n            }\r\n        };\r\n\r\n        aux(startingEdge, root);\r\n        return root;\r\n    },\r\n\r\n    printParseTree(node, printRule = false) {\r\n        let aux = (node, indent, last) => {\r\n            let line = indent + \"+- \" + node.label;\r\n            if (printRule) line += \" (\" + node.rule + \")\";\r\n            console.log(line);\r\n\r\n            indent += last ? \"   \" : \"|  \";\r\n\r\n            for (let i = 0; i < node.children.length; i++) {\r\n                aux(node.children[i], indent, i === node.children.length - 1);\r\n            }\r\n        };\r\n\r\n        aux(node, \"\", true);\r\n    },\r\n\r\n    getParseTreeString(node, printRule = false) {\r\n        let string = \"\";\r\n        let aux = (node, indent, last) => {\r\n            let line = indent + \"+- \" + node.label;\r\n            if (printRule) line += \" (\" + node.rule + \")\";\r\n            string += line + \"\\n\";\r\n\r\n            indent += last ? \"   \" : \"|  \";\r\n\r\n            for (let i = 0; i < node.children.length; i++) {\r\n                aux(node.children[i], indent, i === node.children.length - 1);\r\n            }\r\n        };\r\n\r\n        aux(node, \"\", true);\r\n        return string;\r\n    },\r\n\r\n    getEdges(startNode, endNode, graph) {\r\n        console.assert(graph.length > startNode);\r\n\r\n        let edges = [];\r\n        for (const item of graph[startNode]) {\r\n            if (item.start === endNode) edges.push(item);\r\n        }\r\n        return edges;\r\n    },\r\n\r\n    decomposeEdge(input, graph, grammar, edge) {\r\n        console.assert(edge.startNode < graph.length);\r\n        console.assert(edge.endNode < graph.length);\r\n        console.assert(edge.data >= 0 && edge.data < grammar.rules.length);\r\n\r\n        const rules = grammar.rules[edge.data].definition;\r\n\r\n        let start = edge.startNode;\r\n        let finish = edge.endNode;\r\n        let bottom = rules.length;\r\n\r\n        let isLeaf = (node, depth) => {\r\n            return node === finish && depth === bottom;\r\n        };\r\n\r\n        let getChild = (edge, depth) => {\r\n            return edge.endNode;\r\n        };\r\n\r\n        let getEdges = (node, depth) => {\r\n            if (depth >= rules.length) return [];\r\n\r\n            let edges = [];\r\n            let symbol = rules[depth];\r\n\r\n            if (symbol instanceof Terminal) {\r\n                if (symbol.match(input.substring(node, node + 1)))\r\n                    edges.push(new Edge(node, node + 1, -1));\r\n            } else if (symbol instanceof NonTerminal) {\r\n                for (const item of graph[node]) {\r\n                    if (symbol.match(grammar.rules[item.rule].name))\r\n                        edges.push(new Edge(node, item.start, item.rule));\r\n                }\r\n            }\r\n            return edges;\r\n        };\r\n\r\n        return this.depthFirstSearch(start, getEdges, isLeaf, getChild);\r\n    },\r\n\r\n    depthFirstSearch(root, funcGetEdges, funcIsLeaf, funcGetChild) {\r\n        let path = [];\r\n        let aux = (node, depth) => {\r\n            if (funcIsLeaf(node, depth)) return true;\r\n            let edges = funcGetEdges(node, depth);\r\n            for (const edge of edges) {\r\n                let child = funcGetChild(edge, depth);\r\n                if (aux(child, depth + 1)) {\r\n                    path.unshift(edge);\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n        aux(root, 0);\r\n        return path;\r\n    },\r\n\r\n    applySemanticAction(tokenHandler, root, actions) {\r\n        let aux = (node) => {\r\n            // if node is a leaf node\r\n            if (node.rule === -1) {\r\n                return tokenHandler(node.label);\r\n            } else {\r\n                let processedChildren = [];\r\n                for (const child of node.children) {\r\n                    processedChildren.push(aux(child));\r\n                }\r\n                return actions[node.rule](...processedChildren);\r\n            }\r\n        };\r\n        return aux(root);\r\n    },\r\n};\r\n\r\nexport default EarleyParser;\r\n"]},"metadata":{},"sourceType":"module"}