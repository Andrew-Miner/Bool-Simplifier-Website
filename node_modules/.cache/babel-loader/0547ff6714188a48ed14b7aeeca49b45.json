{"ast":null,"code":"import _slicedToArray from\"C:/Users/Andrew/Documents/JavaScript Projects/bool-simp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import _createForOfIteratorHelper from\"C:/Users/Andrew/Documents/JavaScript Projects/bool-simp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _classCallCheck from\"C:/Users/Andrew/Documents/JavaScript Projects/bool-simp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"C:/Users/Andrew/Documents/JavaScript Projects/bool-simp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";import _classPrivateFieldLooseBase from\"C:/Users/Andrew/Documents/JavaScript Projects/bool-simp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";import _classPrivateFieldLooseKey from\"C:/Users/Andrew/Documents/JavaScript Projects/bool-simp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";import{buildBoolGrammar,deepCopy,validateTerms,getVarBitSet,calculateMinTerms}from\"./BoolExpressionUtils\";import QMFuncs from\"./QMFunctions\";import PMFuncs from\"./PMFunctions\";import Recognizer from\"../Earley Parser/EarleyRecognizer\";import Parser from\"../Earley Parser/EarleyParser\";import BitSet from\"bitset\";var _varCount=/*#__PURE__*/_classPrivateFieldLooseKey(\"varCount\");var _minTerms=/*#__PURE__*/_classPrivateFieldLooseKey(\"minTerms\");var _dontCares=/*#__PURE__*/_classPrivateFieldLooseKey(\"dontCares\");var _primeImps=/*#__PURE__*/_classPrivateFieldLooseKey(\"primeImps\");var _petrickSOP=/*#__PURE__*/_classPrivateFieldLooseKey(\"petrickSOP\");var _sSet=/*#__PURE__*/_classPrivateFieldLooseKey(\"sSet\");var _invertedS=/*#__PURE__*/_classPrivateFieldLooseKey(\"invertedS\");var _parseTree=/*#__PURE__*/_classPrivateFieldLooseKey(\"parseTree\");var _varBitSet=/*#__PURE__*/_classPrivateFieldLooseKey(\"varBitSet\");var _expression=/*#__PURE__*/_classPrivateFieldLooseKey(\"expression\");var _errorCode=/*#__PURE__*/_classPrivateFieldLooseKey(\"errorCode\");var _isLogged=/*#__PURE__*/_classPrivateFieldLooseKey(\"isLogged\");var _qmLog=/*#__PURE__*/_classPrivateFieldLooseKey(\"qmLog\");var _pmLog=/*#__PURE__*/_classPrivateFieldLooseKey(\"pmLog\");var _truthTable=/*#__PURE__*/_classPrivateFieldLooseKey(\"truthTable\");var _BOOL_GRAMMAR=/*#__PURE__*/_classPrivateFieldLooseKey(\"BOOL_GRAMMAR\");var _reduce=/*#__PURE__*/_classPrivateFieldLooseKey(\"reduce\");var _buildTruthTable=/*#__PURE__*/_classPrivateFieldLooseKey(\"buildTruthTable\");var BoolExpression=/*#__PURE__*/function(){function BoolExpression(_expression2,_minTerms2,_dontCares2){var _this=this;var isLogged=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;_classCallCheck(this,BoolExpression);Object.defineProperty(this,_varCount,{writable:true,value:void 0});Object.defineProperty(this,_minTerms,{writable:true,value:void 0});Object.defineProperty(this,_dontCares,{writable:true,value:void 0});Object.defineProperty(this,_primeImps,{writable:true,value:void 0});Object.defineProperty(this,_petrickSOP,{writable:true,value:void 0});Object.defineProperty(this,_sSet,{writable:true,value:void 0});Object.defineProperty(this,_invertedS,{writable:true,value:void 0});Object.defineProperty(this,_parseTree,{writable:true,value:void 0});Object.defineProperty(this,_varBitSet,{writable:true,value:void 0});Object.defineProperty(this,_expression,{writable:true,value:void 0});Object.defineProperty(this,_errorCode,{writable:true,value:-2});Object.defineProperty(this,_isLogged,{writable:true,value:false});Object.defineProperty(this,_qmLog,{writable:true,value:void 0});Object.defineProperty(this,_pmLog,{writable:true,value:void 0});Object.defineProperty(this,_truthTable,{writable:true,value:void 0});this.getMinTerms=function(){return deepCopy(_classPrivateFieldLooseBase(_this,_minTerms)[_minTerms]);};this.getDontCares=function(){return deepCopy(_classPrivateFieldLooseBase(_this,_dontCares)[_dontCares]);};this.getPetrickSOP=function(){return deepCopy(_classPrivateFieldLooseBase(_this,_petrickSOP)[_petrickSOP]);};this.getEssentialImplicants=function(){return deepCopy(_classPrivateFieldLooseBase(_this,_primeImps)[_primeImps]);};this.getVarCount=function(){return _classPrivateFieldLooseBase(_this,_varCount)[_varCount];};this.getQMLog=function(){return _classPrivateFieldLooseBase(_this,_isLogged)[_isLogged]?deepCopy(_classPrivateFieldLooseBase(_this,_qmLog)[_qmLog]):[];};this.getPMLog=function(){return _classPrivateFieldLooseBase(_this,_isLogged)[_isLogged]?deepCopy(_classPrivateFieldLooseBase(_this,_pmLog)[_pmLog]):[];};this.getTruthTable=function(){return deepCopy(_classPrivateFieldLooseBase(_this,_truthTable)[_truthTable]);};this.getPrimeImpStrings=function(){var piStrs=[];var _iterator=_createForOfIteratorHelper(_classPrivateFieldLooseBase(_this,_primeImps)[_primeImps]),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var implicant=_step.value;var str=\"[\";var minTerms=QMFuncs.extractMinTerms(implicant);var _iterator2=_createForOfIteratorHelper(minTerms),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var term=_step2.value;str+=parseInt(term)+\"-\";}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}str=str.substring(0,str.length-1)+\"] \";str+=QMFuncs.toString(implicant,_classPrivateFieldLooseBase(_this,_varCount)[_varCount]);piStrs.push(str);}}catch(err){_iterator.e(err);}finally{_iterator.f();}return piStrs;};this.getSOPStrings=function(){var sopStrs=[];if(_classPrivateFieldLooseBase(_this,_petrickSOP)[_petrickSOP].length===0){if(_classPrivateFieldLooseBase(_this,_varBitSet)[_varBitSet])sopStrs.push(PMFuncs.mapProductToString([],_classPrivateFieldLooseBase(_this,_varBitSet)[_varBitSet]));else sopStrs.push(PMFuncs.productToString([],_classPrivateFieldLooseBase(_this,_varCount)[_varCount]));}else{var _iterator3=_createForOfIteratorHelper(_classPrivateFieldLooseBase(_this,_petrickSOP)[_petrickSOP]),_step3;try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var product=_step3.value;if(_classPrivateFieldLooseBase(_this,_varBitSet)[_varBitSet])sopStrs.push(PMFuncs.mapProductToString(product,_classPrivateFieldLooseBase(_this,_varBitSet)[_varBitSet]));else sopStrs.push(PMFuncs.productToString(product,_classPrivateFieldLooseBase(_this,_varCount)[_varCount]));}}catch(err){_iterator3.e(err);}finally{_iterator3.f();}}return sopStrs;};this.setExpression=function(expression){expression=expression.replace(/ /g,\"\");var sSet=Recognizer.buildItems(expression,_classPrivateFieldLooseBase(BoolExpression,_BOOL_GRAMMAR)[_BOOL_GRAMMAR]);var invertedS=Parser.invertEarleySets(sSet,_classPrivateFieldLooseBase(BoolExpression,_BOOL_GRAMMAR)[_BOOL_GRAMMAR]);var parseTree=Parser.buildParseTree(expression,invertedS,_classPrivateFieldLooseBase(BoolExpression,_BOOL_GRAMMAR)[_BOOL_GRAMMAR]);if(parseTree!==null){_classPrivateFieldLooseBase(_this,_sSet)[_sSet]=sSet;_classPrivateFieldLooseBase(_this,_invertedS)[_invertedS]=invertedS;_classPrivateFieldLooseBase(_this,_parseTree)[_parseTree]=parseTree;_classPrivateFieldLooseBase(_this,_varBitSet)[_varBitSet]=getVarBitSet(expression);_classPrivateFieldLooseBase(_this,_varCount)[_varCount]=_classPrivateFieldLooseBase(_this,_varBitSet)[_varBitSet].cardinality();_classPrivateFieldLooseBase(_this,_minTerms)[_minTerms]=calculateMinTerms(parseTree,_classPrivateFieldLooseBase(_this,_varBitSet)[_varBitSet]);}else{var _QMFuncs$parseString=QMFuncs.parseString(expression),_QMFuncs$parseString2=_slicedToArray(_QMFuncs$parseString,3),parsed=_QMFuncs$parseString2[0],minTerms=_QMFuncs$parseString2[1],dontCares=_QMFuncs$parseString2[2];if(!parsed){_classPrivateFieldLooseBase(_this,_errorCode)[_errorCode]=-2;return false;}var _validateTerms=validateTerms(minTerms,dontCares),_validateTerms2=_slicedToArray(_validateTerms,2),validated=_validateTerms2[0],errorCode=_validateTerms2[1];if(!validated){_classPrivateFieldLooseBase(_this,_errorCode)[_errorCode]=errorCode;return false;}_classPrivateFieldLooseBase(_this,_varCount)[_varCount]=QMFuncs.getVariableCount(minTerms,dontCares);_classPrivateFieldLooseBase(_this,_minTerms)[_minTerms]=minTerms;_classPrivateFieldLooseBase(_this,_dontCares)[_dontCares]=dontCares;}if(_classPrivateFieldLooseBase(_this,_isLogged)[_isLogged]){_classPrivateFieldLooseBase(_this,_qmLog)[_qmLog]=[];_classPrivateFieldLooseBase(_this,_pmLog)[_pmLog]=[];}_classPrivateFieldLooseBase(_this,_reduce)[_reduce]();_classPrivateFieldLooseBase(_this,_buildTruthTable)[_buildTruthTable]();return true;};this.setMinTerms=function(minTerms,dontCares){var _validateTerms3=validateTerms(minTerms,dontCares),_validateTerms4=_slicedToArray(_validateTerms3,2),success=_validateTerms4[0],errorCode=_validateTerms4[1];if(!success){_classPrivateFieldLooseBase(_this,_errorCode)[_errorCode]=errorCode;return false;}_classPrivateFieldLooseBase(_this,_minTerms)[_minTerms]=minTerms;_classPrivateFieldLooseBase(_this,_dontCares)[_dontCares]=dontCares;_classPrivateFieldLooseBase(_this,_varCount)[_varCount]=QMFuncs.getVariableCount(minTerms,dontCares);_classPrivateFieldLooseBase(_this,_sSet)[_sSet]=null;_this.expression=null;_classPrivateFieldLooseBase(_this,_invertedS)[_invertedS]=null;_classPrivateFieldLooseBase(_this,_parseTree)[_parseTree]=null;_classPrivateFieldLooseBase(_this,_varBitSet)[_varBitSet]=null;if(_classPrivateFieldLooseBase(_this,_isLogged)[_isLogged]){_classPrivateFieldLooseBase(_this,_qmLog)[_qmLog]=[];_classPrivateFieldLooseBase(_this,_pmLog)[_pmLog]=[];}_classPrivateFieldLooseBase(_this,_reduce)[_reduce]();_classPrivateFieldLooseBase(_this,_buildTruthTable)[_buildTruthTable]();return true;};Object.defineProperty(this,_reduce,{writable:true,value:function value(){var nonEssentialPrimeImps=QMFuncs.getPrimeImplicants(_classPrivateFieldLooseBase(_this,_minTerms)[_minTerms],_classPrivateFieldLooseBase(_this,_dontCares)[_dontCares],_classPrivateFieldLooseBase(_this,_qmLog)[_qmLog]);_classPrivateFieldLooseBase(_this,_petrickSOP)[_petrickSOP]=PMFuncs.getPetrickSOP(nonEssentialPrimeImps,_classPrivateFieldLooseBase(_this,_minTerms)[_minTerms],_classPrivateFieldLooseBase(_this,_pmLog)[_pmLog]);_classPrivateFieldLooseBase(_this,_primeImps)[_primeImps]=QMFuncs.getEssentialTerms(nonEssentialPrimeImps,_classPrivateFieldLooseBase(_this,_minTerms)[_minTerms]);}});Object.defineProperty(this,_buildTruthTable,{writable:true,value:function value(){_classPrivateFieldLooseBase(_this,_truthTable)[_truthTable]=[];var varRow=[\"#\"];if(_classPrivateFieldLooseBase(_this,_varBitSet)[_varBitSet]){var setBits=_classPrivateFieldLooseBase(_this,_varBitSet)[_varBitSet].toArray();var _iterator4=_createForOfIteratorHelper(setBits),_step4;try{for(_iterator4.s();!(_step4=_iterator4.n()).done;){var bit=_step4.value;varRow.push(String.fromCharCode(bit+65));}}catch(err){_iterator4.e(err);}finally{_iterator4.f();}}else{for(var i=0;i<_classPrivateFieldLooseBase(_this,_varCount)[_varCount];i++){varRow.push(String.fromCharCode(i+65));}}varRow.push(\"Output\");_classPrivateFieldLooseBase(_this,_truthTable)[_truthTable].push(varRow);var rowCount=Math.pow(2,_classPrivateFieldLooseBase(_this,_varCount)[_varCount]);for(var _i=0;_i<rowCount;_i++){var row=[_i];var bits=new BitSet(_i);for(var j=0;j<_classPrivateFieldLooseBase(_this,_varCount)[_varCount];j++){row.push(parseInt(bits.get(_classPrivateFieldLooseBase(_this,_varCount)[_varCount]-1-j)));}row.push(_this.isMinTerm(_i)?\"1\":\"0\");_classPrivateFieldLooseBase(_this,_truthTable)[_truthTable].push(row);}}});this.toString=function(){if(_classPrivateFieldLooseBase(_this,_expression)[_expression])return _classPrivateFieldLooseBase(_this,_expression)[_expression];var str=\"m(\";var _iterator5=_createForOfIteratorHelper(_classPrivateFieldLooseBase(_this,_minTerms)[_minTerms]),_step5;try{for(_iterator5.s();!(_step5=_iterator5.n()).done;){var _term=_step5.value;str+=parseInt(_term)+\" \";}}catch(err){_iterator5.e(err);}finally{_iterator5.f();}str=str.substr(0,str.length-1)+\")\";if(_classPrivateFieldLooseBase(_this,_dontCares)[_dontCares].length){str+=\"+d(\";var _iterator6=_createForOfIteratorHelper(_classPrivateFieldLooseBase(_this,_dontCares)[_dontCares]),_step6;try{for(_iterator6.s();!(_step6=_iterator6.n()).done;){var term=_step6.value;str+=parseInt(term)+\" \";}}catch(err){_iterator6.e(err);}finally{_iterator6.f();}str=str.substr(0,str.length-1)+\")\";}return str;};if(!_expression2&&!_minTerms2&&!_dontCares2){throw new Error(\"null expression\");}_classPrivateFieldLooseBase(this,_minTerms)[_minTerms]=_minTerms2;_classPrivateFieldLooseBase(this,_dontCares)[_dontCares]=_dontCares2;_classPrivateFieldLooseBase(this,_expression)[_expression]=_expression2;_classPrivateFieldLooseBase(this,_isLogged)[_isLogged]=true;var _success;if(_expression2)_success=this.setExpression(_expression2);else _success=this.setMinTerms(_minTerms2,_dontCares2);if(!_success){if(_classPrivateFieldLooseBase(this,_errorCode)[_errorCode]===-1)throw new Error(\"cannot have 0 minimum terms\");else if(_classPrivateFieldLooseBase(this,_errorCode)[_errorCode]>=0)throw new Error(parseInt(_classPrivateFieldLooseBase(this,_errorCode)[_errorCode])+\" cannot be both a min term and a don't care\");else throw new Error(\"expression is not valid\");}}_createClass(BoolExpression,[{key:\"isEssentialImplicant\",value:function isEssentialImplicant(qmTerm){return _classPrivateFieldLooseBase(this,_primeImps)[_primeImps].some(function(e){return QMFuncs.isQMTermEqual(qmTerm,e);});}},{key:\"isMinTerm\",value:function isMinTerm(intTerm){return _classPrivateFieldLooseBase(this,_minTerms)[_minTerms].includes(intTerm);}},{key:\"isDontCare\",value:function isDontCare(intTerm){return _classPrivateFieldLooseBase(this,_dontCares)[_dontCares].includes(intTerm);}}],[{key:\"ExpressionInstance\",value:function ExpressionInstance(expression){var isLogged=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;return new BoolExpression(expression,null,null,isLogged);}},{key:\"MinTermInstance\",value:function MinTermInstance(minTerms,dontCares){var isLogged=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;return new BoolExpression(null,minTerms,dontCares,isLogged);}}]);return BoolExpression;}();Object.defineProperty(BoolExpression,_BOOL_GRAMMAR,{writable:true,value:buildBoolGrammar()});export{BoolExpression as default};","map":{"version":3,"sources":["C:/Users/Andrew/Documents/JavaScript Projects/bool-simp/src/scripts/BooleanSimplifier/BoolExpression.js"],"names":["buildBoolGrammar","deepCopy","validateTerms","getVarBitSet","calculateMinTerms","QMFuncs","PMFuncs","Recognizer","Parser","BitSet","BoolExpression","expression","minTerms","dontCares","isLogged","getMinTerms","getDontCares","getPetrickSOP","getEssentialImplicants","getVarCount","getQMLog","getPMLog","getTruthTable","getPrimeImpStrings","piStrs","implicant","str","extractMinTerms","term","parseInt","substring","length","toString","push","getSOPStrings","sopStrs","mapProductToString","productToString","product","setExpression","replace","sSet","buildItems","invertedS","invertEarleySets","parseTree","buildParseTree","cardinality","parseString","parsed","validated","errorCode","getVariableCount","setMinTerms","success","nonEssentialPrimeImps","getPrimeImplicants","getEssentialTerms","varRow","setBits","toArray","bit","String","fromCharCode","i","rowCount","row","bits","j","get","isMinTerm","substr","Error","qmTerm","some","e","isQMTermEqual","intTerm","includes"],"mappings":"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","sourcesContent":["import {\r\n    buildBoolGrammar,\r\n    deepCopy,\r\n    validateTerms,\r\n    getVarBitSet,\r\n    calculateMinTerms,\r\n} from \"./BoolExpressionUtils\";\r\nimport QMFuncs from \"./QMFunctions\";\r\nimport PMFuncs from \"./PMFunctions\";\r\nimport Recognizer from \"../Earley Parser/EarleyRecognizer\";\r\nimport Parser from \"../Earley Parser/EarleyParser\";\r\nimport BitSet from \"bitset\";\r\n\r\nexport default class BoolExpression {\r\n    #varCount;\r\n    #minTerms;\r\n    #dontCares;\r\n    #primeImps;\r\n    #petrickSOP;\r\n\r\n    #sSet;\r\n    #invertedS;\r\n    #parseTree;\r\n    #varBitSet;\r\n    #expression;\r\n\r\n    #errorCode = -2;\r\n    #isLogged = false;\r\n\r\n    #qmLog;\r\n    #pmLog;\r\n\r\n    #truthTable;\r\n\r\n    static #BOOL_GRAMMAR = buildBoolGrammar();\r\n\r\n    constructor(expression, minTerms, dontCares, isLogged = false) {\r\n        if (!expression && !minTerms && !dontCares) {\r\n            throw new Error(\"null expression\");\r\n        }\r\n\r\n        this.#minTerms = minTerms;\r\n        this.#dontCares = dontCares;\r\n        this.#expression = expression;\r\n        this.#isLogged = true;\r\n\r\n        let success;\r\n        if (expression) success = this.setExpression(expression);\r\n        else success = this.setMinTerms(minTerms, dontCares);\r\n\r\n        if (!success) {\r\n            if (this.#errorCode === -1) throw new Error(\"cannot have 0 minimum terms\");\r\n            else if (this.#errorCode >= 0)\r\n                throw new Error(\r\n                    parseInt(this.#errorCode) +\r\n                        \" cannot be both a min term and a don't care\"\r\n                );\r\n            else throw new Error(\"expression is not valid\");\r\n        }\r\n    }\r\n\r\n    static ExpressionInstance(expression, isLogged = false) {\r\n        return new BoolExpression(expression, null, null, isLogged);\r\n    }\r\n\r\n    static MinTermInstance(minTerms, dontCares, isLogged = false) {\r\n        return new BoolExpression(null, minTerms, dontCares, isLogged);\r\n    }\r\n\r\n    getMinTerms = () => deepCopy(this.#minTerms);\r\n    getDontCares = () => deepCopy(this.#dontCares);\r\n    getPetrickSOP = () => deepCopy(this.#petrickSOP);\r\n    getEssentialImplicants = () => deepCopy(this.#primeImps);\r\n    getVarCount = () => this.#varCount;\r\n\r\n    getQMLog = () => (this.#isLogged ? deepCopy(this.#qmLog) : []);\r\n    getPMLog = () => (this.#isLogged ? deepCopy(this.#pmLog) : []);\r\n\r\n    getTruthTable = () => deepCopy(this.#truthTable);\r\n\r\n    getPrimeImpStrings = () => {\r\n        let piStrs = [];\r\n        for (const implicant of this.#primeImps) {\r\n            let str = \"[\";\r\n            let minTerms = QMFuncs.extractMinTerms(implicant);\r\n            for (const term of minTerms) str += parseInt(term) + \"-\";\r\n            str = str.substring(0, str.length - 1) + \"] \";\r\n            str += QMFuncs.toString(implicant, this.#varCount);\r\n            piStrs.push(str);\r\n        }\r\n        return piStrs;\r\n    };\r\n\r\n    getSOPStrings = () => {\r\n        let sopStrs = [];\r\n        if (this.#petrickSOP.length === 0) {\r\n            if (this.#varBitSet)\r\n                sopStrs.push(PMFuncs.mapProductToString([], this.#varBitSet));\r\n            else sopStrs.push(PMFuncs.productToString([], this.#varCount));\r\n        } else {\r\n            for (const product of this.#petrickSOP) {\r\n                if (this.#varBitSet)\r\n                    sopStrs.push(PMFuncs.mapProductToString(product, this.#varBitSet));\r\n                else sopStrs.push(PMFuncs.productToString(product, this.#varCount));\r\n            }\r\n        }\r\n        return sopStrs;\r\n    };\r\n\r\n    setExpression = (expression) => {\r\n        expression = expression.replace(/ /g, \"\");\r\n        let sSet = Recognizer.buildItems(expression, BoolExpression.#BOOL_GRAMMAR);\r\n        let invertedS = Parser.invertEarleySets(sSet, BoolExpression.#BOOL_GRAMMAR);\r\n        let parseTree = Parser.buildParseTree(\r\n            expression,\r\n            invertedS,\r\n            BoolExpression.#BOOL_GRAMMAR\r\n        );\r\n\r\n        if (parseTree !== null) {\r\n            this.#sSet = sSet;\r\n            this.#invertedS = invertedS;\r\n            this.#parseTree = parseTree;\r\n\r\n            this.#varBitSet = getVarBitSet(expression);\r\n            this.#varCount = this.#varBitSet.cardinality();\r\n            this.#minTerms = calculateMinTerms(parseTree, this.#varBitSet);\r\n        } else {\r\n            let [parsed, minTerms, dontCares] = QMFuncs.parseString(expression);\r\n            if (!parsed) {\r\n                this.#errorCode = -2;\r\n                return false;\r\n            }\r\n\r\n            let [validated, errorCode] = validateTerms(minTerms, dontCares);\r\n            if (!validated) {\r\n                this.#errorCode = errorCode;\r\n                return false;\r\n            }\r\n\r\n            this.#varCount = QMFuncs.getVariableCount(minTerms, dontCares);\r\n            this.#minTerms = minTerms;\r\n            this.#dontCares = dontCares;\r\n        }\r\n\r\n        if (this.#isLogged) {\r\n            this.#qmLog = [];\r\n            this.#pmLog = [];\r\n        }\r\n\r\n        this.#reduce();\r\n        this.#buildTruthTable();\r\n\r\n        return true;\r\n    };\r\n\r\n    setMinTerms = (minTerms, dontCares) => {\r\n        let [success, errorCode] = validateTerms(minTerms, dontCares);\r\n        if (!success) {\r\n            this.#errorCode = errorCode;\r\n            return false;\r\n        }\r\n\r\n        this.#minTerms = minTerms;\r\n        this.#dontCares = dontCares;\r\n        this.#varCount = QMFuncs.getVariableCount(minTerms, dontCares);\r\n\r\n        this.#sSet = null;\r\n        this.expression = null;\r\n        this.#invertedS = null;\r\n        this.#parseTree = null;\r\n        this.#varBitSet = null;\r\n\r\n        if (this.#isLogged) {\r\n            this.#qmLog = [];\r\n            this.#pmLog = [];\r\n        }\r\n\r\n        this.#reduce();\r\n        this.#buildTruthTable();\r\n\r\n        return true;\r\n    };\r\n\r\n    #reduce = () => {\r\n        let nonEssentialPrimeImps = QMFuncs.getPrimeImplicants(\r\n            this.#minTerms,\r\n            this.#dontCares,\r\n            this.#qmLog\r\n        );\r\n\r\n        this.#petrickSOP = PMFuncs.getPetrickSOP(\r\n            nonEssentialPrimeImps,\r\n            this.#minTerms,\r\n            this.#pmLog\r\n        );\r\n\r\n        this.#primeImps = QMFuncs.getEssentialTerms(\r\n            nonEssentialPrimeImps,\r\n            this.#minTerms\r\n        );\r\n    };\r\n\r\n    #buildTruthTable = () => {\r\n        this.#truthTable = [];\r\n\r\n        let varRow = [\"#\"];\r\n        if (this.#varBitSet) {\r\n            let setBits = this.#varBitSet.toArray();\r\n            for (const bit of setBits) {\r\n                varRow.push(String.fromCharCode(bit + 65));\r\n            }\r\n        } else {\r\n            for (let i = 0; i < this.#varCount; i++) {\r\n                varRow.push(String.fromCharCode(i + 65));\r\n            }\r\n        }\r\n        varRow.push(\"Output\");\r\n        this.#truthTable.push(varRow);\r\n\r\n        let rowCount = 2 ** this.#varCount;\r\n        for (let i = 0; i < rowCount; i++) {\r\n            let row = [i];\r\n            let bits = new BitSet(i);\r\n            for (let j = 0; j < this.#varCount; j++) {\r\n                row.push(parseInt(bits.get(this.#varCount - 1 - j)));\r\n            }\r\n            row.push(this.isMinTerm(i) ? \"1\" : \"0\");\r\n            this.#truthTable.push(row);\r\n        }\r\n    };\r\n\r\n    toString = () => {\r\n        if (this.#expression) return this.#expression;\r\n\r\n        let str = \"m(\";\r\n        for (const term of this.#minTerms) str += parseInt(term) + \" \";\r\n        str = str.substr(0, str.length - 1) + \")\";\r\n\r\n        if (this.#dontCares.length) {\r\n            str += \"+d(\";\r\n            for (const term of this.#dontCares) str += parseInt(term) + \" \";\r\n            str = str.substr(0, str.length - 1) + \")\";\r\n        }\r\n\r\n        return str;\r\n    };\r\n\r\n    isEssentialImplicant(qmTerm) {\r\n        return this.#primeImps.some((e) => QMFuncs.isQMTermEqual(qmTerm, e));\r\n    }\r\n\r\n    isMinTerm(intTerm) {\r\n        return this.#minTerms.includes(intTerm);\r\n    }\r\n\r\n    isDontCare(intTerm) {\r\n        return this.#dontCares.includes(intTerm);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}