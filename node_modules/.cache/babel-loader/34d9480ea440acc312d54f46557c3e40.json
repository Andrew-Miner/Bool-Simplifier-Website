{"ast":null,"code":"import StructFactory from \"../StructFactory\";\nimport { Terminal, NonTerminal } from \"./Symbol\";\nconst Edge = StructFactory(\"startNode endNode data\");\nexport class ParseNode {\n  constructor(rule, label, children) {\n    this.rule = -1;\n    this.label = \"\";\n    this.children = [];\n    this.rule = rule;\n    this.label = label;\n    if (children === undefined || children === null) this.children = [];else this.children = children;\n  }\n\n}\nconst EarleyParser = {\n  sortEarleySets(s) {},\n\n  invertEarleySets(s, grammar, filterIncomplete = true) {\n    let inverted = [];\n    this.padEarleySets(s.length, inverted);\n\n    for (let i = 0; i < s.length; i++) {\n      for (let j = 0; j < s[i].length; j++) {\n        let item = s[i][j];\n        let rule = grammar.rules[item.rule];\n        if (filterIncomplete && rule.definition.length > item.next) continue;\n        let newSet = item.start;\n        item.start = i;\n        inverted[newSet].push(item);\n      }\n    }\n\n    return inverted;\n  },\n\n  padEarleySets(amount, s) {\n    for (let i = 0; i < amount; i++) {\n      s.push([]);\n    }\n  },\n\n  buildParseTree(input, invertedS, grammar) {\n    let completeItems = this.getEdges(0, input.length, invertedS);\n    if (completeItems.length === 0) return null;\n    let startingEdge = new Edge(0, input.length, completeItems[0].rule);\n    let root = new ParseNode(startingEdge.data, grammar.rules[startingEdge.data].name);\n\n    let aux = (edge, node) => {\n      let children = this.decomposeEdge(input, invertedS, grammar, edge);\n\n      for (const child of children) {\n        if (child.data === -1) {\n          node.children.push(new ParseNode(-1, input.substring(child.startNode, child.startNode + 1)));\n        } else {\n          let newNode = new ParseNode(child.data, grammar.rules[child.data].name);\n          node.children.push(newNode);\n          aux(child, newNode);\n        }\n      }\n    };\n\n    aux(startingEdge, root);\n    return root;\n  },\n\n  printParseTree(node, printRule = false) {\n    let aux = (node, indent, last) => {\n      let line = indent + \"+- \" + node.label;\n      if (printRule) line += \" (\" + node.rule + \")\";\n      console.log(line);\n      indent += last ? \"   \" : \"|  \";\n\n      for (let i = 0; i < node.children.length; i++) {\n        aux(node.children[i], indent, i === node.children.length - 1);\n      }\n    };\n\n    aux(node, \"\", true);\n  },\n\n  getParseTreeString(node, printRule = false) {\n    let string = \"\";\n\n    let aux = (node, indent, last) => {\n      let line = indent + \"+- \" + node.label;\n      if (printRule) line += \" (\" + node.rule + \")\";\n      string += line + \"\\n\";\n      indent += last ? \"   \" : \"|  \";\n\n      for (let i = 0; i < node.children.length; i++) {\n        aux(node.children[i], indent, i === node.children.length - 1);\n      }\n    };\n\n    aux(node, \"\", true);\n    return string;\n  },\n\n  getEdges(startNode, endNode, graph) {\n    console.assert(graph.length > startNode);\n    let edges = [];\n\n    for (const item of graph[startNode]) {\n      if (item.start === endNode) edges.push(item);\n    }\n\n    return edges;\n  },\n\n  decomposeEdge(input, graph, grammar, edge) {\n    console.assert(edge.startNode < graph.length);\n    console.assert(edge.endNode < graph.length);\n    console.assert(edge.data >= 0 && edge.data < grammar.rules.length);\n    const rules = grammar.rules[edge.data].definition;\n    let start = edge.startNode;\n    let finish = edge.endNode;\n    let bottom = rules.length;\n\n    let isLeaf = (node, depth) => {\n      return node === finish && depth === bottom;\n    };\n\n    let getChild = (edge, depth) => {\n      return edge.endNode;\n    };\n\n    let getEdges = (node, depth) => {\n      if (depth >= rules.length) return [];\n      let edges = [];\n      let symbol = rules[depth];\n\n      if (symbol instanceof Terminal) {\n        if (symbol.match(input.substring(node, node + 1))) edges.push(new Edge(node, node + 1, -1));\n      } else if (symbol instanceof NonTerminal) {\n        for (const item of graph[node]) {\n          if (symbol.match(grammar.rules[item.rule].name)) edges.push(new Edge(node, item.start, item.rule));\n        }\n      }\n\n      return edges;\n    };\n\n    return this.depthFirstSearch(start, getEdges, isLeaf, getChild);\n  },\n\n  depthFirstSearch(root, funcGetEdges, funcIsLeaf, funcGetChild) {\n    let path = [];\n\n    let aux = (node, depth) => {\n      if (funcIsLeaf(node, depth)) return true;\n      let edges = funcGetEdges(node, depth);\n\n      for (const edge of edges) {\n        let child = funcGetChild(edge, depth);\n\n        if (aux(child, depth + 1)) {\n          path.unshift(edge);\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    aux(root, 0);\n    return path;\n  },\n\n  applySemanticAction(tokenHandler, root, actions) {\n    let aux = node => {\n      // if node is a leaf node\n      if (node.rule === -1) {\n        return tokenHandler(node.label);\n      } else {\n        let processedChildren = [];\n\n        for (const child of node.children) {\n          processedChildren.push(aux(child));\n        }\n\n        return actions[node.rule](...processedChildren);\n      }\n    };\n\n    return aux(root);\n  }\n\n};\nexport default EarleyParser;","map":{"version":3,"sources":["C:/Users/Andrew/Documents/JavaScript Projects/bool-simp/src/scripts/Earley Parser/EarleyParser.js"],"names":["StructFactory","Terminal","NonTerminal","Edge","ParseNode","constructor","rule","label","children","undefined","EarleyParser","sortEarleySets","s","invertEarleySets","grammar","filterIncomplete","inverted","padEarleySets","length","i","j","item","rules","definition","next","newSet","start","push","amount","buildParseTree","input","invertedS","completeItems","getEdges","startingEdge","root","data","name","aux","edge","node","decomposeEdge","child","substring","startNode","newNode","printParseTree","printRule","indent","last","line","console","log","getParseTreeString","string","endNode","graph","assert","edges","finish","bottom","isLeaf","depth","getChild","symbol","match","depthFirstSearch","funcGetEdges","funcIsLeaf","funcGetChild","path","unshift","applySemanticAction","tokenHandler","actions","processedChildren"],"mappings":"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","sourcesContent":["import StructFactory from \"../StructFactory\";\r\nimport { Terminal, NonTerminal } from \"./Symbol\";\r\n\r\nconst Edge = StructFactory(\"startNode endNode data\");\r\n\r\nexport class ParseNode {\r\n    rule = -1;\r\n    label = \"\";\r\n    children = [];\r\n\r\n    constructor(rule, label, children) {\r\n        this.rule = rule;\r\n        this.label = label;\r\n\r\n        if (children === undefined || children === null) this.children = [];\r\n        else this.children = children;\r\n    }\r\n}\r\n\r\nconst EarleyParser = {\r\n    sortEarleySets(s) {},\r\n\r\n    invertEarleySets(s, grammar, filterIncomplete = true) {\r\n        let inverted = [];\r\n        this.padEarleySets(s.length, inverted);\r\n\r\n        for (let i = 0; i < s.length; i++) {\r\n            for (let j = 0; j < s[i].length; j++) {\r\n                let item = s[i][j];\r\n                let rule = grammar.rules[item.rule];\r\n\r\n                if (filterIncomplete && rule.definition.length > item.next) continue;\r\n\r\n                let newSet = item.start;\r\n                item.start = i;\r\n                inverted[newSet].push(item);\r\n            }\r\n        }\r\n\r\n        return inverted;\r\n    },\r\n\r\n    padEarleySets(amount, s) {\r\n        for (let i = 0; i < amount; i++) {\r\n            s.push([]);\r\n        }\r\n    },\r\n\r\n    buildParseTree(input, invertedS, grammar) {\r\n        let completeItems = this.getEdges(0, input.length, invertedS);\r\n        if (completeItems.length === 0) return null;\r\n\r\n        let startingEdge = new Edge(0, input.length, completeItems[0].rule);\r\n        let root = new ParseNode(\r\n            startingEdge.data,\r\n            grammar.rules[startingEdge.data].name\r\n        );\r\n\r\n        let aux = (edge, node) => {\r\n            let children = this.decomposeEdge(input, invertedS, grammar, edge);\r\n            for (const child of children) {\r\n                if (child.data === -1) {\r\n                    node.children.push(\r\n                        new ParseNode(\r\n                            -1,\r\n                            input.substring(child.startNode, child.startNode + 1)\r\n                        )\r\n                    );\r\n                } else {\r\n                    let newNode = new ParseNode(\r\n                        child.data,\r\n                        grammar.rules[child.data].name\r\n                    );\r\n                    node.children.push(newNode);\r\n                    aux(child, newNode);\r\n                }\r\n            }\r\n        };\r\n\r\n        aux(startingEdge, root);\r\n        return root;\r\n    },\r\n\r\n    printParseTree(node, printRule = false) {\r\n        let aux = (node, indent, last) => {\r\n            let line = indent + \"+- \" + node.label;\r\n            if (printRule) line += \" (\" + node.rule + \")\";\r\n            console.log(line);\r\n\r\n            indent += last ? \"   \" : \"|  \";\r\n\r\n            for (let i = 0; i < node.children.length; i++) {\r\n                aux(node.children[i], indent, i === node.children.length - 1);\r\n            }\r\n        };\r\n\r\n        aux(node, \"\", true);\r\n    },\r\n\r\n    getParseTreeString(node, printRule = false) {\r\n        let string = \"\";\r\n        let aux = (node, indent, last) => {\r\n            let line = indent + \"+- \" + node.label;\r\n            if (printRule) line += \" (\" + node.rule + \")\";\r\n            string += line + \"\\n\";\r\n\r\n            indent += last ? \"   \" : \"|  \";\r\n\r\n            for (let i = 0; i < node.children.length; i++) {\r\n                aux(node.children[i], indent, i === node.children.length - 1);\r\n            }\r\n        };\r\n\r\n        aux(node, \"\", true);\r\n        return string;\r\n    },\r\n\r\n    getEdges(startNode, endNode, graph) {\r\n        console.assert(graph.length > startNode);\r\n\r\n        let edges = [];\r\n        for (const item of graph[startNode]) {\r\n            if (item.start === endNode) edges.push(item);\r\n        }\r\n        return edges;\r\n    },\r\n\r\n    decomposeEdge(input, graph, grammar, edge) {\r\n        console.assert(edge.startNode < graph.length);\r\n        console.assert(edge.endNode < graph.length);\r\n        console.assert(edge.data >= 0 && edge.data < grammar.rules.length);\r\n\r\n        const rules = grammar.rules[edge.data].definition;\r\n\r\n        let start = edge.startNode;\r\n        let finish = edge.endNode;\r\n        let bottom = rules.length;\r\n\r\n        let isLeaf = (node, depth) => {\r\n            return node === finish && depth === bottom;\r\n        };\r\n\r\n        let getChild = (edge, depth) => {\r\n            return edge.endNode;\r\n        };\r\n\r\n        let getEdges = (node, depth) => {\r\n            if (depth >= rules.length) return [];\r\n\r\n            let edges = [];\r\n            let symbol = rules[depth];\r\n\r\n            if (symbol instanceof Terminal) {\r\n                if (symbol.match(input.substring(node, node + 1)))\r\n                    edges.push(new Edge(node, node + 1, -1));\r\n            } else if (symbol instanceof NonTerminal) {\r\n                for (const item of graph[node]) {\r\n                    if (symbol.match(grammar.rules[item.rule].name))\r\n                        edges.push(new Edge(node, item.start, item.rule));\r\n                }\r\n            }\r\n            return edges;\r\n        };\r\n\r\n        return this.depthFirstSearch(start, getEdges, isLeaf, getChild);\r\n    },\r\n\r\n    depthFirstSearch(root, funcGetEdges, funcIsLeaf, funcGetChild) {\r\n        let path = [];\r\n        let aux = (node, depth) => {\r\n            if (funcIsLeaf(node, depth)) return true;\r\n            let edges = funcGetEdges(node, depth);\r\n            for (const edge of edges) {\r\n                let child = funcGetChild(edge, depth);\r\n                if (aux(child, depth + 1)) {\r\n                    path.unshift(edge);\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n        aux(root, 0);\r\n        return path;\r\n    },\r\n\r\n    applySemanticAction(tokenHandler, root, actions) {\r\n        let aux = (node) => {\r\n            // if node is a leaf node\r\n            if (node.rule === -1) {\r\n                return tokenHandler(node.label);\r\n            } else {\r\n                let processedChildren = [];\r\n                for (const child of node.children) {\r\n                    processedChildren.push(aux(child));\r\n                }\r\n                return actions[node.rule](...processedChildren);\r\n            }\r\n        };\r\n        return aux(root);\r\n    },\r\n};\r\n\r\nexport default EarleyParser;\r\n"]},"metadata":{},"sourceType":"module"}