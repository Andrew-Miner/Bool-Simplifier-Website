{"ast":null,"code":"import { BOOL_GRAMMAR, BOOL_CALC_ACTIONS } from \"./BoolExpressionGrammar\";\nimport Recognizer from \"../Earley Parser/EarleyRecognizer\";\nimport Parser, { ParseNode } from \"../Earley Parser/EarleyParser\";\nimport { bnfGrammar, bnfActions, interpretBNF } from \"../Earley Parser/BNFInterpreter\";\nimport BoolExpression from \"./BoolExpression\";\nexport default function boolMain(expStr) {\n  try {\n    let exp = BoolExpression.ExpressionInstance(expStr, true);\n    console.log(\"Expression: \", exp.toString());\n    console.log(\"Min Terms: \", exp.getMinTerms());\n    console.log(\"Var Count: \", exp.getVarCount());\n    console.log(\"Prime Implicants: \", exp.getPrimeImplicants());\n    console.log(\"Petrick SOP: \", exp.getPetrickSOP()); // Print Prime Implicants\n\n    for (const implicant of exp.getPrimeImpStrings()) {\n      console.log(implicant);\n    }\n\n    let petrickSOP = exp.getSOPStrings();\n\n    for (let i = 0; i < petrickSOP.length; i++) {\n      console.log(\"Solution \", i + 1, \": \", petrickSOP[i]);\n    }\n\n    let test = exp.getQMLog();\n    console.log(\"QM Log: \", test);\n    console.log(\"PM Log: \", exp.getPMLog());\n  } catch (error) {\n    console.log(error);\n  }\n}\nexport function buildBoolGrammar() {\n  try {\n    let grammar = BOOL_GRAMMAR.replaceAll(\"\\\\n\", \"\\n\");\n    let s = Recognizer.buildItems(grammar, bnfGrammar);\n    let invertedS = Parser.invertEarleySets(s, bnfGrammar);\n    let parseTree = Parser.buildParseTree(grammar, invertedS, bnfGrammar);\n\n    if (parseTree === null) {\n      throw new Error(\"invalid grammar\");\n    }\n\n    let simplifiedTree = Parser.applySemanticAction(token => new ParseNode(-1, token), parseTree, bnfActions);\n    return interpretBNF(simplifiedTree);\n  } catch (error) {\n    console.log(error);\n    return null;\n  }\n}\nexport function calculateMinTerms(expStr, parseTree, varBitSet) {\n  let varCount = varBitSet.cardinality();\n  let minTerms = []; // array to be filled with minTerms\n\n  let rowCount = 2 ** varCount;\n\n  for (let i = rowCount - 1; i >= 0; i--) {\n    let normalizedVariables = BitSet(i);\n    let boolVal = calculateExpression(parseTree, varBitSet, normalizedVariables);\n    if (boolVal) minTerms.push(i);\n  }\n\n  return minTerms;\n}\n\nfunction calculateExpression(parseTree, varBitSet, normVars) {\n  let semanticActions = BOOL_CALC_ACTIONS.slice();\n  let varCount = varBitSet.cardinality();\n  let varPos = 0;\n\n  for (let i = 0; i < 26; i++) {\n    if (varBitSet.get(i) === 0) continue;\n    let bool = normVars.get(varCount - 1 - varPos++);\n\n    if (bool) {\n      semanticActions[i + semanticActions.length - 52] = () => true;\n\n      semanticActions[i + semanticActions.length - 26] = () => true;\n    } else {\n      semanticActions[i + semanticActions.length - 52] = () => false;\n\n      semanticActions[i + semanticActions.length - 26] = () => false;\n    }\n  }\n\n  return Parser.applySemanticAction(token => token, parseTree, semanticActions);\n}\n\nexport function validateTerms(minTerms, dontCares) {\n  if (minTerms.length === 0) return [false, -1];\n\n  for (const term of dontCares) if (minTerms.includes(term)) return [false, term];\n\n  return [true, -2];\n}\nexport function getVarBitSet(expStr) {\n  let variables = new BitSet();\n\n  for (let i = 0; i < expStr.length; i++) {\n    if (/[A-Z]/.test(expStr[i])) {\n      variables.set(expStr.charCodeAt(i) - 65, 1);\n    }\n  }\n\n  return variables;\n}\nexport function deepCopy(src) {\n  let target = Array.isArray(src) ? [] : {};\n\n  for (let key in src) {\n    let v = src[key];\n\n    if (v) {\n      if (typeof v === \"object\") {\n        target[key] = deepCopy(v);\n      } else {\n        target[key] = v;\n      }\n    } else {\n      target[key] = v;\n    }\n  }\n\n  return target;\n}","map":{"version":3,"sources":["C:/Users/Andrew/Documents/JavaScript Projects/bool-simp/src/scripts/BooleanSimplifier/BoolExpressionUtils.js"],"names":["BOOL_GRAMMAR","BOOL_CALC_ACTIONS","Recognizer","Parser","ParseNode","bnfGrammar","bnfActions","interpretBNF","BoolExpression","boolMain","expStr","exp","ExpressionInstance","console","log","toString","getMinTerms","getVarCount","getPrimeImplicants","getPetrickSOP","implicant","getPrimeImpStrings","petrickSOP","getSOPStrings","i","length","test","getQMLog","getPMLog","error","buildBoolGrammar","grammar","replaceAll","s","buildItems","invertedS","invertEarleySets","parseTree","buildParseTree","Error","simplifiedTree","applySemanticAction","token","calculateMinTerms","varBitSet","varCount","cardinality","minTerms","rowCount","normalizedVariables","BitSet","boolVal","calculateExpression","push","normVars","semanticActions","slice","varPos","get","bool","validateTerms","dontCares","term","includes","getVarBitSet","variables","set","charCodeAt","deepCopy","src","target","Array","isArray","key","v"],"mappings":"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","sourcesContent":["import { BOOL_GRAMMAR, BOOL_CALC_ACTIONS } from \"./BoolExpressionGrammar\";\r\nimport Recognizer from \"../Earley Parser/EarleyRecognizer\";\r\nimport Parser, { ParseNode } from \"../Earley Parser/EarleyParser\";\r\n\r\nimport { bnfGrammar, bnfActions, interpretBNF } from \"../Earley Parser/BNFInterpreter\";\r\nimport BoolExpression from \"./BoolExpression\";\r\n\r\nexport default function boolMain(expStr) {\r\n    try {\r\n        let exp = BoolExpression.ExpressionInstance(expStr, true);\r\n\r\n        console.log(\"Expression: \", exp.toString());\r\n        console.log(\"Min Terms: \", exp.getMinTerms());\r\n        console.log(\"Var Count: \", exp.getVarCount());\r\n        console.log(\"Prime Implicants: \", exp.getPrimeImplicants());\r\n        console.log(\"Petrick SOP: \", exp.getPetrickSOP());\r\n        // Print Prime Implicants\r\n        for (const implicant of exp.getPrimeImpStrings()) {\r\n            console.log(implicant);\r\n        }\r\n\r\n        let petrickSOP = exp.getSOPStrings();\r\n        for (let i = 0; i < petrickSOP.length; i++) {\r\n            console.log(\"Solution \", i + 1, \": \", petrickSOP[i]);\r\n        }\r\n\r\n        let test = exp.getQMLog();\r\n        console.log(\"QM Log: \", test);\r\n        console.log(\"PM Log: \", exp.getPMLog());\r\n    } catch (error) {\r\n        console.log(error);\r\n    }\r\n}\r\n\r\nexport function buildBoolGrammar() {\r\n    try {\r\n        let grammar = BOOL_GRAMMAR.replaceAll(\"\\\\n\", \"\\n\");\r\n        let s = Recognizer.buildItems(grammar, bnfGrammar);\r\n        let invertedS = Parser.invertEarleySets(s, bnfGrammar);\r\n        let parseTree = Parser.buildParseTree(grammar, invertedS, bnfGrammar);\r\n\r\n        if (parseTree === null) {\r\n            throw new Error(\"invalid grammar\");\r\n        }\r\n\r\n        let simplifiedTree = Parser.applySemanticAction(\r\n            (token) => new ParseNode(-1, token),\r\n            parseTree,\r\n            bnfActions\r\n        );\r\n\r\n        return interpretBNF(simplifiedTree);\r\n    } catch (error) {\r\n        console.log(error);\r\n        return null;\r\n    }\r\n}\r\n\r\nexport function calculateMinTerms(expStr, parseTree, varBitSet) {\r\n    let varCount = varBitSet.cardinality();\r\n    let minTerms = []; // array to be filled with minTerms\r\n    let rowCount = 2 ** varCount;\r\n\r\n    for (let i = rowCount - 1; i >= 0; i--) {\r\n        let normalizedVariables = BitSet(i);\r\n        let boolVal = calculateExpression(parseTree, varBitSet, normalizedVariables);\r\n        if (boolVal) minTerms.push(i);\r\n    }\r\n    return minTerms;\r\n}\r\n\r\nfunction calculateExpression(parseTree, varBitSet, normVars) {\r\n    let semanticActions = BOOL_CALC_ACTIONS.slice();\r\n    let varCount = varBitSet.cardinality();\r\n\r\n    let varPos = 0;\r\n    for (let i = 0; i < 26; i++) {\r\n        if (varBitSet.get(i) === 0) continue;\r\n        let bool = normVars.get(varCount - 1 - varPos++);\r\n        if (bool) {\r\n            semanticActions[i + semanticActions.length - 52] = () => true;\r\n            semanticActions[i + semanticActions.length - 26] = () => true;\r\n        } else {\r\n            semanticActions[i + semanticActions.length - 52] = () => false;\r\n            semanticActions[i + semanticActions.length - 26] = () => false;\r\n        }\r\n    }\r\n\r\n    return Parser.applySemanticAction((token) => token, parseTree, semanticActions);\r\n}\r\n\r\nexport function validateTerms(minTerms, dontCares) {\r\n    if (minTerms.length === 0) return [false, -1];\r\n    for (const term of dontCares) if (minTerms.includes(term)) return [false, term];\r\n    return [true, -2];\r\n}\r\n\r\nexport function getVarBitSet(expStr) {\r\n    let variables = new BitSet();\r\n    for (let i = 0; i < expStr.length; i++) {\r\n        if (/[A-Z]/.test(expStr[i])) {\r\n            variables.set(expStr.charCodeAt(i) - 65, 1);\r\n        }\r\n    }\r\n    return variables;\r\n}\r\n\r\nexport function deepCopy(src) {\r\n    let target = Array.isArray(src) ? [] : {};\r\n    for (let key in src) {\r\n        let v = src[key];\r\n        if (v) {\r\n            if (typeof v === \"object\") {\r\n                target[key] = deepCopy(v);\r\n            } else {\r\n                target[key] = v;\r\n            }\r\n        } else {\r\n            target[key] = v;\r\n        }\r\n    }\r\n\r\n    return target;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}