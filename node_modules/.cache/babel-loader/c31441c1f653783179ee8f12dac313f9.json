{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _isValidIdentifier = require(\"../validators/isValidIdentifier\");\n\nvar _generated = require(\"../builders/generated\");\n\nvar _default = valueToNode;\nexports.default = _default;\nconst objectToString = Function.call.bind(Object.prototype.toString);\n\nfunction isRegExp(value) {\n  return objectToString(value) === \"[object RegExp]\";\n}\n\nfunction isPlainObject(value) {\n  if (typeof value !== \"object\" || value === null || Object.prototype.toString.call(value) !== \"[object Object]\") {\n    return false;\n  }\n\n  const proto = Object.getPrototypeOf(value);\n  return proto === null || Object.getPrototypeOf(proto) === null;\n}\n\nfunction valueToNode(value) {\n  if (value === undefined) {\n    return (0, _generated.identifier)(\"undefined\");\n  }\n\n  if (value === true || value === false) {\n    return (0, _generated.booleanLiteral)(value);\n  }\n\n  if (value === null) {\n    return (0, _generated.nullLiteral)();\n  }\n\n  if (typeof value === \"string\") {\n    return (0, _generated.stringLiteral)(value);\n  }\n\n  if (typeof value === \"number\") {\n    let result;\n\n    if (Number.isFinite(value)) {\n      result = (0, _generated.numericLiteral)(Math.abs(value));\n    } else {\n      let numerator;\n\n      if (Number.isNaN(value)) {\n        numerator = (0, _generated.numericLiteral)(0);\n      } else {\n        numerator = (0, _generated.numericLiteral)(1);\n      }\n\n      result = (0, _generated.binaryExpression)(\"/\", numerator, (0, _generated.numericLiteral)(0));\n    }\n\n    if (value < 0 || Object.is(value, -0)) {\n      result = (0, _generated.unaryExpression)(\"-\", result);\n    }\n\n    return result;\n  }\n\n  if (isRegExp(value)) {\n    const pattern = value.source;\n    const flags = value.toString().match(/\\/([a-z]+|)$/)[1];\n    return (0, _generated.regExpLiteral)(pattern, flags);\n  }\n\n  if (Array.isArray(value)) {\n    return (0, _generated.arrayExpression)(value.map(valueToNode));\n  }\n\n  if (isPlainObject(value)) {\n    const props = [];\n\n    for (const key of Object.keys(value)) {\n      let nodeKey;\n\n      if ((0, _isValidIdentifier.default)(key)) {\n        nodeKey = (0, _generated.identifier)(key);\n      } else {\n        nodeKey = (0, _generated.stringLiteral)(key);\n      }\n\n      props.push((0, _generated.objectProperty)(nodeKey, valueToNode(value[key])));\n    }\n\n    return (0, _generated.objectExpression)(props);\n  }\n\n  throw new Error(\"don't know how to turn this value into a node\");\n}","map":{"version":3,"sources":["C:/Users/Andrew/Documents/JavaScript Projects/bool-simp/node_modules/@babel/types/lib/converters/valueToNode.js"],"names":["Object","defineProperty","exports","value","default","_isValidIdentifier","require","_generated","_default","valueToNode","objectToString","Function","call","bind","prototype","toString","isRegExp","isPlainObject","proto","getPrototypeOf","undefined","identifier","booleanLiteral","nullLiteral","stringLiteral","result","Number","isFinite","numericLiteral","Math","abs","numerator","isNaN","binaryExpression","is","unaryExpression","pattern","source","flags","match","regExpLiteral","Array","isArray","arrayExpression","map","props","key","keys","nodeKey","push","objectProperty","objectExpression","Error"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkB,KAAK,CAAvB;;AAEA,IAAIC,kBAAkB,GAAGC,OAAO,CAAC,iCAAD,CAAhC;;AAEA,IAAIC,UAAU,GAAGD,OAAO,CAAC,uBAAD,CAAxB;;AAEA,IAAIE,QAAQ,GAAGC,WAAf;AACAP,OAAO,CAACE,OAAR,GAAkBI,QAAlB;AACA,MAAME,cAAc,GAAGC,QAAQ,CAACC,IAAT,CAAcC,IAAd,CAAmBb,MAAM,CAACc,SAAP,CAAiBC,QAApC,CAAvB;;AAEA,SAASC,QAAT,CAAkBb,KAAlB,EAAyB;AACvB,SAAOO,cAAc,CAACP,KAAD,CAAd,KAA0B,iBAAjC;AACD;;AAED,SAASc,aAAT,CAAuBd,KAAvB,EAA8B;AAC5B,MAAI,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,KAAK,IAAvC,IAA+CH,MAAM,CAACc,SAAP,CAAiBC,QAAjB,CAA0BH,IAA1B,CAA+BT,KAA/B,MAA0C,iBAA7F,EAAgH;AAC9G,WAAO,KAAP;AACD;;AAED,QAAMe,KAAK,GAAGlB,MAAM,CAACmB,cAAP,CAAsBhB,KAAtB,CAAd;AACA,SAAOe,KAAK,KAAK,IAAV,IAAkBlB,MAAM,CAACmB,cAAP,CAAsBD,KAAtB,MAAiC,IAA1D;AACD;;AAED,SAAST,WAAT,CAAqBN,KAArB,EAA4B;AAC1B,MAAIA,KAAK,KAAKiB,SAAd,EAAyB;AACvB,WAAO,CAAC,GAAGb,UAAU,CAACc,UAAf,EAA2B,WAA3B,CAAP;AACD;;AAED,MAAIlB,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAK,KAAhC,EAAuC;AACrC,WAAO,CAAC,GAAGI,UAAU,CAACe,cAAf,EAA+BnB,KAA/B,CAAP;AACD;;AAED,MAAIA,KAAK,KAAK,IAAd,EAAoB;AAClB,WAAO,CAAC,GAAGI,UAAU,CAACgB,WAAf,GAAP;AACD;;AAED,MAAI,OAAOpB,KAAP,KAAiB,QAArB,EAA+B;AAC7B,WAAO,CAAC,GAAGI,UAAU,CAACiB,aAAf,EAA8BrB,KAA9B,CAAP;AACD;;AAED,MAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC7B,QAAIsB,MAAJ;;AAEA,QAAIC,MAAM,CAACC,QAAP,CAAgBxB,KAAhB,CAAJ,EAA4B;AAC1BsB,MAAAA,MAAM,GAAG,CAAC,GAAGlB,UAAU,CAACqB,cAAf,EAA+BC,IAAI,CAACC,GAAL,CAAS3B,KAAT,CAA/B,CAAT;AACD,KAFD,MAEO;AACL,UAAI4B,SAAJ;;AAEA,UAAIL,MAAM,CAACM,KAAP,CAAa7B,KAAb,CAAJ,EAAyB;AACvB4B,QAAAA,SAAS,GAAG,CAAC,GAAGxB,UAAU,CAACqB,cAAf,EAA+B,CAA/B,CAAZ;AACD,OAFD,MAEO;AACLG,QAAAA,SAAS,GAAG,CAAC,GAAGxB,UAAU,CAACqB,cAAf,EAA+B,CAA/B,CAAZ;AACD;;AAEDH,MAAAA,MAAM,GAAG,CAAC,GAAGlB,UAAU,CAAC0B,gBAAf,EAAiC,GAAjC,EAAsCF,SAAtC,EAAiD,CAAC,GAAGxB,UAAU,CAACqB,cAAf,EAA+B,CAA/B,CAAjD,CAAT;AACD;;AAED,QAAIzB,KAAK,GAAG,CAAR,IAAaH,MAAM,CAACkC,EAAP,CAAU/B,KAAV,EAAiB,CAAC,CAAlB,CAAjB,EAAuC;AACrCsB,MAAAA,MAAM,GAAG,CAAC,GAAGlB,UAAU,CAAC4B,eAAf,EAAgC,GAAhC,EAAqCV,MAArC,CAAT;AACD;;AAED,WAAOA,MAAP;AACD;;AAED,MAAIT,QAAQ,CAACb,KAAD,CAAZ,EAAqB;AACnB,UAAMiC,OAAO,GAAGjC,KAAK,CAACkC,MAAtB;AACA,UAAMC,KAAK,GAAGnC,KAAK,CAACY,QAAN,GAAiBwB,KAAjB,CAAuB,cAAvB,EAAuC,CAAvC,CAAd;AACA,WAAO,CAAC,GAAGhC,UAAU,CAACiC,aAAf,EAA8BJ,OAA9B,EAAuCE,KAAvC,CAAP;AACD;;AAED,MAAIG,KAAK,CAACC,OAAN,CAAcvC,KAAd,CAAJ,EAA0B;AACxB,WAAO,CAAC,GAAGI,UAAU,CAACoC,eAAf,EAAgCxC,KAAK,CAACyC,GAAN,CAAUnC,WAAV,CAAhC,CAAP;AACD;;AAED,MAAIQ,aAAa,CAACd,KAAD,CAAjB,EAA0B;AACxB,UAAM0C,KAAK,GAAG,EAAd;;AAEA,SAAK,MAAMC,GAAX,IAAkB9C,MAAM,CAAC+C,IAAP,CAAY5C,KAAZ,CAAlB,EAAsC;AACpC,UAAI6C,OAAJ;;AAEA,UAAI,CAAC,GAAG3C,kBAAkB,CAACD,OAAvB,EAAgC0C,GAAhC,CAAJ,EAA0C;AACxCE,QAAAA,OAAO,GAAG,CAAC,GAAGzC,UAAU,CAACc,UAAf,EAA2ByB,GAA3B,CAAV;AACD,OAFD,MAEO;AACLE,QAAAA,OAAO,GAAG,CAAC,GAAGzC,UAAU,CAACiB,aAAf,EAA8BsB,GAA9B,CAAV;AACD;;AAEDD,MAAAA,KAAK,CAACI,IAAN,CAAW,CAAC,GAAG1C,UAAU,CAAC2C,cAAf,EAA+BF,OAA/B,EAAwCvC,WAAW,CAACN,KAAK,CAAC2C,GAAD,CAAN,CAAnD,CAAX;AACD;;AAED,WAAO,CAAC,GAAGvC,UAAU,CAAC4C,gBAAf,EAAiCN,KAAjC,CAAP;AACD;;AAED,QAAM,IAAIO,KAAJ,CAAU,+CAAV,CAAN;AACD","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _isValidIdentifier = require(\"../validators/isValidIdentifier\");\n\nvar _generated = require(\"../builders/generated\");\n\nvar _default = valueToNode;\nexports.default = _default;\nconst objectToString = Function.call.bind(Object.prototype.toString);\n\nfunction isRegExp(value) {\n  return objectToString(value) === \"[object RegExp]\";\n}\n\nfunction isPlainObject(value) {\n  if (typeof value !== \"object\" || value === null || Object.prototype.toString.call(value) !== \"[object Object]\") {\n    return false;\n  }\n\n  const proto = Object.getPrototypeOf(value);\n  return proto === null || Object.getPrototypeOf(proto) === null;\n}\n\nfunction valueToNode(value) {\n  if (value === undefined) {\n    return (0, _generated.identifier)(\"undefined\");\n  }\n\n  if (value === true || value === false) {\n    return (0, _generated.booleanLiteral)(value);\n  }\n\n  if (value === null) {\n    return (0, _generated.nullLiteral)();\n  }\n\n  if (typeof value === \"string\") {\n    return (0, _generated.stringLiteral)(value);\n  }\n\n  if (typeof value === \"number\") {\n    let result;\n\n    if (Number.isFinite(value)) {\n      result = (0, _generated.numericLiteral)(Math.abs(value));\n    } else {\n      let numerator;\n\n      if (Number.isNaN(value)) {\n        numerator = (0, _generated.numericLiteral)(0);\n      } else {\n        numerator = (0, _generated.numericLiteral)(1);\n      }\n\n      result = (0, _generated.binaryExpression)(\"/\", numerator, (0, _generated.numericLiteral)(0));\n    }\n\n    if (value < 0 || Object.is(value, -0)) {\n      result = (0, _generated.unaryExpression)(\"-\", result);\n    }\n\n    return result;\n  }\n\n  if (isRegExp(value)) {\n    const pattern = value.source;\n    const flags = value.toString().match(/\\/([a-z]+|)$/)[1];\n    return (0, _generated.regExpLiteral)(pattern, flags);\n  }\n\n  if (Array.isArray(value)) {\n    return (0, _generated.arrayExpression)(value.map(valueToNode));\n  }\n\n  if (isPlainObject(value)) {\n    const props = [];\n\n    for (const key of Object.keys(value)) {\n      let nodeKey;\n\n      if ((0, _isValidIdentifier.default)(key)) {\n        nodeKey = (0, _generated.identifier)(key);\n      } else {\n        nodeKey = (0, _generated.stringLiteral)(key);\n      }\n\n      props.push((0, _generated.objectProperty)(nodeKey, valueToNode(value[key])));\n    }\n\n    return (0, _generated.objectExpression)(props);\n  }\n\n  throw new Error(\"don't know how to turn this value into a node\");\n}"]},"metadata":{},"sourceType":"script"}