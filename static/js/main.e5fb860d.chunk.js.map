{"version":3,"sources":["scripts/StructFactory.js","scripts/Earley Parser/Symbol.js","scripts/BooleanSimplifier/BoolExpressionGrammar.js","scripts/Earley Parser/EarleyParser.js","scripts/Earley Parser/BNFInterpreter.js","scripts/BooleanSimplifier/BoolExpressionUtils.js","scripts/BooleanSimplifier/QMFunctions.js","scripts/BooleanSimplifier/PMFunctions.js","scripts/BooleanSimplifier/BoolExpression.js","components/OperatorTable.jsx","components/ExampleGroup.jsx","components/AboutAccordion.jsx","components/ExpressionForm.jsx","components/QMCard.jsx","components/QMLog.jsx","components/PMLog.jsx","copyoutlined.svg","components/SOPCard.jsx","components/TruthTable.jsx","components/TTCard.jsx","components/ImplicantTable.jsx","components/ITCard.jsx","App.js","reportWebVitals.js","index.js","scripts/Earley Parser/EarleyRecognizer.js"],"names":["StructFactory","names","argNames","split","count","length","i","this","arguments","Symbol","symbols","Set","Array","sym","has","size","str","entries","next","value","Terminal","NonTerminal","BOOL_GRAMMAR","BOOL_CALC_ACTIONS","lOperand","op","rOperand","eval","complexOp","product","factor","lParen","exp","rParen","v","b","nt","operand","Edge","ParseNode","rule","label","children","undefined","EarleyParser","sortEarleySets","s","invertEarleySets","grammar","filterIncomplete","inverted","padEarleySets","j","item","rules","definition","newSet","start","push","amount","buildParseTree","input","invertedS","completeItems","getEdges","startingEdge","root","data","name","aux","edge","node","decomposeEdge","child","substring","startNode","newNode","printParseTree","printRule","indent","last","line","console","log","getParseTreeString","string","endNode","graph","assert","edges","finish","bottom","depthFirstSearch","depth","symbol","match","funcGetEdges","funcIsLeaf","funcGetChild","path","unshift","applySemanticAction","tokenHandler","actions","processedChildren","bnfGrammar","Grammar","Rule","bnfActions","syntax","space1","lessThan","ruleName","greaterThan","space2","colon1","colon2","equal","space3","expression","lineEnd","spaces","space","list","orTerminal","optWhitespace","eol","lineEnd1","lineEnd2","concat","term","terminal","nonTerminal","doubleQuote1","text1","doubleQuote2","singleQuote1","text2","singleQuote2","character1","character2","letter","digit","character","singleQuote","doubleQuote","ruleChar","dash","interpretExpression","expressionTree","hasNull","Error","ruleDef","symChild","c","calculateMinTerms","parseTree","varBitSet","varCount","cardinality","minTerms","calculateExpression","BitSet","normVars","semanticActions","slice","varPos","get","Parser","token","validateTerms","dontCares","includes","getVarBitSet","expStr","variables","test","set","charCodeAt","deepCopy","src","target","isArray","key","QMTerm","REG_EXP","REG_NUMBS","QM","getPrimeImplicants","allTerms","qmTerms","getQMArray","fromatQMArray","reducedTerms","reduceQMTerms","removeDuplicateTerms","toString","qmTerm","variableCount","dashMask","intTerms","terms","forEach","sort","term1","term2","compareQMTerms","extractMinTerms","minTerm","resultant","parseInt","curCount","dashPos","forward","minTermCount","nextPos","nextDash","prevDash","flip","tmpTerms","equals","and","xor","or","used","splice","qmTerm1","qmTerm2","pos","parseString","matches","map","e","getVariableCount","highest","bits","getEssentialTerms","essentialTerms","mins","find","element","isQMTermEqual","LabelPair","PM","getPetrickSOP","primeImps","groupsMap","groupPrimeImplicants","labels","String","fromCharCode","values","sumToString","solution","expandGroups","removeLargerTerms","removeSmallerDashes","sopToString","sum","found","pair","varName","substr","groups","Map","piMinTerms","keys","from","workingSOP","toSOP","group","nextSOP","foilSums","sop1","sop2","logSOP","sop","logStr","simplifySOP","oldExpandGroups","result","smallest","largestDash","dashCount","firstSum","secondSum","k","simplified","isProductSubset","lessThanQMArray","array1","array2","isQMArrayEqual","isProductUnique","subset","superset","productToString","varLimit","firstVar","mapProductToString","conversionMap","BoolExpression","getMinTerms","getDontCares","getEssentialImplicants","getVarCount","getQMLog","getPMLog","getTruthTable","getPrimeImpStrings","piStrs","implicant","QMFuncs","getSOPStrings","sopStrs","PMFuncs","setExpression","replace","sSet","Recognizer","buildItems","parsed","validated","errorCode","setMinTerms","success","nonEssentialPrimeImps","varRow","setBits","toArray","bit","rowCount","row","isMinTerm","some","intTerm","isLogged","replaceAll","simplifiedParseTree","newBNF","startRule","interpretBNF","error","buildBoolGrammar","OperatorTable","props","Table","className","borderless","hover","responsive","headClass","bodyClass","ExampleGroup","it","end","examples","ButtonGroup","vertical","Fragment","Button","onClick","handleExample","variant","disabled","EXAMPLES_1","EXAMPLES_2","EXAMPLES_3","AboutAccordion","handleClick","Accordion","defaultActiveKey","flush","Item","eventKey","Header","Body","Row","Col","md","xs","style","textIndent","href","ExpressionForm","handleChange","event","setState","expValue","handleSubmit","preventDefault","stopPropagation","ExpressionInstance","state","isInvalid","displayExpression","errorMsg","message","Form","noValidate","onSubmit","Group","as","controlId","InputGroup","hasValidation","FormControl","required","placeholder","onChange","id","type","Control","Feedback","React","Component","QMCard","qmterms","getMinTermColor","isDontCare","Card","headerClass","title","Badge","pill","bg","isEssentialImplicant","QMLog","iterationCount","reverse","PMLog","SOPCard","sops","textField","document","createElement","innerText","body","appendChild","select","execCommand","remove","background","border","color","CopyIco","alt","width","height","OUTPUT_STYE","borderLeft","TruthTable","table","header","striped","bordered","TruthHeader","TruthRow","rowNumber","TTCard","ImplicantTable","cName","imp","ImpRow","implicantGroups","variable","impMinTerms","ITCard","App","formValue","Container","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById","EarleyItem","testG2","testG","testAactionsA","number","num1","num2","testAactionsB","EarleyRecognizer","nullableSet","getNullableRules","nextSymbol","complete","scan","predict","nextSym","appendItem","nss","items","JSON","stringify","oldSize","updateNullableSet","isNullable","add","printEarlySets","g","hideIncomplete","lines","maxDefLen","maxNameLen","defSize","l","padEnd"],"mappings":"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","file":"static/js/main.e5fb860d.chunk.js","sourcesContent":["export default function StructFactory(names) {\r\n    var argNames = names.split(\" \");\r\n    var count = names.length;\r\n    function constructor() {\r\n        for (var i = 0; i < count; i++) {\r\n            this[argNames[i]] = arguments[i];\r\n        }\r\n    }\r\n    return constructor;\r\n}\r\n","class Symbol {\r\n    constructor(symbols) {\r\n        if (symbols instanceof Set) this.symbols = symbols;\r\n        else if (symbols instanceof Array) this.symbols = new Set(symbols);\r\n        else this.symbols = new Set([symbols]);\r\n    }\r\n\r\n    match(symbols) {\r\n        if (symbols instanceof Set || symbols instanceof Array) {\r\n            for (const sym of symbols) {\r\n                if (this.symbols.has(sym) === false) return false;\r\n            }\r\n            return true;\r\n        } else return this.symbols.has(symbols);\r\n    }\r\n\r\n    toString() {\r\n        if (this.symbols.size > 1) {\r\n            let str = \"[\";\r\n            let count = 0;\r\n            for (const sym of this.symbols) {\r\n                if (count !== this.symbols.size - 1) str += sym + \",\";\r\n                else str += sym;\r\n                count++;\r\n            }\r\n            str += \"]\";\r\n            return str;\r\n        }\r\n\r\n        return \"\" + this.symbols.entries().next().value[0];\r\n    }\r\n}\r\n\r\nclass Terminal extends Symbol {}\r\n\r\nclass NonTerminal extends Symbol {}\r\n\r\nexport { Symbol, Terminal, NonTerminal };\r\n","/* eslint-disable no-eval */\r\n\r\nexport const BOOL_GRAMMAR =\r\n    '<exp>       ::= <exp> \"+\" <complexOp>;\\n' +\r\n    \"<exp>       ::= <complexOp>;\\n\" +\r\n    '<complexOp> ::= <complexOp> \"@\" <product> | <complexOp> \"%\" <product> | <complexOp> \"^\" <product>;\\n' +\r\n    \"<complexOp> ::= <product>;\\n\" +\r\n    '<product>   ::= <product> \"*\" <factor>;\\n' +\r\n    \"<product>   ::= <factor>;\\n\" +\r\n    '<factor>    ::= \"(\" <exp> \")\" | <var> | <bool> | \"~\" <factor>;\\n' +\r\n    '<bool>      ::= \"1\" | \"0\";' +\r\n    '<var>       ::= \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\" | \"G\" | \"H\" | \"I\" | \"J\" | \"K\" | \"L\" | \"M\" | \"N\" | \"O\" | \"P\" | \"Q\" | \"R\" | \"S\" | \"T\" | \"U\" | \"V\" | \"W\" | \"X\" | \"Y\" | \"Z\" | \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" | \"g\" | \"h\" | \"i\" | \"j\" | \"k\" | \"l\" | \"m\" | \"n\" | \"o\" | \"p\" | \"q\" | \"r\" | \"s\" | \"t\" | \"u\" | \"v\" | \"w\" | \"x\" | \"y\" | \"z\";';\r\n\r\nexport const BOOL_CALC_ACTIONS = [\r\n    (lOperand, op, rOperand) => eval(lOperand + \" || \" + rOperand),\r\n    (complexOp) => complexOp,\r\n    (lOperand, op, rOperand) => eval(\"!(\" + lOperand + \" && \" + rOperand + \")\"),\r\n    (lOperand, op, rOperand) => eval(\"!(\" + lOperand + \" || \" + rOperand + \")\"),\r\n    (lOperand, op, rOperand) =>\r\n        eval(\r\n            \"(!\" +\r\n                lOperand +\r\n                \" && \" +\r\n                rOperand +\r\n                \") || (\" +\r\n                lOperand +\r\n                \" && !\" +\r\n                rOperand +\r\n                \")\"\r\n        ),\r\n    (product) => product,\r\n    (lOperand, op, rOperand) => eval(lOperand + \" && \" + rOperand),\r\n    (factor) => factor,\r\n    (lParen, exp, rParen) => exp,\r\n    (v) => v,\r\n    (b) => b,\r\n    (nt, operand) => eval(\"!\" + operand),\r\n    (b) => true,\r\n    (b) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n    (v) => false,\r\n];\r\n\r\n/*<exp>       ::= <complexOp> \"+\" <exp>;\r\n<exp>       ::= <complexOp>;\r\n<complexOp> ::= <product> \"@\" <complexOp> | <product> \"%\" <complexOp> | <product> \"^\" <complexOp>;\r\n<complexOp> ::= <product>;\r\n<product>   ::= <factor> \"*\" <product>;\r\n<product>   ::= <factor>;\r\n<factor>    ::= \"(\" <exp> \")\" | <val> | \"~\" <factor>;\r\n<val>       ::= \"0\" | \"1\";\r\n<var>       ::= \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\" | \"G\" | \"H\" | \"I\" | \"J\" | \"K\" | \"L\" | \"M\" | \"N\" | \"O\" | \"P\" | \"Q\" | \"R\" | \"S\" | \"T\" | \"U\" | \"V\" | \"W\" | \"X\" | \"Y\" | \"Z\" | \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" | \"g\" | \"h\" | \"i\" | \"j\" | \"k\" | \"l\" | \"m\" | \"n\" | \"o\" | \"p\" | \"q\" | \"r\" | \"s\" | \"t\" | \"u\" | \"v\" | \"w\" | \"x\" | \"y\" | \"z\";\r\n\r\n(lOperand, op, rOperand) => eval(lOperand + \" || \" + rOperand),\r\n(complexOp) => complexOp,\r\n(lOperand, op, rOperand) => eval(\"!(\" + lOperand + \" && \" + rOperand + \")\"),\r\n(lOperand, op, rOperand) => eval(\"!(\" + lOperand + \" || \" + rOperand + \")\"),\r\n(lOperand, op, rOperand) => eval(\"(!\" + lOperand + \" && \" + rOperand + \") || (\" + lOperand + \" && !\" + rOperand + \")\"),\r\n(product) => product,\r\n(lOperand, op, rOperand) => eval(lOperand + \" && \" + rOperand),\r\n(factor) => factor,\r\n(lParen, exp, rParen) => exp,\r\n(v) => v,\r\n(nt, operand) => eval(\"!\" + operand),\r\n(v) => eval(v + \"== 1\"),\r\n(v) => eval(v + \"== 1\")\r\n\r\n<exp>       ::= <complexOp> \"+\" <exp>;\r\n<exp>       ::= <complexOp>;\r\n<complexOp> ::= <product> \"@\" <complexOp> | <product> \"%\" <complexOp> | <product> \"^\" <complexOp>;\r\n<complexOp> ::= <product>;\r\n<product>   ::= <factor> \"*\" <product>;\r\n<product>   ::= <factor>;\r\n<factor>    ::= \"(\" <exp> \")\" | <var> | \"~\" <factor>;\r\n<var>       ::= \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\" | \"G\" | \"H\" | \"I\" | \"J\" | \"K\" | \"L\" | \"M\" | \"N\" | \"O\" | \"P\" | \"Q\" | \"R\" | \"S\" | \"T\" | \"U\" | \"V\" | \"W\" | \"X\" | \"Y\" | \"Z\" | \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" | \"g\" | \"h\" | \"i\" | \"j\" | \"k\" | \"l\" | \"m\" | \"n\" | \"o\" | \"p\" | \"q\" | \"r\" | \"s\" | \"t\" | \"u\" | \"v\" | \"w\" | \"x\" | \"y\" | \"z\";\r\n\r\n\r\n(lOperand, op, rOperand) => new ParseNode(-1, \"exp\", [lOperand, op, rOperand]),\r\n(complexOp) => new ParseNode(-1, \"exp\", [complexOp]),\r\n(lOperand, op, rOperand) =>  new ParseNode(-1, \"complexOp\", [lOperand, op, rOperand]),\r\n(lOperand, op, rOperand) =>  new ParseNode(-1, \"complexOp\", [lOperand, op, rOperand]),\r\n(lOperand, op, rOperand) =>  new ParseNode(-1, \"complexOp\", [lOperand, op, rOperand]),\r\n(product) => new ParseNode(-1, \"complexOp\", [product]),\r\n(lOperand, op, rOperand) =>  new ParseNode(-1, \"product\", [lOperand, op, rOperand]),\r\n(factor) => new ParseNode(-1, \"product\", [factor]),\r\n(lParen, exp, rParen) => new ParseNode(-1, \"Factor\", [lParen, exp, rParen]),\r\n(v) => new ParseNode(-1, \"factor\", [v]),\r\n(nt, factor) => new ParseNode(-1, \"factor\", [nt, factor]),\r\n(v) => new ParseNode(-1, \"var\", [v]), (v) => new ParseNode(-1, \"var\", [v]), (v) => new ParseNode(-1, \"var\", [v]), \r\n(v) => new ParseNode(-1, \"var\", [v]), (v) => new ParseNode(-1, \"var\", [v]), (v) => new ParseNode(-1, \"var\", [v]), \r\n(v) => new ParseNode(-1, \"var\", [v]), (v) => new ParseNode(-1, \"var\", [v]), (v) => new ParseNode(-1, \"var\", [v]), \r\n(v) => new ParseNode(-1, \"var\", [v]), (v) => new ParseNode(-1, \"var\", [v]), (v) => new ParseNode(-1, \"var\", [v]), \r\n(v) => new ParseNode(-1, \"var\", [v]), (v) => new ParseNode(-1, \"var\", [v]), (v) => new ParseNode(-1, \"var\", [v]), \r\n(v) => new ParseNode(-1, \"var\", [v]), (v) => new ParseNode(-1, \"var\", [v]), (v) => new ParseNode(-1, \"var\", [v]), \r\n(v) => new ParseNode(-1, \"var\", [v]), (v) => new ParseNode(-1, \"var\", [v]), (v) => new ParseNode(-1, \"var\", [v]), \r\n(v) => new ParseNode(-1, \"var\", [v]), (v) => new ParseNode(-1, \"var\", [v]), (v) => new ParseNode(-1, \"var\", [v]), \r\n(v) => new ParseNode(-1, \"var\", [v]), (v) => new ParseNode(-1, \"var\", [v]), \r\n(v) => new ParseNode(-1, \"var\", [v]), (v) => new ParseNode(-1, \"var\", [v]), (v) => new ParseNode(-1, \"var\", [v]), \r\n(v) => new ParseNode(-1, \"var\", [v]), (v) => new ParseNode(-1, \"var\", [v]), (v) => new ParseNode(-1, \"var\", [v]), \r\n(v) => new ParseNode(-1, \"var\", [v]), (v) => new ParseNode(-1, \"var\", [v]), (v) => new ParseNode(-1, \"var\", [v]), \r\n(v) => new ParseNode(-1, \"var\", [v]), (v) => new ParseNode(-1, \"var\", [v]), (v) => new ParseNode(-1, \"var\", [v]), \r\n(v) => new ParseNode(-1, \"var\", [v]), (v) => new ParseNode(-1, \"var\", [v]), (v) => new ParseNode(-1, \"var\", [v]), \r\n(v) => new ParseNode(-1, \"var\", [v]), (v) => new ParseNode(-1, \"var\", [v]), (v) => new ParseNode(-1, \"var\", [v]), \r\n(v) => new ParseNode(-1, \"var\", [v]), (v) => new ParseNode(-1, \"var\", [v]), (v) => new ParseNode(-1, \"var\", [v]), \r\n(v) => new ParseNode(-1, \"var\", [v]), (v) => new ParseNode(-1, \"var\", [v]), (v) => new ParseNode(-1, \"var\", [v]), \r\n(v) => new ParseNode(-1, \"var\", [v]), (v) => new ParseNode(-1, \"var\", [v])\r\n\r\n(A+~C+B*D)*(~A+(~B+D)*(C+~D))\r\n\"~(A^C)@(B%D)\"\r\n\r\n(lOperand, op, rOperand) => [lOperand, op, rOperand],\r\n(complexOp) => complexOp,\r\n(lOperand, op, rOperand) =>  [lOperand, op, rOperand],\r\n(lOperand, op, rOperand) =>  [lOperand, op, rOperand],\r\n(lOperand, op, rOperand) =>  [lOperand, op, rOperand],\r\n(product) => product,\r\n(lOperand, op, rOperand) =>  [lOperand, op, rOperand],\r\n(factor) => factor,\r\n(lParen, exp, rParen) => [lParen, exp, rParen],\r\n(v) => v,\r\n(nt, factor) => [nt, factor],\r\n(v) => v, (v) => v, (v) => v, (v) => v, (v) => v, (v) => v, \r\n(v) => v, (v) => v, (v) => v, (v) => v, (v) => v, (v) => v, \r\n(v) => v, (v) => v, (v) => v, (v) => v, (v) => v, (v) => v,  \r\n(v) => v, (v) => v, (v) => v, (v) => v, (v) => v, (v) => v, \r\n(v) => v, (v) => v, (v) => v, (v) => v, (v) => v, \r\n(v) => v, (v) => v, (v) => v, (v) => v, (v) => v, (v) => v, \r\n(v) => v, (v) => v, (v) => v, (v) => v, (v) => v, (v) => v, \r\n(v) => v, (v) => v, (v) => v, (v) => v, (v) => v, (v) => v, \r\n(v) => v, (v) => v, (v) => v, (v) => v, (v) => v\r\n*/\r\n","import StructFactory from \"../StructFactory\";\r\nimport { Terminal, NonTerminal } from \"./Symbol\";\r\n\r\nconst Edge = StructFactory(\"startNode endNode data\");\r\n\r\nexport class ParseNode {\r\n    rule = -1;\r\n    label = \"\";\r\n    children = [];\r\n\r\n    constructor(rule, label, children) {\r\n        this.rule = rule;\r\n        this.label = label;\r\n\r\n        if (children === undefined || children === null) this.children = [];\r\n        else this.children = children;\r\n    }\r\n}\r\n\r\nconst EarleyParser = {\r\n    sortEarleySets(s) {},\r\n\r\n    invertEarleySets(s, grammar, filterIncomplete = true) {\r\n        let inverted = [];\r\n        this.padEarleySets(s.length, inverted);\r\n\r\n        for (let i = 0; i < s.length; i++) {\r\n            for (let j = 0; j < s[i].length; j++) {\r\n                let item = s[i][j];\r\n                let rule = grammar.rules[item.rule];\r\n\r\n                if (filterIncomplete && rule.definition.length > item.next) continue;\r\n\r\n                let newSet = item.start;\r\n                item.start = i;\r\n                inverted[newSet].push(item);\r\n            }\r\n        }\r\n\r\n        return inverted;\r\n    },\r\n\r\n    padEarleySets(amount, s) {\r\n        for (let i = 0; i < amount; i++) {\r\n            s.push([]);\r\n        }\r\n    },\r\n\r\n    buildParseTree(input, invertedS, grammar) {\r\n        let completeItems = this.getEdges(0, input.length, invertedS);\r\n        if (completeItems.length === 0) return null;\r\n\r\n        let startingEdge = new Edge(0, input.length, completeItems[0].rule);\r\n        let root = new ParseNode(\r\n            startingEdge.data,\r\n            grammar.rules[startingEdge.data].name\r\n        );\r\n\r\n        let aux = (edge, node) => {\r\n            let children = this.decomposeEdge(input, invertedS, grammar, edge);\r\n            for (const child of children) {\r\n                if (child.data === -1) {\r\n                    node.children.push(\r\n                        new ParseNode(\r\n                            -1,\r\n                            input.substring(child.startNode, child.startNode + 1)\r\n                        )\r\n                    );\r\n                } else {\r\n                    let newNode = new ParseNode(\r\n                        child.data,\r\n                        grammar.rules[child.data].name\r\n                    );\r\n                    node.children.push(newNode);\r\n                    aux(child, newNode);\r\n                }\r\n            }\r\n        };\r\n\r\n        aux(startingEdge, root);\r\n        return root;\r\n    },\r\n\r\n    printParseTree(node, printRule = false) {\r\n        let aux = (node, indent, last) => {\r\n            let line = indent + \"+- \" + node.label;\r\n            if (printRule) line += \" (\" + node.rule + \")\";\r\n            console.log(line);\r\n\r\n            indent += last ? \"   \" : \"|  \";\r\n\r\n            for (let i = 0; i < node.children.length; i++) {\r\n                aux(node.children[i], indent, i === node.children.length - 1);\r\n            }\r\n        };\r\n\r\n        aux(node, \"\", true);\r\n    },\r\n\r\n    getParseTreeString(node, printRule = false) {\r\n        let string = \"\";\r\n        let aux = (node, indent, last) => {\r\n            let line = indent + \"+- \" + node.label;\r\n            if (printRule) line += \" (\" + node.rule + \")\";\r\n            string += line + \"\\n\";\r\n\r\n            indent += last ? \"   \" : \"|  \";\r\n\r\n            for (let i = 0; i < node.children.length; i++) {\r\n                aux(node.children[i], indent, i === node.children.length - 1);\r\n            }\r\n        };\r\n\r\n        aux(node, \"\", true);\r\n        return string;\r\n    },\r\n\r\n    getEdges(startNode, endNode, graph) {\r\n        console.assert(graph.length > startNode);\r\n\r\n        let edges = [];\r\n        for (const item of graph[startNode]) {\r\n            if (item.start === endNode) edges.push(item);\r\n        }\r\n        return edges;\r\n    },\r\n\r\n    decomposeEdge(input, graph, grammar, edge) {\r\n        console.assert(edge.startNode < graph.length);\r\n        console.assert(edge.endNode < graph.length);\r\n        console.assert(edge.data >= 0 && edge.data < grammar.rules.length);\r\n\r\n        const rules = grammar.rules[edge.data].definition;\r\n\r\n        let start = edge.startNode;\r\n        let finish = edge.endNode;\r\n        let bottom = rules.length;\r\n\r\n        let isLeaf = (node, depth) => {\r\n            return node === finish && depth === bottom;\r\n        };\r\n\r\n        let getChild = (edge, depth) => {\r\n            return edge.endNode;\r\n        };\r\n\r\n        let getEdges = (node, depth) => {\r\n            if (depth >= rules.length) return [];\r\n\r\n            let edges = [];\r\n            let symbol = rules[depth];\r\n\r\n            if (symbol instanceof Terminal) {\r\n                if (symbol.match(input.substring(node, node + 1)))\r\n                    edges.push(new Edge(node, node + 1, -1));\r\n            } else if (symbol instanceof NonTerminal) {\r\n                for (const item of graph[node]) {\r\n                    if (symbol.match(grammar.rules[item.rule].name))\r\n                        edges.push(new Edge(node, item.start, item.rule));\r\n                }\r\n            }\r\n            return edges;\r\n        };\r\n\r\n        return this.depthFirstSearch(start, getEdges, isLeaf, getChild);\r\n    },\r\n\r\n    depthFirstSearch(root, funcGetEdges, funcIsLeaf, funcGetChild) {\r\n        let path = [];\r\n        let aux = (node, depth) => {\r\n            if (funcIsLeaf(node, depth)) return true;\r\n            let edges = funcGetEdges(node, depth);\r\n            for (const edge of edges) {\r\n                let child = funcGetChild(edge, depth);\r\n                if (aux(child, depth + 1)) {\r\n                    path.unshift(edge);\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n        aux(root, 0);\r\n        return path;\r\n    },\r\n\r\n    applySemanticAction(tokenHandler, root, actions) {\r\n        let aux = (node) => {\r\n            // if node is a leaf node\r\n            if (node.rule === -1) {\r\n                return tokenHandler(node.label);\r\n            } else {\r\n                let processedChildren = [];\r\n                for (const child of node.children) {\r\n                    processedChildren.push(aux(child));\r\n                }\r\n                return actions[node.rule](...processedChildren);\r\n            }\r\n        };\r\n        return aux(root);\r\n    },\r\n};\r\n\r\nexport default EarleyParser;\r\n","import { Grammar, Rule } from \"./EarleyRecognizer\";\r\nimport { Terminal, NonTerminal } from \"./Symbol\";\r\nimport { ParseNode } from \"./EarleyParser\";\r\n\r\nexport const bnfGrammar = new Grammar(\"syntax\", [\r\n    new Rule(\"syntax\", [new NonTerminal(\"rule\")]),\r\n    new Rule(\"syntax\", [new NonTerminal(\"syntax\"), new NonTerminal(\"rule\")]),\r\n\r\n    new Rule(\"rule\", [\r\n        new NonTerminal(\"opt-whitespace\"),\r\n        new Terminal(\"<\"),\r\n        new NonTerminal(\"rule-name\"),\r\n        new Terminal(\">\"),\r\n        new NonTerminal(\"opt-whitespace\"),\r\n        new Terminal(\":\"),\r\n        new Terminal(\":\"),\r\n        new Terminal(\"=\"),\r\n        new NonTerminal(\"opt-whitespace\"),\r\n        new NonTerminal(\"expression\"),\r\n        new NonTerminal(\"line-end\"),\r\n    ]),\r\n\r\n    new Rule(\"opt-whitespace\", []),\r\n    new Rule(\"opt-whitespace\", [new NonTerminal(\"opt-whitespace\"), new Terminal(\" \")]),\r\n\r\n    new Rule(\"expression\", [new NonTerminal(\"list\")]),\r\n    new Rule(\"expression\", [\r\n        new NonTerminal(\"expression\"),\r\n        new NonTerminal(\"opt-whitespace\"),\r\n        new Terminal(\"|\"),\r\n        new NonTerminal(\"opt-whitespace\"),\r\n        new NonTerminal(\"list\"),\r\n    ]),\r\n\r\n    new Rule(\"line-end\", [new NonTerminal(\"opt-whitespace\"), new NonTerminal(\"EOL\")]),\r\n    new Rule(\"line-end\", [new NonTerminal(\"line-end\"), new NonTerminal(\"line-end\")]),\r\n\r\n    new Rule(\"EOL\", [new Terminal([\";\", \"\\n\", \"\\r\"])]),\r\n\r\n    new Rule(\"list\", [new NonTerminal(\"term\")]),\r\n    new Rule(\"list\", [\r\n        new NonTerminal(\"list\"),\r\n        new NonTerminal(\"opt-whitespace\"),\r\n        new NonTerminal(\"term\"),\r\n    ]),\r\n\r\n    new Rule(\"term\", [new NonTerminal(\"terminal\")]),\r\n    new Rule(\"term\", [new NonTerminal(\"non-terminal\")]),\r\n\r\n    new Rule(\"non-terminal\", [\r\n        new Terminal(\"<\"),\r\n        new NonTerminal(\"rule-name\"),\r\n        new Terminal(\">\"),\r\n    ]),\r\n\r\n    new Rule(\"terminal\", [\r\n        new Terminal('\"'),\r\n        new NonTerminal(\"text1\"),\r\n        new Terminal('\"'),\r\n    ]),\r\n    new Rule(\"terminal\", [\r\n        new Terminal(\"'\"),\r\n        new NonTerminal(\"text2\"),\r\n        new Terminal(\"'\"),\r\n    ]),\r\n\r\n    new Rule(\"text1\", []), // NULL\r\n    new Rule(\"text1\", [new NonTerminal(\"text1\"), new NonTerminal(\"character1\")]),\r\n\r\n    new Rule(\"text2\", []), // NULL\r\n    new Rule(\"text2\", [new NonTerminal(\"text2\"), new NonTerminal(\"character2\")]),\r\n\r\n    new Rule(\"character\", [new NonTerminal(\"letter\")]),\r\n    new Rule(\"character\", [new NonTerminal(\"digit\")]),\r\n    new Rule(\"character\", [new NonTerminal(\"symbol\")]),\r\n\r\n    new Rule(\"digit\", [new Terminal([\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"])]),\r\n\r\n    new Rule(\"character1\", [new NonTerminal(\"character\")]),\r\n    new Rule(\"character1\", [new Terminal(\"'\")]),\r\n\r\n    new Rule(\"character2\", [new NonTerminal(\"character\")]),\r\n    new Rule(\"character2\", [new Terminal('\"')]),\r\n\r\n    new Rule(\"rule-name\", [new NonTerminal(\"letter\")]),\r\n    new Rule(\"rule-name\", [new NonTerminal(\"rule-name\"), new NonTerminal(\"rule-char\")]),\r\n\r\n    new Rule(\"rule-char\", [new NonTerminal(\"letter\")]),\r\n    new Rule(\"rule-char\", [new NonTerminal(\"digit\")]),\r\n    new Rule(\"rule-char\", [new Terminal(\"-\")]),\r\n\r\n    new Rule(\"letter\", [\r\n        new Terminal([\r\n            \"a\",\r\n            \"b\",\r\n            \"c\",\r\n            \"d\",\r\n            \"e\",\r\n            \"f\",\r\n            \"g\",\r\n            \"h\",\r\n            \"i\",\r\n            \"j\",\r\n            \"k\",\r\n            \"l\",\r\n            \"m\",\r\n            \"n\",\r\n            \"o\",\r\n            \"p\",\r\n            \"q\",\r\n            \"r\",\r\n            \"s\",\r\n            \"t\",\r\n            \"u\",\r\n            \"v\",\r\n            \"w\",\r\n            \"x\",\r\n            \"y\",\r\n            \"z\",\r\n            \"A\",\r\n            \"B\",\r\n            \"C\",\r\n            \"D\",\r\n            \"E\",\r\n            \"F\",\r\n            \"G\",\r\n            \"H\",\r\n            \"I\",\r\n            \"J\",\r\n            \"K\",\r\n            \"L\",\r\n            \"M\",\r\n            \"N\",\r\n            \"O\",\r\n            \"P\",\r\n            \"Q\",\r\n            \"R\",\r\n            \"S\",\r\n            \"T\",\r\n            \"U\",\r\n            \"V\",\r\n            \"W\",\r\n            \"X\",\r\n            \"Y\",\r\n            \"Z\",\r\n        ]),\r\n    ]),\r\n\r\n    new Rule(\"symbol\", [\r\n        new Terminal([\r\n            \"|\",\r\n            \" \",\r\n            \"!\",\r\n            \"#\",\r\n            \"$\",\r\n            \"%\",\r\n            \"&\",\r\n            \"(\",\r\n            \")\",\r\n            \"*\",\r\n            \"+\",\r\n            \",\",\r\n            \"-\",\r\n            \".\",\r\n            \"/\",\r\n            \":\",\r\n            \";\",\r\n            \">\",\r\n            \"=\",\r\n            \"<\",\r\n            \"?\",\r\n            \"@\",\r\n            \"[\",\r\n            \"\\\\\",\r\n            \"]\",\r\n            \"^\",\r\n            \"_\",\r\n            \"`\",\r\n            \"{\",\r\n            \"}\",\r\n            \"~\",\r\n            \"\\n\",\r\n            \"\\r\",\r\n        ]),\r\n    ]),\r\n]);\r\n\r\nexport const bnfActions = [\r\n    (rule) => new ParseNode(0, \"syntax\", [rule]),\r\n    (syntax, rule) => {\r\n        syntax.children.push(rule);\r\n        return syntax;\r\n    },\r\n\r\n    (\r\n        space1,\r\n        lessThan,\r\n        ruleName,\r\n        greaterThan,\r\n        space2,\r\n        colon1,\r\n        colon2,\r\n        equal,\r\n        space3,\r\n        expression,\r\n        lineEnd\r\n    ) => {\r\n        return new ParseNode(2, \"rule\", [ruleName, expression]);\r\n    }, //new ParseNode(2, \"rule\", args),\r\n\r\n    () => new ParseNode(3, \"opt-whitespace\"),\r\n    (spaces, space) => {\r\n        if (spaces.rule === 3) return space;\r\n        spaces.label += space.label;\r\n        return spaces;\r\n    }, //new ParseNode(4, \"opt-whitespace\", args),\r\n\r\n    (list) => new ParseNode(5, \"expression\", [list]),\r\n    (expression, space1, orTerminal, space2, list) => {\r\n        //if (expression.rule === 5) {\r\n        expression.children.push(list);\r\n        return expression;\r\n        //}\r\n        //return new ParseNode(6, \"expression\", [expression, list]);\r\n    }, //new ParseNode(6, \"expression\", args),\r\n\r\n    (optWhitespace, eol) => new ParseNode(7, \"line-end\", [eol]),\r\n    (lineEnd1, lineEnd2) =>\r\n        new ParseNode(8, \"line-end\", lineEnd1.children.concat(lineEnd2.children)),\r\n\r\n    (eol) => eol,\r\n\r\n    (term) => new ParseNode(11, \"list\", [term]),\r\n    (list, optWhitespace, term) => {\r\n        list.children.push(term);\r\n        list.rule = 12;\r\n        return list;\r\n    },\r\n\r\n    (terminal) => terminal, //new ParseNode(12, \"term\", args),\r\n    (nonTerminal) => nonTerminal, //new ParseNode(13, \"term\", args),\r\n\r\n    (lessThan, ruleName, greaterThan) => new ParseNode(14, \"non-terminal\", [ruleName]),\r\n\r\n    (doubleQuote1, text1, doubleQuote2) => new ParseNode(15, \"terminal\", [text1]),\r\n    (singleQuote1, text2, singleQuote2) => new ParseNode(16, \"terminal\", [text2]),\r\n\r\n    () => new ParseNode(17, \"null\"),\r\n    (text1, character1) => {\r\n        if (text1.rule === 17) return character1;\r\n        text1.label += character1.label;\r\n        return text1;\r\n    }, //new ParseNode(18, \"text1\", args),\r\n\r\n    () => new ParseNode(19, \"null\"),\r\n    (text2, character2) => {\r\n        if (text2.rule === 19) return character2;\r\n        text2.label += character2.label;\r\n        return text2;\r\n    }, //new ParseNode(20, \"text2\", args),\r\n\r\n    (letter) => letter, //new ParseNode(22, \"character\", args),\r\n    (digit) => digit, //new ParseNode(22, \"character\", args),\r\n    (symbol) => symbol, //new ParseNode(23, \"character\", args),\r\n\r\n    (digit) => digit, //new ParseNode(24, \"digit\", args),\r\n\r\n    (character) => character, //new ParseNode(25, \"character1\", args),\r\n    (singleQuote) => singleQuote, //new ParseNode(26, \"character1\", args),\r\n\r\n    (character) => character, //new ParseNode(27, \"character2\", args),\r\n    (doubleQuote) => doubleQuote, // new ParseNode(28, \"character2\", args),\r\n\r\n    (letter) => letter, //new ParseNode(29, \"rule-name\", args),\r\n    (ruleName, ruleChar) => {\r\n        ruleName.label += ruleChar.label;\r\n        return ruleName;\r\n    }, //new ParseNode(30, \"rule-name\", args),\r\n\r\n    (letter) => letter, //new ParseNode(31, \"rule-char\", args),\r\n    (digit) => digit, //new ParseNode(32, \"rule-char\", args),\r\n    (dash) => dash, //new ParseNode(33, \"rule-char\", args),\r\n\r\n    (letter) => letter, //new ParseNode(34, \"letter\", args),\r\n    (symbol) => symbol, //new ParseNode(35, \"symbol\", args),\r\n];\r\n\r\nexport function interpretBNF(simplifiedParseTree) {\r\n    if (simplifiedParseTree === null || simplifiedParseTree === undefined)\r\n        throw new Error(\"invalid parse tree\");\r\n    if (simplifiedParseTree.label !== \"syntax\") throw new Error(\"invalid parse tree\");\r\n\r\n    let newBNF = new Grammar(undefined, []);\r\n    for (const rule of simplifiedParseTree.children) {\r\n        if (rule.label !== \"rule\") throw new Error(\"invalid syntax\");\r\n        if (rule.children.length !== 2) throw new Error(\"invalid rule\");\r\n        if (rule.children[0].rule !== -1) throw new Error(\"invalid rule\");\r\n        if (rule.children[1].label !== \"expression\") throw new Error(\"invalid rule\");\r\n\r\n        let ruleName = rule.children[0].label;\r\n        if (newBNF.startRule === undefined) newBNF.startRule = ruleName;\r\n\r\n        let rules = interpretExpression(ruleName, rule.children[1]);\r\n        newBNF.rules = newBNF.rules.concat(rules);\r\n    }\r\n    return newBNF;\r\n}\r\n\r\n// returns array of Rules\r\nfunction interpretExpression(ruleName, expressionTree) {\r\n    const NULL1 = 17;\r\n    const NULL2 = 19;\r\n\r\n    let rules = [];\r\n    let hasNull = false;\r\n    for (const list of expressionTree.children) {\r\n        if (list.label !== \"list\") throw new Error(\"invalid expression\");\r\n\r\n        let ruleDef = [];\r\n\r\n        for (const symbol of list.children) {\r\n            if (symbol.children.length !== 1) throw new Error(\"invalid list\");\r\n            let symChild = symbol.children[0];\r\n\r\n            if (symbol.label === \"non-terminal\") {\r\n                if (symChild.rule !== -1) throw new Error(\"invalid non-terminal\");\r\n                ruleDef.push(new NonTerminal(symChild.label));\r\n            } else if (symbol.label === \"terminal\") {\r\n                if (symChild.rule === NULL1 || symChild.rule === NULL2) {\r\n                    if (list.children.length > 1) {\r\n                        if (hasNull === false) {\r\n                            rules.push(new Rule(ruleName + \"-null\", []));\r\n                            hasNull = true;\r\n                        }\r\n                        ruleDef.push(NonTerminal(ruleName + \"-null\"));\r\n                    }\r\n                } else if (symChild.rule === -1) {\r\n                    for (const c of symChild.label) {\r\n                        ruleDef.push(new Terminal(c));\r\n                    }\r\n                } else throw new Error(\"invalid terminal\");\r\n            } else throw new Error(\"invalid list\");\r\n        }\r\n\r\n        rules.push(new Rule(ruleName, ruleDef));\r\n    }\r\n    return rules;\r\n}\r\n","import { BOOL_GRAMMAR, BOOL_CALC_ACTIONS } from \"./BoolExpressionGrammar\";\r\nimport Recognizer from \"../Earley Parser/EarleyRecognizer\";\r\nimport Parser, { ParseNode } from \"../Earley Parser/EarleyParser\";\r\nimport BitSet from \"bitset\";\r\nimport { bnfGrammar, bnfActions, interpretBNF } from \"../Earley Parser/BNFInterpreter\";\r\n//import BoolExpression from \"./BoolExpression\";\r\n\r\n/*export default function boolMain(expStr) {\r\n    try {\r\n        let exp = BoolExpression.ExpressionInstance(expStr, true);\r\n\r\n        console.log(\"Expression: \", exp.toString());\r\n        console.log(\"Min Terms: \", exp.getMinTerms());\r\n        console.log(\"Var Count: \", exp.getVarCount());\r\n        console.log(\"Prime Implicants: \", exp.getPrimeImplicants());\r\n        console.log(\"Petrick SOP: \", exp.getPetrickSOP());\r\n        // Print Prime Implicants\r\n        for (const implicant of exp.getPrimeImpStrings()) {\r\n            console.log(implicant);\r\n        }\r\n\r\n        let petrickSOP = exp.getSOPStrings();\r\n        for (let i = 0; i < petrickSOP.length; i++) {\r\n            console.log(\"Solution \", i + 1, \": \", petrickSOP[i]);\r\n        }\r\n\r\n        let test = exp.getQMLog();\r\n        console.log(\"QM Log: \", test);\r\n        console.log(\"PM Log: \", exp.getPMLog());\r\n    } catch (error) {\r\n        console.log(error);\r\n    }\r\n}*/\r\n\r\nexport function buildBoolGrammar() {\r\n    try {\r\n        let grammar = BOOL_GRAMMAR.replaceAll(\"\\\\n\", \"\\n\");\r\n        let s = Recognizer.buildItems(grammar, bnfGrammar);\r\n        let invertedS = Parser.invertEarleySets(s, bnfGrammar);\r\n        let parseTree = Parser.buildParseTree(grammar, invertedS, bnfGrammar);\r\n\r\n        if (parseTree === null) {\r\n            throw new Error(\"invalid grammar\");\r\n        }\r\n\r\n        let simplifiedTree = Parser.applySemanticAction(\r\n            (token) => new ParseNode(-1, token),\r\n            parseTree,\r\n            bnfActions\r\n        );\r\n\r\n        return interpretBNF(simplifiedTree);\r\n    } catch (error) {\r\n        console.log(error);\r\n        return null;\r\n    }\r\n}\r\n\r\nexport function calculateMinTerms(parseTree, varBitSet) {\r\n    let varCount = varBitSet.cardinality();\r\n    let minTerms = []; // array to be filled with minTerms\r\n    let rowCount = 2 ** varCount;\r\n\r\n    for (let i = rowCount - 1; i >= 0; i--) {\r\n        let normalizedVariables = BitSet(i);\r\n        let boolVal = calculateExpression(parseTree, varBitSet, normalizedVariables);\r\n        if (boolVal) minTerms.push(i);\r\n    }\r\n    return minTerms;\r\n}\r\n\r\nfunction calculateExpression(parseTree, varBitSet, normVars) {\r\n    let semanticActions = BOOL_CALC_ACTIONS.slice();\r\n    let varCount = varBitSet.cardinality();\r\n\r\n    let varPos = 0;\r\n    for (let i = 0; i < 26; i++) {\r\n        if (varBitSet.get(i) === 0) continue;\r\n        let bool = normVars.get(varCount - 1 - varPos++);\r\n        if (bool) {\r\n            semanticActions[i + semanticActions.length - 52] = () => true;\r\n            semanticActions[i + semanticActions.length - 26] = () => true;\r\n        } else {\r\n            semanticActions[i + semanticActions.length - 52] = () => false;\r\n            semanticActions[i + semanticActions.length - 26] = () => false;\r\n        }\r\n    }\r\n\r\n    return Parser.applySemanticAction((token) => token, parseTree, semanticActions);\r\n}\r\n\r\nexport function validateTerms(minTerms, dontCares) {\r\n    if (minTerms.length === 0) return [false, -1];\r\n    for (const term of dontCares) if (minTerms.includes(term)) return [false, term];\r\n    return [true, -2];\r\n}\r\n\r\nexport function getVarBitSet(expStr) {\r\n    let variables = new BitSet();\r\n    for (let i = 0; i < expStr.length; i++) {\r\n        if (/[A-Z]/.test(expStr[i])) {\r\n            variables.set(expStr.charCodeAt(i) - 65, 1);\r\n        }\r\n    }\r\n    return variables;\r\n}\r\n\r\nexport function mapVariable(variable, varBitSet) {\r\n    let setBits = varBitSet.toArray();\r\n\r\n    // variable is an index\r\n    if (variable === parseInt(variable))\r\n        return String.fromCharCode(setBits[variable] + 65);\r\n\r\n    //variable is a character\r\n    return String.fromCharCode(setBits[variable.charCodeAt(0) - 65] + 65);\r\n}\r\n\r\nexport function deepCopy(src) {\r\n    let target = Array.isArray(src) ? [] : {};\r\n    for (let key in src) {\r\n        let v = src[key];\r\n        if (v) {\r\n            if (typeof v === \"object\") {\r\n                target[key] = deepCopy(v);\r\n            } else {\r\n                target[key] = v;\r\n            }\r\n        } else {\r\n            target[key] = v;\r\n        }\r\n    }\r\n\r\n    return target;\r\n}\r\n","import StructFactory from \"../StructFactory\";\r\nimport BitSet from \"bitset\";\r\nconst QMTerm = StructFactory(\"term dashMask used\");\r\nconst REG_EXP = /^( *m *\\( *\\d+(?:, *\\d+)* *\\))( *\\+ *d *\\( *\\d+(?:, *\\d+)* *\\))?$/;\r\nconst REG_NUMBS = /([\\d,\\s]+)/;\r\n\r\nconst QM = {\r\n    getPrimeImplicants(minTerms, dontCares, log) {\r\n        let allTerms = dontCares ? minTerms.concat(dontCares) : minTerms;\r\n        let qmTerms = this.getQMArray(allTerms);\r\n        qmTerms = this.fromatQMArray(qmTerms);\r\n\r\n        let reducedTerms = [];\r\n        this.reduceQMTerms(qmTerms, reducedTerms, log);\r\n        this.removeDuplicateTerms(reducedTerms);\r\n        return reducedTerms;\r\n    },\r\n\r\n    toString(qmTerm, variableCount) {\r\n        let varLimit = variableCount === 0 ? 25 : variableCount - 1;\r\n\r\n        let str = \"\";\r\n        for (let i = varLimit; i >= 0; i--) {\r\n            if ((i + 1) % 4 === 0) str += \" \";\r\n            if (qmTerm.dashMask.get(i) === 1) str += \"-\";\r\n            else str += qmTerm.term.get(i);\r\n        }\r\n        return str;\r\n    },\r\n\r\n    getQMArray(intTerms) {\r\n        let terms = [];\r\n        intTerms.forEach((term) => {\r\n            terms.push(new QMTerm(new BitSet(term), new BitSet(0), false));\r\n        });\r\n        return terms;\r\n    },\r\n\r\n    fromatQMArray(qmTerms) {\r\n        // compareQMTerms works like a standard comparison function\r\n        // and must be multiplied by -1 to sort in decending order\r\n        return qmTerms.sort((term1, term2) => {\r\n            return QM.compareQMTerms(term1, term2) * -1;\r\n        });\r\n    },\r\n\r\n    // This function iterates the dashMask bitset\r\n    // forward once and backward once. Each time it\r\n    // comes accross a set bit it flips that bit in\r\n    // in the minTerm bitset and stores the new\r\n    // minTerm value. Aka O(2n) where n is the number\r\n    // of variable in an expression. There is one other\r\n    // algorithm I came up with that that is\r\n    // O(2^(d+2) - 1) where d is the number of set\r\n    // bits in the qmTerm's dashMask. Which algorithm\r\n    // is better is heavily dependent on the number of\r\n    // variables in an expression how reducable said\r\n    // expression is. I decided to stick with the O(n)\r\n    // case for the sake of being linear.\r\n    extractMinTerms(qmTerm) {\r\n        let minTerm = qmTerm.term;\r\n        let resultant = [parseInt(minTerm.toString(10))];\r\n\r\n        let curCount = 1;\r\n        let dashPos = -1;\r\n        let forward = true;\r\n        let minTermCount = 2 ** qmTerm.dashMask.cardinality();\r\n\r\n        while (curCount < minTermCount) {\r\n            let nextPos = -1;\r\n\r\n            if (forward) nextPos = this.nextDash(qmTerm.dashMask, dashPos);\r\n            else nextPos = this.prevDash(qmTerm.dashMask, dashPos);\r\n\r\n            if (nextPos === -1) {\r\n                forward = !forward;\r\n                continue;\r\n            }\r\n\r\n            dashPos = nextPos;\r\n            minTerm.flip(dashPos);\r\n            resultant.push(parseInt(minTerm.toString(10)));\r\n            curCount++;\r\n        }\r\n\r\n        return resultant;\r\n    },\r\n\r\n    reduceQMTerms(qmTerms, resultant, log) {\r\n        let tmpTerms = qmTerms.slice();\r\n        let reducedTerms = [];\r\n\r\n        if (log) log.push(qmTerms);\r\n\r\n        for (let i = 0; i < tmpTerms.length; ) {\r\n            for (let j = i + 1; j < tmpTerms.length; j++) {\r\n                if (tmpTerms[i].dashMask.equals(tmpTerms[j].dashMask)) {\r\n                    // Core of QM Method\r\n                    let resultant = new QMTerm(\r\n                        tmpTerms[i].term.and(tmpTerms[j].term),\r\n                        tmpTerms[i].term.xor(tmpTerms[j].term),\r\n                        false\r\n                    );\r\n\r\n                    // Real resultant will always have 1 more dash mark than the original terms\r\n                    if (resultant.dashMask.cardinality() !== 1) continue;\r\n\r\n                    resultant.dashMask = resultant.dashMask.or(tmpTerms[i].dashMask);\r\n\r\n                    reducedTerms.push(resultant);\r\n\r\n                    tmpTerms[i].used = true;\r\n                    tmpTerms[j].used = true;\r\n                }\r\n            }\r\n\r\n            // Remove Used Terms\r\n            if (tmpTerms[i].used) tmpTerms.splice(i, 1);\r\n            else i++;\r\n        }\r\n\r\n        // Remove any remaining used terms\r\n        for (let i = 0; i < tmpTerms.length; ) {\r\n            if (tmpTerms[i].used) tmpTerms.splice(i, 1);\r\n            else i++;\r\n        }\r\n\r\n        // Save unused Terms\r\n        resultant.push(...tmpTerms);\r\n\r\n        // If we're not done reducing\r\n        if (reducedTerms.length !== 0) {\r\n            this.removeDuplicateTerms(reducedTerms);\r\n            this.reduceQMTerms(reducedTerms, resultant, log);\r\n        }\r\n    },\r\n\r\n    removeDuplicateTerms(qmTerms) {\r\n        for (let i = 0; i < qmTerms.length; i++) {\r\n            for (let j = i + 1; j < qmTerms.length; ) {\r\n                if (\r\n                    qmTerms[i].term.equals(qmTerms[j].term) &&\r\n                    qmTerms[i].dashMask.equals(qmTerms[j].dashMask)\r\n                )\r\n                    qmTerms.splice(j, 1);\r\n                else j++;\r\n            }\r\n        }\r\n    },\r\n\r\n    compareQMTerms(qmTerm1, qmTerm2) {\r\n        let term1 = parseInt(qmTerm1.term.toString(10));\r\n        let term2 = parseInt(qmTerm2.term.toString(10));\r\n        return term1 < term2 ? -1 : term1 > term2 ? 1 : 0;\r\n    },\r\n\r\n    prevDash(dashMask, pos) {\r\n        for (let i = pos === -1 ? dashMask.cardinality() - 1 : pos - 1; i >= 0; i--) {\r\n            if (dashMask.get(i) === 1) return i;\r\n        }\r\n        return -1;\r\n    },\r\n\r\n    nextDash(dashMask, pos) {\r\n        for (let i = pos === -1 ? 0 : pos + 1; i < dashMask.toString().length; i++) {\r\n            if (dashMask.get(i) === 1) return i;\r\n        }\r\n        return -1;\r\n    },\r\n\r\n    parseString(expression) {\r\n        if (!REG_EXP.test(expression)) return [false, [], []];\r\n\r\n        let matches = expression.match(REG_EXP);\r\n        let mNumbers = matches[1].match(REG_NUMBS);\r\n        let minTerms = mNumbers[1].split(\",\").map((e) => parseInt(e));\r\n\r\n        if (matches[2] === undefined) return [true, minTerms, []];\r\n\r\n        let dNumbers = matches[2].match(REG_NUMBS);\r\n        let dontCares = dNumbers[1].split(\",\").map((e) => parseInt(e));\r\n        return [true, minTerms, dontCares];\r\n    },\r\n\r\n    getVariableCount(minTerms, dontCares) {\r\n        let highest = 0;\r\n\r\n        minTerms.forEach((term) => {\r\n            if (term > highest) highest = term;\r\n            else if (!highest && !term) highest = 1;\r\n        });\r\n\r\n        dontCares.forEach((term) => {\r\n            if (term > highest) highest = term;\r\n        });\r\n\r\n        let bits = 0;\r\n        while (highest) {\r\n            highest >>>= 1;\r\n            bits++;\r\n        }\r\n\r\n        return bits;\r\n    },\r\n\r\n    getEssentialTerms(qmTerms, minTerms) {\r\n        let essentialTerms = [];\r\n\r\n        for (let i = 0; i < qmTerms.length; i++) {\r\n            let mins = this.extractMinTerms(qmTerms[i]);\r\n            for (let j = 0; j < mins.length; j++) {\r\n                if (minTerms.find((element) => element === mins[j])) {\r\n                    essentialTerms.push(qmTerms[i]);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return essentialTerms;\r\n    },\r\n\r\n    isQMTermEqual(qmTerm1, qmTerm2) {\r\n        return (\r\n            qmTerm1.term.equals(qmTerm2.term) && qmTerm1.dashMask.equals(qmTerm2.dashMask)\r\n        );\r\n    },\r\n};\r\n\r\nexport default QM;\r\n","import StructFactory from \"../StructFactory\";\r\nimport QM from \"./QMFunctions\";\r\n\r\nconst LabelPair = StructFactory(\"qmTerm varName\");\r\n\r\nconst PM = {\r\n    getPetrickSOP(primeImps, minTerms, log) {\r\n        let groupsMap = this.groupPrimeImplicants(primeImps, minTerms);\r\n\r\n        let labels = [];\r\n        if (log && primeImps.length) {\r\n            let count = 0;\r\n            for (const term of primeImps) {\r\n                labels.push(\r\n                    new LabelPair(\r\n                        term,\r\n                        String.fromCharCode(\r\n                            ((\"K\".charCodeAt(0) - 65 + count++) % 26) + 65\r\n                        )\r\n                    )\r\n                );\r\n            }\r\n\r\n            let str = \"\";\r\n            for (const value of groupsMap.values())\r\n                str += this.sumToString(value, labels);\r\n            log.push(str);\r\n        }\r\n\r\n        let solution = this.expandGroups(groupsMap, log, labels);\r\n        this.removeLargerTerms(solution);\r\n        this.removeSmallerDashes(solution);\r\n\r\n        if (log && primeImps.length) {\r\n            let str = \"(\" + this.sopToString(solution, labels) + \")\";\r\n            if (log[log.length - 1] !== str) log.push(str);\r\n        }\r\n\r\n        return solution;\r\n    },\r\n\r\n    sumToString(sum, labels) {\r\n        if (sum.length === 0) return \"\";\r\n\r\n        let str = \"(\";\r\n        for (const term of sum) {\r\n            let found = labels.find(\r\n                (pair) =>\r\n                    pair.qmTerm.term.equals(term.term) &&\r\n                    pair.qmTerm.dashMask.equals(term.dashMask)\r\n            );\r\n            if (found !== undefined) {\r\n                str += found.varName + \" + \";\r\n            }\r\n        }\r\n        str = str.substr(0, str.length - 3) + \")\";\r\n        return str;\r\n    },\r\n\r\n    groupPrimeImplicants(primeImps, minTerms) {\r\n        let groups = new Map();\r\n\r\n        // Initialize Groups\r\n        for (let i = 0; i < minTerms.length; i++) groups.set(minTerms[i], []);\r\n\r\n        // Group Prime Imps (QMTerms)\r\n        for (let i = 0; i < primeImps.length; i++) {\r\n            // Calculate min terms using dash positions\r\n            let piMinTerms = QM.extractMinTerms(primeImps[i]);\r\n\r\n            for (let j = 0; j < piMinTerms.length; j++) {\r\n                // If extracted min term is not a don't care, insert it into the map\r\n                if (groups.has(piMinTerms[j]))\r\n                    groups.get(piMinTerms[j]).push(primeImps[i]);\r\n            }\r\n        }\r\n\r\n        return groups;\r\n    },\r\n\r\n    // returns SOP\r\n    expandGroups(groups, log, labels) {\r\n        if (!groups.size) return [];\r\n\r\n        let keys = Array.from(groups.keys());\r\n        if (keys.length === 0) return [];\r\n\r\n        let workingSOP = this.toSOP(groups.get(keys[0]));\r\n        for (let i = 1; i < keys.length; i++) {\r\n            let group = groups.get(keys[i]);\r\n            if (group.length) {\r\n                let nextSOP = this.toSOP(group);\r\n                workingSOP = this.foilSums(workingSOP, nextSOP);\r\n\r\n                workingSOP.sort((sop1, sop2) =>\r\n                    sop1.length < sop2.length ? -1 : sop1.length > sop2.length ? 1 : 0\r\n                );\r\n\r\n                let logSOP = (sop) => {\r\n                    let logStr = \"(\" + this.sopToString(sop, labels) + \")\";\r\n                    for (let j = i + 1; j < keys.length; j++)\r\n                        logStr += this.sumToString(groups.get(keys[j]), labels);\r\n                    log.push(logStr);\r\n                };\r\n\r\n                if (log) logSOP(workingSOP);\r\n                workingSOP = this.simplifySOP(workingSOP);\r\n                if (log) logSOP(workingSOP);\r\n            }\r\n        }\r\n\r\n        return workingSOP;\r\n    },\r\n\r\n    // returns SOP\r\n    oldExpandGroups(groups, log, labels) {\r\n        if (!groups.size) return [];\r\n\r\n        let workingSOP;\r\n        for (let value of groups.values()) {\r\n            if (workingSOP === undefined) {\r\n                workingSOP = this.toSOP(value);\r\n                continue;\r\n            }\r\n\r\n            if (value.length) {\r\n                let nextSOP = this.toSOP(value);\r\n                workingSOP = this.foilSums(workingSOP, nextSOP);\r\n\r\n                workingSOP.sort((sop1, sop2) => (sop1.length > sop2.length && 1) || -1);\r\n                workingSOP = this.simplifySOP(workingSOP);\r\n            }\r\n        }\r\n\r\n        return workingSOP;\r\n    },\r\n\r\n    toSOP(sum) {\r\n        let result = [];\r\n\r\n        for (let i = 0; i < sum.length; i++) {\r\n            result.push([sum[i]]);\r\n        }\r\n\r\n        return result;\r\n    },\r\n\r\n    removeLargerTerms(expression) {\r\n        if (expression.length === 0) return;\r\n\r\n        // Find smallest term size and remove those larger\r\n        let smallest = expression[0].length;\r\n\r\n        for (let i = 1; i < expression.length; ) {\r\n            if (expression[i].length > smallest) expression.splice(i, 1);\r\n            else {\r\n                if (expression[i].length < smallest) smallest = expression[i].length;\r\n                i++;\r\n            }\r\n        }\r\n\r\n        // Iterate one more time to remove remaining large terms\r\n        for (let i = 0; i < expression.length; ) {\r\n            if (expression[i].length > smallest) expression.splice(i, 1);\r\n            else i++;\r\n        }\r\n    },\r\n\r\n    removeSmallerDashes(expression) {\r\n        if (expression.length === 0) return;\r\n\r\n        // Find largest dash count and remove those smaller\r\n        let largestDash = 0;\r\n        for (let i = 0; i < expression.length; ) {\r\n            let dashCount = 0;\r\n            for (let j = 0; j < expression[i].length; j++)\r\n                dashCount += expression[i][j].dashMask.cardinality();\r\n\r\n            if (dashCount < largestDash) expression.splice(i, 1);\r\n            else {\r\n                largestDash = dashCount;\r\n                i++;\r\n            }\r\n        }\r\n\r\n        // Iterate one more time to remove remaning small (larger) terms\r\n        for (let i = 0; i < expression.length; ) {\r\n            let dashCount = 0;\r\n            for (let j = 0; j < expression[i].length; j++)\r\n                dashCount += expression[i][j].dashMask.cardinality();\r\n\r\n            if (dashCount < largestDash) expression.splice(i, 1);\r\n            else i++;\r\n        }\r\n    },\r\n\r\n    foilSums(firstSum, secondSum) {\r\n        let result = [];\r\n        for (let i = 0; i < firstSum.length; i++) {\r\n            for (let j = 0; j < secondSum.length; j++) {\r\n                for (let k = 0; k < secondSum[j].length; k++) {\r\n                    let product = firstSum[i].slice();\r\n                    let findVar = product.find((element) => element === secondSum[j][k]);\r\n                    if (findVar === undefined) product.push(secondSum[j][k]);\r\n                    result.push(product);\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    },\r\n\r\n    // Precondition: SOP is sorted by var count per term\r\n    simplifySOP(sop) {\r\n        let simplified = sop.slice();\r\n        for (let i = 0; i < simplified.length; i++) {\r\n            for (let j = i + 1; j < simplified.length; ) {\r\n                if (this.isProductSubset(simplified[i], simplified[j]))\r\n                    simplified.splice(j, 1);\r\n                else j++;\r\n            }\r\n        }\r\n        return simplified;\r\n    },\r\n\r\n    lessThanQMArray(array1, array2) {},\r\n    isQMArrayEqual(array1, array2) {},\r\n    isProductUnique(sop, product) {},\r\n    isProductSubset(subset, superset) {\r\n        if (subset.length > superset.length) return false;\r\n\r\n        for (let i = 0; i < subset.length; i++) {\r\n            if (\r\n                superset.find((element) => {\r\n                    return (\r\n                        element.term.equals(subset[i].term) &&\r\n                        element.dashMask.equals(subset[i].dashMask)\r\n                    );\r\n                }) === undefined\r\n            )\r\n                return false;\r\n        }\r\n\r\n        return true;\r\n    },\r\n\r\n    productToString(product, varCount) {\r\n        let varLimit = varCount === 0 ? 25 : varCount - 1;\r\n\r\n        // Edge case for contradictions\r\n        if (product.length === 0) return \"0\";\r\n\r\n        // Edge case for tautologies\r\n        if (\r\n            product.length === 1 &&\r\n            product[0].term.cardinality() === 0 &&\r\n            product[0].dashMask.cardinality() === varCount + 1\r\n        )\r\n            return \"1\";\r\n\r\n        let string = \"\";\r\n        for (let i = product.length - 1; i >= 0; i--) {\r\n            let firstVar = true;\r\n            for (let j = varLimit; j >= 0; j--) {\r\n                if (product[i].dashMask.get(j) === 0) {\r\n                    if (!firstVar) string += \"*\";\r\n                    else firstVar = false;\r\n\r\n                    if (product[i].term.get(j) === 0) string += \"~\";\r\n                    string += String.fromCharCode(65 + (varLimit - j));\r\n                }\r\n            }\r\n\r\n            if (i - 1 >= 0) string += \" + \";\r\n        }\r\n        return string;\r\n    },\r\n\r\n    mapProductToString(product, varBitSet) {\r\n        // Edge case for contradictions\r\n        if (product.length === 0) return \"0\";\r\n\r\n        // Edge case for tautologies\r\n        if (\r\n            product.length === 1 &&\r\n            product[0].term.cardinality() === 0 &&\r\n            product[0].dashMask.cardinality() === varBitSet.cardinality()\r\n        )\r\n            return \"1\";\r\n\r\n        let varLimit = varBitSet.cardinality() - 1;\r\n        let varPos = 0;\r\n        let conversionMap = new Map();\r\n        for (let i = 0; i < 26; i++) {\r\n            if (varBitSet.get(i) === 0) continue;\r\n            conversionMap.set(varLimit - varPos++, String.fromCharCode(i + 65));\r\n        }\r\n\r\n        let string = \"\";\r\n        for (let i = 0; i < product.length; i++) {\r\n            let firstVar = true;\r\n            for (let j = varLimit; j >= 0; j--) {\r\n                if (product[i].dashMask.get(j) === 0) {\r\n                    if (!firstVar) string += \"*\";\r\n                    else firstVar = false;\r\n\r\n                    if (product[i].term.get(j) === 0) string += \"~\";\r\n                    string += conversionMap.get(j);\r\n                }\r\n            }\r\n\r\n            if (i < product.length - 1) string += \" + \";\r\n        }\r\n        return string;\r\n    },\r\n\r\n    sopToString(sop, labels) {\r\n        let str = \"\";\r\n        for (const term of sop) {\r\n            for (const product of term) {\r\n                let found = labels.find(\r\n                    (pair) =>\r\n                        pair.qmTerm.term.equals(product.term) &&\r\n                        pair.qmTerm.dashMask.equals(product.dashMask)\r\n                );\r\n                if (found !== undefined) str += found.varName;\r\n            }\r\n            str += \" + \";\r\n        }\r\n        str = str.substr(0, str.length - 3);\r\n\r\n        return str;\r\n    },\r\n};\r\n\r\nexport default PM;\r\n","import {\r\n    buildBoolGrammar,\r\n    deepCopy,\r\n    validateTerms,\r\n    getVarBitSet,\r\n    calculateMinTerms,\r\n} from \"./BoolExpressionUtils\";\r\nimport QMFuncs from \"./QMFunctions\";\r\nimport PMFuncs from \"./PMFunctions\";\r\nimport Recognizer from \"../Earley Parser/EarleyRecognizer\";\r\nimport Parser from \"../Earley Parser/EarleyParser\";\r\nimport BitSet from \"bitset\";\r\n\r\nexport default class BoolExpression {\r\n    #varCount;\r\n    #minTerms;\r\n    #dontCares;\r\n    #primeImps;\r\n    #petrickSOP;\r\n\r\n    #sSet;\r\n    #invertedS;\r\n    #parseTree;\r\n    #varBitSet;\r\n    #expression;\r\n\r\n    #errorCode = -2;\r\n    #isLogged = false;\r\n\r\n    #qmLog;\r\n    #pmLog;\r\n\r\n    #truthTable;\r\n\r\n    static #BOOL_GRAMMAR = buildBoolGrammar();\r\n\r\n    constructor(expression, minTerms, dontCares, isLogged = false) {\r\n        if (!expression && !minTerms && !dontCares) {\r\n            throw new Error(\"null expression\");\r\n        }\r\n\r\n        this.#minTerms = minTerms;\r\n        this.#dontCares = dontCares;\r\n        this.#expression = expression;\r\n        this.#isLogged = true;\r\n\r\n        let success;\r\n        if (expression) success = this.setExpression(expression);\r\n        else success = this.setMinTerms(minTerms, dontCares);\r\n\r\n        if (!success) {\r\n            if (this.#errorCode === -1) throw new Error(\"cannot have 0 minimum terms\");\r\n            else if (this.#errorCode >= 0)\r\n                throw new Error(\r\n                    parseInt(this.#errorCode) +\r\n                        \" cannot be both a min term and a don't care\"\r\n                );\r\n            else throw new Error(\"expression is not valid\");\r\n        }\r\n    }\r\n\r\n    static ExpressionInstance(expression, isLogged = false) {\r\n        return new BoolExpression(expression, null, null, isLogged);\r\n    }\r\n\r\n    static MinTermInstance(minTerms, dontCares, isLogged = false) {\r\n        return new BoolExpression(null, minTerms, dontCares, isLogged);\r\n    }\r\n\r\n    getMinTerms = () => deepCopy(this.#minTerms);\r\n    getDontCares = () => deepCopy(this.#dontCares);\r\n    getPetrickSOP = () => deepCopy(this.#petrickSOP);\r\n    getEssentialImplicants = () => deepCopy(this.#primeImps);\r\n    getVarCount = () => this.#varCount;\r\n\r\n    getQMLog = () => (this.#isLogged ? deepCopy(this.#qmLog) : []);\r\n    getPMLog = () => (this.#isLogged ? deepCopy(this.#pmLog) : []);\r\n\r\n    getTruthTable = () => deepCopy(this.#truthTable);\r\n\r\n    getPrimeImpStrings = () => {\r\n        let piStrs = [];\r\n        for (const implicant of this.#primeImps) {\r\n            let str = \"[\";\r\n            let minTerms = QMFuncs.extractMinTerms(implicant);\r\n            for (const term of minTerms) str += parseInt(term) + \"-\";\r\n            str = str.substring(0, str.length - 1) + \"] \";\r\n            str += QMFuncs.toString(implicant, this.#varCount);\r\n            piStrs.push(str);\r\n        }\r\n        return piStrs;\r\n    };\r\n\r\n    getSOPStrings = () => {\r\n        let sopStrs = [];\r\n        if (this.#petrickSOP.length === 0) {\r\n            if (this.#varBitSet)\r\n                sopStrs.push(PMFuncs.mapProductToString([], this.#varBitSet));\r\n            else sopStrs.push(PMFuncs.productToString([], this.#varCount));\r\n        } else {\r\n            for (const product of this.#petrickSOP) {\r\n                if (this.#varBitSet)\r\n                    sopStrs.push(PMFuncs.mapProductToString(product, this.#varBitSet));\r\n                else sopStrs.push(PMFuncs.productToString(product, this.#varCount));\r\n            }\r\n        }\r\n        return sopStrs;\r\n    };\r\n\r\n    setExpression = (expression) => {\r\n        expression = expression.replace(/ /g, \"\");\r\n        let sSet = Recognizer.buildItems(expression, BoolExpression.#BOOL_GRAMMAR);\r\n        let invertedS = Parser.invertEarleySets(sSet, BoolExpression.#BOOL_GRAMMAR);\r\n        let parseTree = Parser.buildParseTree(\r\n            expression,\r\n            invertedS,\r\n            BoolExpression.#BOOL_GRAMMAR\r\n        );\r\n\r\n        if (parseTree !== null) {\r\n            this.#sSet = sSet;\r\n            this.#invertedS = invertedS;\r\n            this.#parseTree = parseTree;\r\n\r\n            this.#varBitSet = getVarBitSet(expression);\r\n            this.#varCount = this.#varBitSet.cardinality();\r\n            this.#minTerms = calculateMinTerms(parseTree, this.#varBitSet);\r\n        } else {\r\n            let [parsed, minTerms, dontCares] = QMFuncs.parseString(expression);\r\n            if (!parsed) {\r\n                this.#errorCode = -2;\r\n                return false;\r\n            }\r\n\r\n            let [validated, errorCode] = validateTerms(minTerms, dontCares);\r\n            if (!validated) {\r\n                this.#errorCode = errorCode;\r\n                return false;\r\n            }\r\n\r\n            this.#varCount = QMFuncs.getVariableCount(minTerms, dontCares);\r\n            this.#minTerms = minTerms;\r\n            this.#dontCares = dontCares;\r\n        }\r\n\r\n        if (this.#isLogged) {\r\n            this.#qmLog = [];\r\n            this.#pmLog = [];\r\n        }\r\n\r\n        this.#reduce();\r\n        this.#buildTruthTable();\r\n\r\n        return true;\r\n    };\r\n\r\n    setMinTerms = (minTerms, dontCares) => {\r\n        let [success, errorCode] = validateTerms(minTerms, dontCares);\r\n        if (!success) {\r\n            this.#errorCode = errorCode;\r\n            return false;\r\n        }\r\n\r\n        this.#minTerms = minTerms;\r\n        this.#dontCares = dontCares;\r\n        this.#varCount = QMFuncs.getVariableCount(minTerms, dontCares);\r\n\r\n        this.#sSet = null;\r\n        this.expression = null;\r\n        this.#invertedS = null;\r\n        this.#parseTree = null;\r\n        this.#varBitSet = null;\r\n\r\n        if (this.#isLogged) {\r\n            this.#qmLog = [];\r\n            this.#pmLog = [];\r\n        }\r\n\r\n        this.#reduce();\r\n        this.#buildTruthTable();\r\n\r\n        return true;\r\n    };\r\n\r\n    #reduce = () => {\r\n        let nonEssentialPrimeImps = QMFuncs.getPrimeImplicants(\r\n            this.#minTerms,\r\n            this.#dontCares,\r\n            this.#qmLog\r\n        );\r\n\r\n        this.#petrickSOP = PMFuncs.getPetrickSOP(\r\n            nonEssentialPrimeImps,\r\n            this.#minTerms,\r\n            this.#pmLog\r\n        );\r\n\r\n        this.#primeImps = QMFuncs.getEssentialTerms(\r\n            nonEssentialPrimeImps,\r\n            this.#minTerms\r\n        );\r\n    };\r\n\r\n    #buildTruthTable = () => {\r\n        this.#truthTable = [];\r\n\r\n        let varRow = [\"#\"];\r\n        if (this.#varBitSet) {\r\n            let setBits = this.#varBitSet.toArray();\r\n            for (const bit of setBits) {\r\n                varRow.push(String.fromCharCode(bit + 65));\r\n            }\r\n        } else {\r\n            for (let i = 0; i < this.#varCount; i++) {\r\n                varRow.push(String.fromCharCode(i + 65));\r\n            }\r\n        }\r\n        varRow.push(\"Output\");\r\n        this.#truthTable.push(varRow);\r\n\r\n        let rowCount = 2 ** this.#varCount;\r\n        for (let i = 0; i < rowCount; i++) {\r\n            let row = [i];\r\n            let bits = new BitSet(i);\r\n            for (let j = 0; j < this.#varCount; j++) {\r\n                row.push(parseInt(bits.get(this.#varCount - 1 - j)));\r\n            }\r\n            row.push(this.isMinTerm(i) ? \"1\" : \"0\");\r\n            this.#truthTable.push(row);\r\n        }\r\n    };\r\n\r\n    toString = () => {\r\n        if (this.#expression) return this.#expression;\r\n\r\n        let str = \"m(\";\r\n        for (const term of this.#minTerms) str += parseInt(term) + \" \";\r\n        str = str.substr(0, str.length - 1) + \")\";\r\n\r\n        if (this.#dontCares.length) {\r\n            str += \"+d(\";\r\n            for (const term of this.#dontCares) str += parseInt(term) + \" \";\r\n            str = str.substr(0, str.length - 1) + \")\";\r\n        }\r\n\r\n        return str;\r\n    };\r\n\r\n    isEssentialImplicant(qmTerm) {\r\n        return this.#primeImps.some((e) => QMFuncs.isQMTermEqual(qmTerm, e));\r\n    }\r\n\r\n    isMinTerm(intTerm) {\r\n        return this.#minTerms.includes(intTerm);\r\n    }\r\n\r\n    isDontCare(intTerm) {\r\n        return this.#dontCares.includes(intTerm);\r\n    }\r\n}\r\n","import { Table } from \"react-bootstrap\";\r\n\r\nexport default function OperatorTable(props) {\r\n    return (\r\n        <Table className={props.className} borderless hover responsive size=\"sm\">\r\n            <thead className={props.headClass}>\r\n                <tr className=\"text-center\">\r\n                    <th>Operator</th>\r\n                    <th>Symbol</th>\r\n                </tr>\r\n            </thead>\r\n            <tbody className={props.bodyClass}>\r\n                <tr className=\"text-center\">\r\n                    <td>Not</td>\r\n                    <td>~</td>\r\n                </tr>\r\n                <tr className=\"text-center\">\r\n                    <td>And</td>\r\n                    <td>*</td>\r\n                </tr>\r\n                <tr className=\"text-center\">\r\n                    <td>Or</td>\r\n                    <td>+</td>\r\n                </tr>\r\n                <tr className=\"text-center\">\r\n                    <td>Xor</td>\r\n                    <td>^</td>\r\n                </tr>\r\n                <tr className=\"text-center\">\r\n                    <td>Nor</td>\r\n                    <td>%</td>\r\n                </tr>\r\n                <tr className=\"text-center\">\r\n                    <td>Nand</td>\r\n                    <td>@</td>\r\n                </tr>\r\n            </tbody>\r\n        </Table>\r\n    );\r\n}\r\n","import React from \"react\";\r\nimport { ButtonGroup, Button } from \"react-bootstrap\";\r\n\r\nexport default function ExampleGroup(props) {\r\n    let it = 0;\r\n    let end = props.examples.length - 1;\r\n    return (\r\n        <ButtonGroup\r\n            vertical\r\n            className={\"special \" + (props.className ? props.className : \"\")}\r\n        >\r\n            {props.examples.map((e) => {\r\n                return (\r\n                    <React.Fragment key={e + \"-fragment\"}>\r\n                        <Button\r\n                            onClick={() => props.handleExample(e)}\r\n                            size=\"sm\"\r\n                            variant=\"secondary\"\r\n                            key={e}\r\n                        >\r\n                            {e}\r\n                        </Button>\r\n                        {it++ !== end && (\r\n                            <Button\r\n                                disabled\r\n                                className=\"mt-0 mb-0 pt-0 pb-0\"\r\n                                size=\"sm\"\r\n                                variant=\"secondary\"\r\n                            ></Button>\r\n                        )}\r\n                    </React.Fragment>\r\n                );\r\n            })}\r\n        </ButtonGroup>\r\n    );\r\n}\r\n","import { Col, Row, Accordion } from \"react-bootstrap\";\r\nimport OperatorTable from \"./OperatorTable\";\r\nimport ExampleGroup from \"./ExampleGroup\";\r\n\r\nconst EXAMPLES_1 = [\"A\", \"~A\", \"~~A\", \"A * ~A\"];\r\nconst EXAMPLES_2 = [\"A + 1\", \"A + 0\", \"A + B\", \"A + ~B\"];\r\nconst EXAMPLES_3 = [\r\n    \"m(2, 3, 7, 9, 11, 13)\",\r\n    \"m(2, 3, 7, 9, 11, 13) + d(1, 10, 15)\",\r\n    \"~(A^C)@(B%D)\",\r\n    \"(A+~C+B*D)*(~A+(~B+D)*(C+~D))\",\r\n];\r\n\r\nexport default function AboutAccordion(props) {\r\n    let handleClick = (e) => {\r\n        props.onClick(e);\r\n    };\r\n\r\n    return (\r\n        <Accordion defaultActiveKey=\"0\" flush>\r\n            <Accordion.Item eventKey=\"0\">\r\n                <Accordion.Header>\r\n                    <p>\r\n                        Operator Symbols <b>/</b> Examples <b>/</b> About\r\n                    </p>\r\n                </Accordion.Header>\r\n\r\n                <Accordion.Body>\r\n                    <Row>\r\n                        <Col className=\"align-self-center pt-3\">\r\n                            <OperatorTable\r\n                                bodyClass=\"bg-white\"\r\n                                headClass=\"table-header-dark\"\r\n                            />\r\n                        </Col>\r\n                        <Col md={8}>\r\n                            <Row xs={1}>\r\n                                <Row>\r\n                                    <h4 className=\"text-center\">\r\n                                        <strong>About</strong>\r\n                                    </h4>\r\n                                    <p style={{ textIndent: \"20px\" }}>\r\n                                        This application can simplifiy either a boolean\r\n                                        algebra expression or a set of minimum terms and\r\n                                        \"don't care\" terms. Both\r\n                                        <b> Quine McCluskey's Algorithm</b> and\r\n                                        <b> Petrick's Method</b> are utilized to reduce an\r\n                                        expression to it's minimum sum-of-products. An\r\n                                        <b> Earley Parser</b> is used to parse expressions\r\n                                        given by the user. This project and the Earley\r\n                                        Parser were written by <b>Andrew Miner</b>.{\" \"}\r\n                                        <a href=\"https://github.com/Andrew-Miner/Bool-Simplifier-Website\">\r\n                                            Check out the GitHub!\r\n                                        </a>\r\n                                    </p>\r\n                                </Row>\r\n                                <Col md={3}>\r\n                                    <ExampleGroup\r\n                                        examples={EXAMPLES_1}\r\n                                        handleExample={handleClick}\r\n                                        className=\"mt-3\"\r\n                                        key=\"examples_1\"\r\n                                    />\r\n                                </Col>\r\n                                <Col md={3}>\r\n                                    <ExampleGroup\r\n                                        examples={EXAMPLES_2}\r\n                                        handleExample={handleClick}\r\n                                        className=\"mt-3\"\r\n                                        key=\"examples_2\"\r\n                                    />\r\n                                </Col>\r\n                                <Col md={6}>\r\n                                    <ExampleGroup\r\n                                        examples={EXAMPLES_3}\r\n                                        handleExample={handleClick}\r\n                                        className=\"mt-3\"\r\n                                        key=\"examples_3\"\r\n                                    />\r\n                                </Col>\r\n                            </Row>\r\n                        </Col>\r\n                    </Row>\r\n                </Accordion.Body>\r\n            </Accordion.Item>\r\n        </Accordion>\r\n    );\r\n}\r\n","import React from \"react\";\r\nimport { InputGroup, FormControl, Button, Form, Col } from \"react-bootstrap\";\r\nimport BoolExpression from \"../scripts/BooleanSimplifier/BoolExpression\";\r\nimport AboutAccordion from \"./AboutAccordion\";\r\n\r\nclass ExpressionForm extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            expValue: \"\",\r\n            isInvalid: false,\r\n            errorMsg: \"Invalid Expression\",\r\n        };\r\n        this.expression = null;\r\n    }\r\n\r\n    handleChange = (event) => {\r\n        this.setState({ expValue: event.target.value });\r\n    };\r\n\r\n    handleSubmit = (event) => {\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n        try {\r\n            this.expression = BoolExpression.ExpressionInstance(\r\n                this.state.expValue,\r\n                true\r\n            );\r\n            this.setState({ isInvalid: false }, () => {\r\n                this.props.displayExpression(this.expression);\r\n            });\r\n        } catch (error) {\r\n            this.setState({ isInvalid: true, errorMsg: \"Error: \" + error.message + \"!\" });\r\n        }\r\n    };\r\n\r\n    displayExpression = (str) => {\r\n        try {\r\n            this.expression = BoolExpression.ExpressionInstance(str, true);\r\n            this.setState({ isInvalid: false, expValue: str }, () => {\r\n                this.props.displayExpression(this.expression);\r\n            });\r\n        } catch (error) {\r\n            this.setState({\r\n                isInvalid: true,\r\n                expValue: str,\r\n                errorMsg: \"Error: \" + error.message + \"!\",\r\n            });\r\n        }\r\n    };\r\n\r\n    render() {\r\n        return (\r\n            <>\r\n                <Form\r\n                    noValidate\r\n                    validated={this.state.validated}\r\n                    onSubmit={this.handleSubmit}\r\n                >\r\n                    <Form.Group as={Col} controlId=\"expressionForm\">\r\n                        <InputGroup hasValidation>\r\n                            <FormControl\r\n                                required\r\n                                placeholder=\"Enter Expression\"\r\n                                aria-label=\"Enter Expression\"\r\n                                aria-describedby=\"basic-addon\"\r\n                                onChange={this.handleChange}\r\n                                isInvalid={this.state.isInvalid}\r\n                                value={this.state.expValue}\r\n                            />\r\n                            <Button variant=\"secondary\" id=\"button-addon\" type=\"submit\">\r\n                                Simplify\r\n                            </Button>\r\n                            <Form.Control.Feedback type=\"invalid\">\r\n                                {this.state.errorMsg}\r\n                            </Form.Control.Feedback>\r\n                        </InputGroup>\r\n                    </Form.Group>\r\n                    <AboutAccordion onClick={this.displayExpression} />\r\n                </Form>\r\n            </>\r\n        );\r\n    }\r\n}\r\n\r\nexport default ExpressionForm;\r\n","import React from \"react\";\r\nimport { Badge, Card } from \"react-bootstrap\";\r\nimport QM from \"../scripts/BooleanSimplifier/QMFunctions\";\r\n\r\nexport default function QMCard(props) {\r\n    let it = 0;\r\n    let end = props.qmterms.length - 1;\r\n\r\n    let getMinTermColor = (minTerm) => {\r\n        if (!props.expression) return \"info\";\r\n        if (props.expression.isMinTerm(minTerm)) return \"primary\";\r\n        if (props.expression.isDontCare(minTerm)) return \"danger\";\r\n        return \"info\";\r\n    };\r\n\r\n    let getImplicantColor = (qmTerm) => {\r\n        if (!props.expression) return \"warning\";\r\n        if (props.expression.isEssentialImplicant(qmTerm)) return \"success\";\r\n        return \"warning\";\r\n    };\r\n\r\n    return (\r\n        <Card>\r\n            <Card.Header as=\"h4\" className={props.headerClass}>\r\n                {props.title}\r\n            </Card.Header>\r\n            <Card.Body className={props.bodyClass}>\r\n                {props.qmterms.map((term) => {\r\n                    return (\r\n                        <React.Fragment\r\n                            key={term.term.toString() + \"-\" + term.dashMask.toString()}\r\n                        >\r\n                            <div className=\"mb-1 mt-2 d-flex justify-content-between\">\r\n                                <div className=\"\">\r\n                                    {\"(\"}\r\n                                    {(() => {\r\n                                        const minTerms = QM.extractMinTerms(term);\r\n                                        const end = minTerms.length - 1;\r\n                                        let it = 0;\r\n                                        return QM.extractMinTerms(term).map((minTerm) => (\r\n                                            <React.Fragment key={minTerm}>\r\n                                                <Badge pill bg={getMinTermColor(minTerm)}>\r\n                                                    {minTerm}\r\n                                                </Badge>\r\n                                                {it++ !== end && \",\"}\r\n                                            </React.Fragment>\r\n                                        ));\r\n                                    })()}\r\n                                    {\")\"}\r\n                                </div>\r\n                                <div className=\"\">\r\n                                    <Badge bg={getImplicantColor(term)} className=\"ml-1\">\r\n                                        {QM.toString(term, props.varCount)}\r\n                                    </Badge>\r\n                                </div>\r\n                            </div>\r\n                            {it++ !== end && <hr className=\"m-0\" />}\r\n                        </React.Fragment>\r\n                    );\r\n                })}\r\n            </Card.Body>\r\n        </Card>\r\n    );\r\n}\r\n","import QMCard from \"./QMCard\";\r\nimport { Col } from \"react-bootstrap\";\r\n\r\nexport default function QMLog(props) {\r\n    let iterationCount = 0;\r\n    return props.expression.getQMLog().map((qmTerms) => {\r\n        qmTerms.reverse();\r\n        return (\r\n            <Col\r\n                className={props.className}\r\n                key={\"Iteration-\" + parseInt(iterationCount)}\r\n            >\r\n                <QMCard\r\n                    title={\"Iteration #\" + parseInt(iterationCount++)}\r\n                    qmterms={qmTerms}\r\n                    varCount={props.expression.getVarCount()}\r\n                    expression={props.expression}\r\n                />\r\n            </Col>\r\n        );\r\n    });\r\n}\r\n","import React from \"react\";\r\nimport { Card } from \"react-bootstrap\";\r\n\r\nexport default function PMLog(props) {\r\n    let it = 0;\r\n    let end = props.log.length - 1;\r\n    return (\r\n        <Card>\r\n            <Card.Header as=\"h4\">{props.title}</Card.Header>\r\n            <Card.Body>\r\n                {props.log.map((exp) => {\r\n                    return (\r\n                        <React.Fragment key={it}>\r\n                            <div className=\"mb-1 mt-2\">\r\n                                {it !== end ? exp : exp.substring(1, exp.length - 1)}\r\n                            </div>\r\n                            {it++ !== end && <hr className=\"m-0\" />}\r\n                        </React.Fragment>\r\n                    );\r\n                })}\r\n            </Card.Body>\r\n        </Card>\r\n    );\r\n}\r\n","export default __webpack_public_path__ + \"static/media/copyoutlined.07adfd96.svg\";","import React from \"react\";\r\nimport { Row, Col, Card, Badge } from \"react-bootstrap\";\r\nimport CopyIco from \"../copyoutlined.svg\";\r\n\r\nexport default function SOPCard(props) {\r\n    let onClick = (event) => {\r\n        let sops = props.expression.getSOPStrings();\r\n\r\n        let end = sops.length - 1;\r\n        let str = \"\";\r\n        for (let i = 0; i < sops.length; i++) {\r\n            str += sops[i];\r\n            if (i !== end) str += \" | \";\r\n        }\r\n        let textField = document.createElement(\"textarea\");\r\n        textField.innerText = str;\r\n        document.body.appendChild(textField);\r\n        textField.select();\r\n        document.execCommand(\"copy\");\r\n        textField.remove();\r\n    };\r\n\r\n    return (\r\n        <Card>\r\n            <Card.Header className={props.headerClass}>\r\n                <button\r\n                    onClick={onClick}\r\n                    style={{ background: \"transparent\", border: \"none\", color: \"white\" }}\r\n                >\r\n                    <h4>\r\n                        {props.title}\r\n                        <img src={CopyIco} alt=\"Copy Icon\" width=\"32\" height=\"25\" />\r\n                    </h4>\r\n                </button>\r\n            </Card.Header>\r\n            <Card.Body className={props.bodyClass}>\r\n                <Row>\r\n                    {props.expression.getSOPStrings().map((sop) => (\r\n                        <React.Fragment key={sop}>\r\n                            <Col\r\n                                as=\"h5\"\r\n                                className=\"d-flex d-none d-md-flex justify-content-center  mb-2\"\r\n                            >\r\n                                <Badge pill bg=\"primary\">\r\n                                    {sop}\r\n                                </Badge>\r\n                            </Col>\r\n                            <Col\r\n                                as=\"h5\"\r\n                                className=\"d-flex d-md-none justify-content-left mb-2\"\r\n                            >\r\n                                <Badge pill bg=\"primary\">\r\n                                    {sop}\r\n                                </Badge>\r\n                            </Col>\r\n                        </React.Fragment>\r\n                    ))}\r\n                </Row>\r\n            </Card.Body>\r\n        </Card>\r\n    );\r\n}\r\n","import { Table } from \"react-bootstrap\";\r\n\r\nconst OUTPUT_STYE = {\r\n    borderLeft: \"3px inset\",\r\n};\r\n\r\nexport default function TruthTable(props) {\r\n    let table = props.table.slice();\r\n    let header = table[0];\r\n    table.splice(0, 1);\r\n\r\n    let rowCount = 1;\r\n    return (\r\n        <Table className={props.className} striped bordered hover size=\"sm\">\r\n            <thead>\r\n                <TruthHeader row={header} />\r\n            </thead>\r\n            <tbody>\r\n                {table.map((row) => (\r\n                    <TruthRow key={rowCount} rowNumber={rowCount++} row={row} />\r\n                ))}\r\n            </tbody>\r\n        </Table>\r\n    );\r\n}\r\n\r\nfunction TruthHeader(props) {\r\n    let it = 0;\r\n    let end = props.row.length - 1;\r\n    return (\r\n        <tr>\r\n            {props.row.map((e) => {\r\n                if (it++ === end)\r\n                    return (\r\n                        <th className=\"text-center\" key={e} style={OUTPUT_STYE}>\r\n                            {e}\r\n                        </th>\r\n                    );\r\n                return (\r\n                    <th key={e} className=\"text-center\">\r\n                        {e}\r\n                    </th>\r\n                );\r\n            })}\r\n        </tr>\r\n    );\r\n}\r\n\r\nfunction TruthRow(props) {\r\n    let it = 0;\r\n    let end = props.row.length - 1;\r\n    return (\r\n        <tr>\r\n            {props.row.map((e) => {\r\n                if (it === 0) {\r\n                    it++;\r\n                    return (\r\n                        <th\r\n                            key={parseInt(props.rowCount) + \"-\" + parseInt(it - 1)}\r\n                            className=\"text-center\"\r\n                        >\r\n                            {e}\r\n                        </th>\r\n                    );\r\n                }\r\n\r\n                if (it === end) {\r\n                    it++;\r\n                    return (\r\n                        <td\r\n                            key={parseInt(props.rowCount) + \"-\" + parseInt(it - 1)}\r\n                            className=\"text-center\"\r\n                            style={OUTPUT_STYE}\r\n                        >\r\n                            {e}\r\n                        </td>\r\n                    );\r\n                }\r\n\r\n                it++;\r\n                return (\r\n                    <td\r\n                        key={parseInt(props.rowCount) + \"-\" + parseInt(it - 1)}\r\n                        className=\"text-center\"\r\n                    >\r\n                        {e}\r\n                    </td>\r\n                );\r\n            })}\r\n        </tr>\r\n    );\r\n}\r\n","import TruthTable from \"./TruthTable\";\r\nimport { Card } from \"react-bootstrap\";\r\n\r\nexport default function TTCard(props) {\r\n    return (\r\n        <Card>\r\n            <Card.Header as=\"h4\" className={props.bodyClass}>\r\n                {props.title}\r\n            </Card.Header>\r\n            <Card.Body className={\"p-0 \" + (props.bodyClass ? props.bodyClass : \"\")}>\r\n                <TruthTable className=\"m-0\" table={props.table} />\r\n            </Card.Body>\r\n        </Card>\r\n    );\r\n}\r\n","import { Table } from \"react-bootstrap\";\r\nimport { Badge } from \"react-bootstrap\";\r\nimport PM from \"../scripts/BooleanSimplifier/PMFunctions\";\r\nimport QM from \"../scripts/BooleanSimplifier/QMFunctions\";\r\n\r\nexport default function ImplicantTable(props) {\r\n    let minTerms = props.expression.getMinTerms();\r\n    minTerms.reverse();\r\n\r\n    let primeImps = props.expression.getEssentialImplicants();\r\n    let groups = PM.groupPrimeImplicants(primeImps, minTerms); // map\r\n\r\n    const VAR_OFFSET = 10;\r\n    let varCount = 0;\r\n    return (\r\n        <Table className={props.className} striped bordered hover>\r\n            <thead>\r\n                <tr>\r\n                    <th className=\"text-center\">Petrick Variable</th>\r\n                    <th className=\"text-center\">Essential Implicant</th>\r\n                    {minTerms.map((term) => {\r\n                        let group = groups.get(term);\r\n\r\n                        if (group === undefined)\r\n                            throw new Error(\r\n                                \"undefined prime implicant group [\" + parseInt(term) + \"]\"\r\n                            );\r\n\r\n                        let cName = \"text-center\";\r\n                        if (group.length === 1) cName += \" success-cell\";\r\n\r\n                        return (\r\n                            <th className={cName} key={term}>\r\n                                <Badge pill bg=\"primary\" className=\"ml-1\">\r\n                                    {term}\r\n                                </Badge>\r\n                            </th>\r\n                        );\r\n                    })}\r\n                </tr>\r\n            </thead>\r\n            <tbody>\r\n                {primeImps.map((imp) => (\r\n                    <ImpRow\r\n                        implicant={imp}\r\n                        minTerms={minTerms}\r\n                        implicantGroups={groups}\r\n                        varCount={props.expression.getVarCount()}\r\n                        variable={String.fromCharCode(\r\n                            ((varCount++ + VAR_OFFSET) % 26) + 65\r\n                        )}\r\n                        key={imp.term.toString() + \"-\" + imp.dashMask.toString() + \"-row\"}\r\n                    />\r\n                ))}\r\n            </tbody>\r\n        </Table>\r\n    );\r\n}\r\n\r\nfunction ImpRow(props) {\r\n    let impMinTerms = QM.extractMinTerms(props.implicant);\r\n    return (\r\n        <tr>\r\n            <td className=\"text-center\">\r\n                <strong>{props.variable}</strong>\r\n            </td>\r\n            <td className=\"text-center\">\r\n                <Badge bg=\"success\" className=\"ml-1\">\r\n                    {QM.toString(props.implicant, props.varCount)}\r\n                </Badge>\r\n            </td>\r\n            {props.minTerms.map((term) => {\r\n                let group = props.implicantGroups.get(term);\r\n\r\n                if (group === undefined)\r\n                    throw new Error(\r\n                        \"undefined prime implicant group [\" + parseInt(term) + \"]\"\r\n                    );\r\n\r\n                let cName = \"text-center\";\r\n                if (group.length === 1) cName += \" success-cell\";\r\n\r\n                if (impMinTerms.includes(term)) {\r\n                    if (group.length === 1) {\r\n                        return (\r\n                            <td\r\n                                className={cName}\r\n                                key={\r\n                                    parseInt(term) +\r\n                                    \"-\" +\r\n                                    QM.toString(props.implicant, props.varCount)\r\n                                }\r\n                            >\r\n                                <Badge pill bg=\"danger\" className=\"ml-1\">\r\n                                    <strong>X</strong>\r\n                                </Badge>\r\n                            </td>\r\n                        );\r\n                    } else {\r\n                        return (\r\n                            <td\r\n                                key={\r\n                                    parseInt(term) +\r\n                                    \"-\" +\r\n                                    QM.toString(props.implicant, props.varCount)\r\n                                }\r\n                                className={cName}\r\n                            >\r\n                                <strong>X</strong>\r\n                            </td>\r\n                        );\r\n                    }\r\n                }\r\n\r\n                return (\r\n                    <td\r\n                        className={cName}\r\n                        key={\r\n                            parseInt(term) +\r\n                            \"-\" +\r\n                            QM.toString(props.implicant, props.varCount)\r\n                        }\r\n                    ></td>\r\n                );\r\n            })}\r\n        </tr>\r\n    );\r\n}\r\n","import ImplicantTable from \"./ImplicantTable\";\r\nimport { Card } from \"react-bootstrap\";\r\n\r\nexport default function ITCard(props) {\r\n    return (\r\n        <Card>\r\n            <Card.Header as=\"h4\" className={props.bodyClass}>\r\n                {props.title}\r\n            </Card.Header>\r\n            <Card.Body className={\"p-0 \" + (props.bodyClass ? props.bodyClass : \"\")}>\r\n                <ImplicantTable className=\"m-0\" expression={props.expression} />\r\n            </Card.Body>\r\n        </Card>\r\n    );\r\n}\r\n","import React from \"react\";\nimport ExpressionForm from \"./components/ExpressionForm\";\nimport { Container, Row, Col } from \"react-bootstrap\";\nimport QMCard from \"./components/QMCard\";\nimport QMLog from \"./components/QMLog\";\nimport PMLog from \"./components/PMLog\";\nimport SOPCard from \"./components/SOPCard\";\nimport TTCard from \"./components/TTCard\";\nimport ITCard from \"./components/ITCard\";\n\nimport \"bootstrap/dist/css/bootstrap.min.css\";\nimport \"./App.css\";\n\nclass App extends React.Component {\n    state = { expression: null, formValue: null };\n\n    displayExpression = (expression) => {\n        this.setState({ expression: expression });\n    };\n\n    render() {\n        return (\n            <>\n                <Container>\n                    <div className=\"py-5\">\n                        <h2>Boolean Algebra Simplifier</h2>\n                        <ExpressionForm\n                            value={this.state.formValue}\n                            displayExpression={this.displayExpression}\n                        />\n                    </div>\n                    {this.state.expression !== null && (\n                        <>\n                            <Row>\n                                <Col>\n                                    <SOPCard\n                                        expression={this.state.expression}\n                                        title=\"Minimum Sum-Of-Products Solution\"\n                                        bodyClass=\"scroll\"\n                                    />\n                                </Col>\n                            </Row>\n                            <Row>\n                                <Col className=\"mt-5\">\n                                    <TTCard\n                                        title=\"Truth Table\"\n                                        table={this.state.expression.getTruthTable()}\n                                        bodyClass=\"scroll\"\n                                    />\n                                </Col>\n                            </Row>\n                            {this.state.expression.getMinTerms().length !== 0 && (\n                                <>\n                                    <Row>\n                                        <Col className=\"mt-5\">\n                                            <QMCard\n                                                qmterms={this.state.expression.getEssentialImplicants()}\n                                                varCount={this.state.expression.getVarCount()}\n                                                expression={this.state.expression}\n                                                title=\"Essential Prime Implicants\"\n                                            />\n                                        </Col>\n                                    </Row>\n                                    <Row\n                                        xs={1}\n                                        md={\n                                            this.state.expression.getQMLog().length > 3\n                                                ? 3\n                                                : this.state.expression.getQMLog().length\n                                        }\n                                    >\n                                        <QMLog\n                                            expression={this.state.expression}\n                                            className=\"mt-5\"\n                                        />\n                                    </Row>\n                                    <Row>\n                                        <Col className=\"mt-5\">\n                                            <ITCard\n                                                title=\"Essential Prime Implicant Chart\"\n                                                expression={this.state.expression}\n                                                bodyClass=\"scroll\"\n                                            />\n                                        </Col>\n                                    </Row>\n                                    <Row>\n                                        <Col className=\"mt-5\">\n                                            <PMLog\n                                                log={this.state.expression.getPMLog()}\n                                                title=\"Petrick's Method\"\n                                            />\n                                        </Col>\n                                    </Row>\n                                </>\n                            )}\n                        </>\n                    )}\n                </Container>\n                <br />\n            </>\n        );\n    }\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n","/* eslint-disable no-eval */\r\n\r\nimport StructFactory from \"../StructFactory\";\r\nimport { Terminal, NonTerminal } from \"./Symbol\";\r\n\r\nexport const EarleyItem = StructFactory(\"rule next start\");\r\nexport const Grammar = StructFactory(\"startRule rules\");\r\nexport const Rule = StructFactory(\"name definition\");\r\n\r\nexport const testG2 = new Grammar(\"A\", [\r\n    new Rule(\"A\", [new NonTerminal(\"A\"), new Terminal(\"a\")]),\r\n    new Rule(\"A\", []),\r\n]);\r\n\r\nexport const testG = new Grammar(\"Sum\", [\r\n    new Rule(\"Sum\", [\r\n        new NonTerminal(\"Sum\"),\r\n        new Terminal([\"+\", \"-\"]),\r\n        new NonTerminal(\"Product\"),\r\n    ]),\r\n\r\n    new Rule(\"Sum\", [new NonTerminal(\"Product\")]),\r\n\r\n    new Rule(\"Product\", [\r\n        new NonTerminal(\"Product\"),\r\n        new Terminal([\"*\", \"/\"]),\r\n        new NonTerminal(\"Factor\"),\r\n    ]),\r\n\r\n    new Rule(\"Product\", [new NonTerminal(\"Factor\")]),\r\n\r\n    new Rule(\"Factor\", [new Terminal(\"(\"), new NonTerminal(\"Sum\"), new Terminal(\")\")]),\r\n\r\n    new Rule(\"Factor\", [new NonTerminal(\"Number\")]),\r\n    new Rule(\"Number\", [\r\n        new NonTerminal(\"Number\"),\r\n        new Terminal([\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]),\r\n    ]),\r\n\r\n    new Rule(\"Number\", [\r\n        new Terminal([\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]),\r\n    ]),\r\n]);\r\n\r\nexport const testAactionsA = [\r\n    (lOperand, op, rOperand) => [lOperand, op, rOperand],\r\n    (product) => product,\r\n    (lOperand, op, rOperand) => [lOperand, op, rOperand],\r\n    (factor) => factor,\r\n    (lParen, sum, rParen) => sum,\r\n    (number) => number,\r\n    (num1, num2) => num1 + num2,\r\n    (number) => number,\r\n];\r\n\r\nexport const testAactionsB = [\r\n    (lOperand, op, rOperand) => eval(lOperand + op + rOperand),\r\n    (product) => product,\r\n    (lOperand, op, rOperand) => eval(lOperand + op + rOperand),\r\n    (factor) => factor,\r\n    (lParen, sum, rParen) => sum,\r\n    (number) => number,\r\n    (num1, num2) => num1 + num2,\r\n    (number) => number,\r\n];\r\n\r\nconst EarleyRecognizer = {\r\n    buildItems(input, grammar) {\r\n        let nullableSet = this.getNullableRules(grammar);\r\n        let s = [[]];\r\n\r\n        for (let i = 0; i < grammar.rules.length; i++) {\r\n            if (grammar.rules[i].name === grammar.startRule) {\r\n                s[0].push(new EarleyItem(i, 0, 0));\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < s.length; i++) {\r\n            for (let j = 0; j < s[i].length; j++) {\r\n                let symbol = this.nextSymbol(s[i][j], grammar);\r\n                if (symbol === null) this.complete(s, i, j, grammar);\r\n                else if (symbol instanceof Terminal) this.scan(s, i, j, symbol, input);\r\n                else if (symbol instanceof NonTerminal)\r\n                    this.predict(s, i, j, symbol, nullableSet, grammar);\r\n                else throw new Error(\"illegal rule\");\r\n            }\r\n        }\r\n\r\n        return s;\r\n    },\r\n\r\n    nextSymbol(item, grammar) {\r\n        if (grammar.rules[item.rule].definition.length <= item.next) return null;\r\n        return grammar.rules[item.rule].definition[item.next];\r\n    },\r\n\r\n    complete(s, i, j, grammar) {\r\n        let item = s[i][j];\r\n        for (let k = 0; k < s[item.start].length; k++) {\r\n            let nextSym = this.nextSymbol(s[item.start][k], grammar);\r\n            if (nextSym !== null && nextSym.match(grammar.rules[item.rule].name))\r\n                this.appendItem(\r\n                    s[i],\r\n                    new EarleyItem(\r\n                        s[item.start][k].rule,\r\n                        s[item.start][k].next + 1,\r\n                        s[item.start][k].start\r\n                    )\r\n                );\r\n        }\r\n    },\r\n\r\n    scan(s, i, j, symbol, input) {\r\n        if (i >= input.length) return;\r\n\r\n        let item = s[i][j];\r\n        if (symbol.match(input.substring(i, i + 1))) {\r\n            if (i + 1 > s.length - 1) s.push([]);\r\n\r\n            s[i + 1].push(new EarleyItem(item.rule, item.next + 1, item.start));\r\n        }\r\n    },\r\n\r\n    predict(s, i, j, symbol, nss, grammar) {\r\n        for (let k = 0; k < grammar.rules.length; k++) {\r\n            if (symbol.match(grammar.rules[k].name)) {\r\n                this.appendItem(s[i], new EarleyItem(k, 0, i));\r\n                // magical completion\r\n                if (nss.has(grammar.rules[k].name))\r\n                    this.appendItem(\r\n                        s[i],\r\n                        new EarleyItem(s[i][j].rule, s[i][j].next + 1, s[i][j].start)\r\n                    );\r\n            }\r\n        }\r\n    },\r\n\r\n    appendItem(items, item) {\r\n        for (const it of items) {\r\n            if (JSON.stringify(it) === JSON.stringify(item)) return false;\r\n        }\r\n        items.push(item);\r\n        return true;\r\n    },\r\n\r\n    getNullableRules(grammar) {\r\n        let nullableSet = new Set();\r\n        let oldSize = 0;\r\n        do {\r\n            oldSize = nullableSet.size;\r\n            this.updateNullableSet(nullableSet, grammar);\r\n        } while (oldSize !== nullableSet.size);\r\n        return nullableSet;\r\n    },\r\n\r\n    updateNullableSet(nullableSet, grammar) {\r\n        for (let i = 0; i < grammar.rules.length; i++) {\r\n            if (this.isNullable(grammar.rules[i], nullableSet))\r\n                nullableSet.add(grammar.rules[i].name);\r\n        }\r\n    },\r\n\r\n    isNullable(rule, nullableSet) {\r\n        for (let i = 0; i < rule.definition.length; i++) {\r\n            if (nullableSet.has(rule.definition[i].toString()) === false) return false;\r\n        }\r\n        return true;\r\n    },\r\n\r\n    printEarlySets(s, g, hideIncomplete = false) {\r\n        let lines = [];\r\n        let maxDefLen = 0;\r\n        let maxNameLen = 0;\r\n\r\n        for (let i = 0; i < s.length; i++) {\r\n            lines.push([]);\r\n            for (let j = 0; j < s[i].length; j++) {\r\n                let item = s[i][j];\r\n                let ruleDef = \"\";\r\n                let ruleName = \"\";\r\n\r\n                if (item.rule > -1) {\r\n                    let rule = g.rules[item.rule];\r\n                    ruleName = rule.name;\r\n                    if (ruleName.length > maxNameLen) maxNameLen = ruleName.length;\r\n\r\n                    let defSize = rule.definition.length;\r\n                    for (let k = 0; k < defSize; k++) {\r\n                        if (k === item.next) ruleDef += \" @\";\r\n                        if (rule.definition[k] instanceof Terminal)\r\n                            ruleDef += \" \" + rule.definition[k].toString();\r\n                        else if (rule.definition[k] instanceof NonTerminal)\r\n                            ruleDef += \" \" + rule.definition[k].toString();\r\n                        else throw new Error(\"impossible symbol\");\r\n                    }\r\n                    if (item.next >= defSize) ruleDef += \" @\";\r\n                    else if (hideIncomplete) continue;\r\n\r\n                    if (ruleDef.length > maxDefLen) maxDefLen = ruleDef.length;\r\n                } else ruleDef = \"{\" + item.rule + \", \" + item.next + \"}\";\r\n\r\n                lines[i].push({\r\n                    name: ruleName,\r\n                    definition: ruleDef,\r\n                    start: \"(\" + item.start + \")\",\r\n                });\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < lines.length; i++) {\r\n            console.log(\"    === \" + i + \" ===\");\r\n            for (let j = 0; j < lines[i].length; j++) {\r\n                let l = lines[i][j];\r\n                let str = l.name.padEnd(maxNameLen, \" \") + \" -> \";\r\n                str += l.definition.padEnd(maxDefLen) + \" \" + l.start;\r\n                console.log(str);\r\n            }\r\n            if (i !== lines.length - 1) console.log(\" \");\r\n        }\r\n    },\r\n};\r\n\r\nexport default EarleyRecognizer;\r\n"],"sourceRoot":""}